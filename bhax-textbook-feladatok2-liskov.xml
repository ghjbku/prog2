<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Liskov!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
	
	<section>
<title>Liskov helyettesítés sértése</title>
        <para>Írjunk olyan OO, leforduló Java és C++ kódcsipetet, amely megsérti a Liskov elvet! Mutassunk rá a
megoldásra: jobb OO tervezés.
https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_1.pdf (93-99 fólia)
(számos példa szerepel az elv megsértésére az UDPROG repóban, lásd pl. source/binom/Batfai-
Barki/madarak/)</para>
<para>
            Megoldás forrása:<link xlink:href="https://github.com/ghjbku/prog2/tree/master/liskov">github link</link>              
        </para>
	</section>
	
	<section>
<title>Szülő-gyerek</title>
        <para>Írjunk Szülő-gyerek Java és C++ osztálydefiníciót, amelyben demonstrálni tudjuk, hogy az ősön
keresztül csak az ős üzenetei küldhetőek!
https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_1.pdf (98. fólia)</para>
	</section>

	<section>
<title>Anti OO</title>
        <para>A BBP algoritmussal 4 a Pi hexadecimális kifejtésének a 0. pozíciótól számított 10 6, 107, 108 darab
jegyét határozzuk meg C, C++, Java és C# nyelveken és vessük össze a futási időket!
https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apas03.html#id561066</para>
<para>
            Megoldás forrása:<link xlink:href="https://github.com/ghjbku/prog2/tree/master/liskov">github link</link>              
        </para>
		<figure>
            <title>A <type> 4 nyelv</type> futás</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="liskov/negy.png" scale="300" />
				  </imageobject>
                <textobject>
                    <phrase>A <type> 4 nyelv</type> futás</phrase>
                </textobject>
            </mediaobject>
        </figure> 
		<figure>
            <title>A <type> 4 nyelv</type> futás</title>
            <mediaobject>
                <imageobject>
					<imagedata fileref="liskov/antitabla.png" scale="200" />
                </imageobject>
                <textobject>
                    <phrase>A <type> 4 nyelv</type> futás</phrase>
                </textobject>
            </mediaobject>
        </figure> 
		<para>Mint láthatjuk, a JAVA mind 3 esetben a legjobban teljesített a számítások során.
		Különös viszont, hogy minél kisebb számjegyét keressük a pi-nek, annál gyorsabban végez a java a többiekhez képest.
		Második helyen a C# volt, nem sokkal lassabb,mint a Java, és a legutolsó a C nyelv.
		Minden 10-ed után kb. 10-szeresére nőtt a futási idő.
		A C fordításánál ügyelni kell arra, hogy a -lm kapcsolót is hozzáadjuk az argumentumok listájához, mivel anélkül nem fog lefordulni a program.
		A hibakód a következő:
		</para>
		<programlisting language="c"><![CDATA[/usr/bin/ld: /tmp/ccKOkIzA.o: in function `d16Sj':
anti_c.c:(.text+0xfe): undefined reference to `floor'
/usr/bin/ld: /tmp/ccKOkIzA.o: in function `main':
anti_c.c:(.text+0x1ff): undefined reference to `floor'
/usr/bin/ld: anti_c.c:(.text+0x227): undefined reference to `floor'
collect2: error: ld returned 1 exit status
]]></programlisting>
<para>A gcc dokumentációban csak annyi található az -lm kapcsolóról, hogy az -l kapcsoló 
paramétere az m, ez egy úgynevezett megosztott library, amely osztályokra van bonta, és objektumokat tartalmaz.
A mi esetünkben az m könyvtár tartalmát kívánjuk használni, amelyben a floor függvény található.
Ez a math lib.
Ha includeoljuk a math.h headert, akkor erre a kapcsolóra is szükségünk lesz.
Ez C++-ban már nem szükséges, elég csak az include.</para>
	</section>

	<section>
<title>Hello, Android!</title>
        <para>Élesszük fel az SMNIST for Humans projektet!
https://gitlab.com/nbatfai/smnist/tree/master/forHumans/SMNISTforHumansExp3/app/src/main
Apró módosításokat eszközölj benne, pl. színvilág.</para>
	</section>

	<section>
<title>Ciklomatikus komplexitás</title>
        <para>Számoljuk ki valamelyik programunk függvényeinek ciklomatikus komplexitását! Lásd a fogalom
tekintetében a https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_2.pdf (77-79
fóliát)!</para>
<para>A ciklomatikus komplexitás számításakor a beágyazott ciklusok azonos súllyal vannak számolva, mint a külső ciklusok.
Viszont valójában a belső ciklusok jelenlétével a programkód megértése nehezebb lesz.
Attól függetlenül, hogy a ciklusok száma szerint a program bonyolultsága alacsony kéne, hogy legyen, még lehet bonyolult a forráskód.
</para>
<para><command>a kódrészlet saját tulajdonban áll.</command></para>
<programlisting language="c++"><![CDATA[
void fight(int intel, int d)
{
	int i = 0;
	int j = 0;
	int k = 0;
	if (intel == 1)
	{
		cout << "you remember the paper you found had a bear drawing on it with three numbers: 5 2 4\n";
	}
	else if (intel == 0)
	{
	}
	cout << "the bear attacks first with a rush attack\nyou: 1.defend\n 2.side step to the right and try to hit its knee\n 3. back step\n 4.slash it with your sword \n5.side step to the left\n";
	cin >> i;
	if (i == 1)
	{
		cout << "you can`t defend without a shield, you died.";
	}
	else if (i == 2)
	{
		cout << "you try to dodge by sidestepping to right, but the bear somehow knows you would do that\nit slashes you and deals critical damage\nyou died.";
	}
	else if (i == 3)
	{
		cout << "you try to backstep, but why? \nthe bear doesn`t even have to turn anywhere, it easily kills you.\n";
	}
	else if (i == 4)
	{
		cout << "you slash the bear with your dagger as it reaches you\nyou dealt almost no damage.\nthe bear bites you with unbearable strength\nyou died";
	}
	else if (i == 5)
	{
		d++;
		cout << "you sidestep to the left,the bear, surprised lounges to the right.\nit hits nothing but air.\nthe bear,enraged even further try to attack you from the right.\n[decision making " << d << "]\nyou: ";
		cout << "1.defend\n 2.side step to the right and try to hit its knee\n 3. back step\n 4.slash it with your sword \n5.side step to the left\n";
		cin >> j;
		if (j == 1)
		{
			cout << "you can`t defend without a shield, you died.";
		}

		if (j == 2)
		{
			d++;
			cout << " you sidestep to the right,the bear surprised again, you use the momentum to slash its knees.\nthe bear falls to the ground.\n[decision making " << d << "]\n ";

			cout << "\nyou: 1.defend\n 2.side step to the right and try to hit its knee\n 3. back step\n 4.slash it with your sword \n5.side step to the left\n";
			cin >> k;
			if (k == 1)
			{
				cout << "why would you..?,you died...";
			}

			else if (k == 2)
			{
				cout << "why would you..?,you died...";
			}

			else if (k == 4)
			{
				d = d + 2;
				cout << "you slash the head of the bear while its down.\nyou dealt monsterous amount of damage.\nyou 1hit killed the bear.[decision making " << d << "]\n\n\nCongratulations, \nYou Won The Game!";
			}

			else if (k == 3)
			{
				cout << "why would you..?,you died...";
			}

			else if (k == 5)
			{
				cout << "why would you..?,you died...";
			}
		}

		if (j == 3)
		{
			cout << "you try to back step,and you succeed, but the bear somehow kicks you in the head and you die.";
		}

		if (j == 4)
		{
			cout << "you try to slash it with your sword, but do you think you hit harder than a bear?\nyou died from a pawn hit in the head.";
		}

		if (j == 5)
		{
			cout << "you try to sidestep to the left,but the bear remembers you doing that before,it turns toward you and slashes...\nyou died.";
		}
	}
}
]]></programlisting>
<figure>
            <title>A <type> ciklomatikus</type> ábra</title>
            <mediaobject>
                <imageobject>
					<imagedata fileref="liskov/ciklomatikus.png" scale="250" />
                </imageobject>
                <textobject>
                    <phrase>A <type> ciklomatikus</type> ábra</phrase>
                </textobject>
            </mediaobject>
        </figure> 
		<para>A komplexitás 17-2+3=18</para>
		<para>a komplexitási érték 4 típusra bontja fel a forráskódokat.
		Ha a komplexitás végeredményeként <command>1-10 közötti szám</command>ot kapunk, akkor a forráskód egyszerűnek mondható.
		</para><para><command>11 és 20 között</command> mérsékelten nehézkes a kód megértése.</para>
		<para><command>21 és 50 között</command> a programkód bonyolult</para><para>az utolsó osztály pedig a 
		<command>50 feletti</command> számok, mely a nagyon bonyolult forráskódoknál fordul elő, és magas a kockázat a hibák ejtésénél.
		</para>
		<para>Számolásunkat a <link xlink:href="www.lizard.ws">lizard.ws</link> oldal is approválja.</para>
	<figure>
            <title>A <type> lizard ciklomatikus</type> számolás</title>
            <mediaobject>
                <imageobject>
					<imagedata fileref="liskov/ciklo_lizard.png" scale="250" />
                </imageobject>
                <textobject>
                    <phrase>A <type> lizard ciklomatikus</type> számolás</phrase>
                </textobject>
            </mediaobject>
        </figure> 
	</section>

	<section>
<title>deprecated - Hello, Android!</title>
	<para>Élesszük fel a https://github.com/nbatfai/SamuEntropy/tree/master/cs projektjeit és vessünk össze
néhány egymásra következőt, hogy hogyan változtak a források!</para>
	</section>
	
	<section>
	<title>Hello, SMNIST for Humans!</title>
	<para>Fejleszd tovább az SMNIST for Humans projektet SMNIST for Anyone emberre szánt appá! Lásd
az smnist2_kutatasi_jegyzokonyv.pdf-ben a részletesebb hátteret!</para>
	</section>
</chapter>
