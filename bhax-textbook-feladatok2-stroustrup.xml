<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Stroustrup!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>JDK osztályok</title>
        <para>

            Írjunk olyan Boost C++ programot (indulj ki például a fénykardból) amely kilistázza a JDK összes
            osztályát (miután kicsomagoltuk az src.zip állományt, arra ráengedve)!
        </para>
        <para>
            A programkód forrása (
            <command>Nem saját source</command>
            ):
            <link xlink:href="https://github.com/ghjbku/prog2/tree/master/stroustrup">github link</link>
        </para>
        <figure>
            <title>
                A
                <type>jdk</type>
                futás
            </title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="stroustrup/jdk.png" scale="250" />
                </imageobject>
                <textobject>
                    <phrase>
                        A
                        <type>jdk</type>
                        futás
                    </phrase>
                </textobject>
            </mediaobject>
        </figure>
        <para>A program három függvényből áll, a GetCurrentWorkingDir,readClasses és searchRootFolders függvényekből.
        Nézzük először a <command>GetCurrentWorkingDir</command> funkciót:</para>
        <programlisting language="c++"><![CDATA[
string GetCurrentWorkingDir( void )
{
char buff[FILENAME_MAX];
GetCurrentDir( buff, FILENAME_MAX );
string current_working_dir(buff);
return current_working_dir;
}]]></programlisting>
<para>A függvényünk nem kér be paraméternek semmit, a GetCurrentDir beépített függvényt használja(getcwd)
,hogy az aktuális könyvtár nevét bekérje, majd létrehoz egy string típusú <command>current_working_dir</command>
 változót, melyben eltároljuk a buffer-ben található fájlnevet, melyet végül visszaad a függvény.</para>
   <para>Következő funkció egy visszatérési érték nélküli funkció/metódus lesz, a <command>readClasses:</command></para>
   <programlisting language="c++"><![CDATA[
void readClasses ( boost::filesystem::path path, vector<string>& classes)
{
if ( is_regular_file ( path ) ) {
std::string ext ( ".java" );
if ( !ext.compare ( boost::filesystem::extension ( path ) ) ){
classes.push_back(path.string());
}
} else if ( is_directory ( path ) )
for ( boost::filesystem::directory_entry & entry : boost::filesystem::directory_iterator ( path ) )

readClasses ( entry.path(),classes);
}]]></programlisting>
   <para>A függvény paraméterként egy path típusú path változót és egy string-vector objektumot vár.
   Ha az is_regular_file függvény igaz értéket ad vissza, akkor megadjuk a keresni kívánt fájl-kiterjesztést az ext objektumban,
   ami most a ".java"</para>
   <para>A Következő if elágazásban megnézzük, hogy az ext objektumunk értéke megegyezik-e a path-ban található kiterjesztéssel.
   Ha nem,akkor push_back, tehát a classes vektor végéhez adja a path-et.
   </para>
   <para>Else if ágba lépünk, ha az <command>is_regular_file</command> nem volt igaz, ekkor 
   az <command>is_directory</command> függvényt hívjuk meg ellenőrzésre.
   Ha a path egy könyvtár, akkor meghívunk egy for ciklust, melyben az entry.path() elérési utakat behelyezzük a classes vektorunkba.
   A ciklus addig megy, amíg van entry.</para>
   <para>Utolsó függvény pedig a <command>searchRootFolders</command>:</para>
   <programlisting language="c++"><![CDATA[
   vector<string> searchRootFolders (vector<string> folders)
{
vector <string> classes;
for ( const auto & path : folders)
{
boost::filesystem::path root ( path );
readClasses ( root, classes);
}
return classes;
}]]></programlisting>
<para>Láthatjuk, hogy ez a függvény már használja a readClasses függvényt,amit az előbb néztünk át,
itt a path a root objektum lesz, a class pedig marad a régi.
visszatérési érték a classes objektum lesz.</para>
<para>Végül jöhet a main függvény:</para>
<programlisting language="c++"><![CDATA[
int main(int argc, char const *argv[])
{
vector<string> roots = {
GetCurrentWorkingDir()+"/"+"src"
};

vector<string> classes = searchRootFolders ( roots );
cout<<endl<<"-----------------Printing java classes------------------------"<<endl;
for(auto &i : classes)
{
cout << i << endl;
}
cout << "összesen " << classes.size() << " osztály található\n";
return 0;
}]]></programlisting><para>A classes vektorunk értékéül a searchRootFolders függvény visszatérési értékét adjuk, ami ugyancsak a classes objektum volt.
Ezután egy for ciklusban kiíratjuk a classes-ben található elérési utakat, végül a classes.size()-al megnézzük, hogy mennyi osztályt talált a program.</para>
    </section>

    <section>
        <title>Másoló-mozgató szemantika</title>
        <para>

            Kódcsipeteken (copy és move ctor és assign) keresztül vesd össze a C++11 másoló és a mozgató
            szemantikáját, a mozgató konstruktort alapozd a mozgató értékadásra!

        </para>
        <programlisting language="c++"><![CDATA[LZWBinFa (LZWBinFa&& regi){
            std::cout<< "LZWBinFa movetor" << std::endl;
            
            *this = std:move(regi);]]></programlisting>
            <para>Itt látható az std::move funkció,
             amely egy jobbérték referenciát ad vissza, ezzel "mozgatva" az objektumot.
            </para>
<programlisting language="c++"><![CDATA[LZWBinFa (const LZWBinFa& regi)
{
std::cout << "LZWBinFa copytor" << std::endl;

gyoker.ujEgyesGyerek (masol (regi.gyoker.egyesGyerek (), regi.fa));
gyoker.ujNullasGyerek (masol (regi.gyoker.nullasGyerek (), regi.fa));

if (regi.fa == & (regi.gyoker)){fa = &gyoker;}
}

}]]></programlisting><para>Ez a másoló konstruktor,mely lemásolja a regi.fa-ban található nullás és egyes gyermekek-et,
és az új fa-ba másolja azokat.</para>
    
    <programlisting language="c++"><![CDATA[LZWBinFa (const LZWBinFa& regi)
{
std::cout << "LZWBinFa masolo ertekadas" << std::endl;

szabadit (gyoker.egyesGyerek());
szabadit (gyoker.nullasGyerek());

gyoker.ujEgyesGyerek (masol (regi.gyoker.egyesGyerek (), regi.fa));
gyoker.ujNullasGyerek (masol (regi.gyoker.nullasGyerek (), regi.fa));

if (regi.fa == & (regi.gyoker)){fa = &gyoker;}
}

}]]></programlisting><para>EZ pedig a másoló értékadás, amely nagyban hasonlít a konstruktoros megoldásra,
csak annyi a különbség,hogy a másolás előtt felszabadítja az egyes- és nullásgyermek-et, Null-ra állítja értéküket.
</para>

<programlisting language="c++"><![CDATA[LZWBinFa (LZWBinFa&& regi)
{
            std::cout<< "LZWBinFa movetor" << std::endl;
            
            gyoker.ujEgyesGyerek (regi.gyoker.egyesGyerek());
            gyoker.ujNullasGyerek (regi.gyoker.nullasGyerek());
            
            regi.gyoker.ujEgyesGyerek(nullptr);
            regi.gyoker.ujNullasGyerek(nullptr);
}]]></programlisting><para>Különbség az eredeti "movetor"-hoz képest, hogy itt nem egy jobbérték referenciát ad vissza egy move függvény,
helyette az új fa gyokerének az új Egyes és Nullás gyermekei-t a régi gyökér nullás és egyes gyermekeire állítjuk be, majd a regi fa gyökerének gyermekeit beállítjuk, hogy nullpointerre mutassanak.
</para>


</section>


    <section>    <title>Hibásan implementált RSA törése</title>
    <para>

        Készítsünk betű gyakoriság alapú törést egy hibásan implementált RSA kódoló:
        https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_3.pdf (71-73 fólia) által
        készített titkos szövegen.
    </para>
</section>

    <section>
        <title>Változó argumentumszámú ctor</title>
        <para>

            Készítsünk olyan példát, amely egy képet tesz az alábbi projekt Perceptron osztályának bemenetére
            és a Perceptron ne egy értéket, hanem egy ugyanakkora méretű „képet” adjon vissza. (Lásd még a 4
            hét/Perceptron osztály feladatot is.)
        </para>
    </section>
    <section>
        <title>Összefoglaló</title>
        <para>

            Az előző 4 feladat egyikéről írj egy 1 oldalas bemutató „”esszé szöveget!
        </para>
    </section>
    <section>
        <title>+feladat</title>
        <para>
            egy egyszerű string osztály elkészítését
            (hogy ne a verembe tegyük a kockászárójel megvalósítását,
            mert az nyilván odacsap az osztály értelmezésének)
        </para>
    </section>
</chapter>
