<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Arroway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>OO szemlélet</title>
        <para>A módosított polártranszformációs normális generátor beprogramozása Java nyelven.
Mutassunk rá, hogy a mi természetes saját megoldásunk és az OpenJDK, Oracle JDK-ban a Sun által adott OO szervezés ua.!
<link xlink:href="https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog1_5.pdf">Prog1_5.pdf</link>               
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/ghjbku/prog2/tree/master/OO_szemlelet">github link</link> </para>
        <para>
            </para>
            <figure>
            <title>A <type> JDK</type> kód</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="OO_szemlelet/gauss.png" scale="200" />
                </imageobject>
                <textobject>
                    <phrase>A <type> JDK</type> kód</phrase>
                </textobject>
            </mediaobject>
        </figure> 
        <para>Amint láthatjuk, a változók elnevezésén kívül és <command>StrictMath,nextDouble</command> metódusokon kívül az általunk írt kód megegyezik.
        Mi ugyanis StrictMath helyett a Math metódust használtuk a gyökvonás és logaritmus képzésnél.</para>
        <programlisting language="java"><![CDATA[double r=Math.sqrt((-2*Math.log(c))/c);]]></programlisting>   
    <para>A fő eltérés a két metódus között(azon kívül, hogy a StrictMath-ban hiperbolikus és egyéb függvények is elérhetőek) az, hogy a <command>StrictMath</command>-nál ha meghívunk egy függvényt, annak ugyan azt az értéket kell visszaadnia például x86-os lebegőpontos változónál, mint SPARC lebegőpontos-nál.
    Ezzel szemben a Math megengedi, hogy a pontosságért cserébe gyorsabban leforduljon a programunk.(na persze a pontossági eltérés nem számottevő a jelen programunk megírásánál)</para>
    <programlisting language="java"><![CDATA[public class polargenerator
{]]></programlisting><para>Amint láthatjuk, az egész programkód egy osztályba van elhelyezve, ez a Java-nak egy sajátossága.</para>
   <programlisting language="java"><![CDATA[ boolean nincstar=true;
 double tarolt;]]></programlisting><para>A forráskód elején inicializálunk két változót, a <command>nincstar</command> változó egy logikai változó, amely megmondja, hogy van-e eltárolva adat.
 Ezzel szemben a <command>tarolt</command> változó hordozza majd a tárolni kívánt értéket.</para>
<programlisting language="java"><![CDATA[ public double kovetkezo()
	{
	if(nincstar)
		{
		double a1,a2,b1,b2,c; ]]></programlisting><para>Itt pedig egy kovetkezo nevű metódust hozunk létre, ha a nincstar értéke igaz, akkor végrehajtódik az if-ben leírt változók deklarálása.
        </para>
        <programlisting language="java"><![CDATA[ ]]></programlisting>
    </section>        

<section>
        <title>"Gagyi"</title>
        <para>
Az ismert formális <command><![CDATA[while(x <=t && x>=t && t!=x);]]></command> tesztkérdéstípusra adj a szokásosnál "mélyebb" választ, írj Java példaprogramot mely egyszer végtelen ciklus, más x és t értékekkel pedig nem!
A példát építsd a JDK Integer.java forrására, hogy a 128-nál inkluzív objektum példányokat poolozza! 
<link xlink:href="https://www.facebook.com/groups/udprog/permalink/437825193072042/">facebook post</link>
	</para>
        <para>
            Megoldás forrása:               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>   

    <section>
        <title>Yoda</title>
        <para>
Írjunk olyan Java programot, ami java.lang.NullPointerEx-el leáll, ha nem követjük a Yoda conditions-t!           
<link xlink:href="https://en.wikipedia.org/wiki/Yoda_conditions">yoda wiki</link>
	</para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/ghjbku/prog2/tree/master/yoda">github link</link>              
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
    
<section>
        <title>Kódolás from scratch</title>
        <para>
Induljunk ki ebből a tudományos közleményből:<link xlink:href="http://crd-legacy.lbl.gov/~dhbailey/dhbpapers/bbp-alg.pdf">http://crd-legacy.lbl.gov/~dhbailey/dhbpapers/bbp-alg.pdf</link>
és csak ezt tanulmányozva írjuk meg Java nyelven a BBP algoritmus megvalósítását!
Ha megakadsz, de csak végső esetben:<link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apbs02.html#pi_jegyei">https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apbs02.html#pi_jegyei</link>

	</para>
        <para>
            Megoldás forrása:               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>       
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
