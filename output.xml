<?xml version="1.0" encoding="UTF-8"?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">    
    
    <info xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">

    <title xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">Univerzális programozás</title>               

    <subtitle xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">Írd meg a saját programozás tankönyvedet!</subtitle>               

    <titleabbrev xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">BHAX KÖNYV</titleabbrev>               

    <authorgroup xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <author>
        <personname>
            <surname>Tóth</surname>
            <firstname>Balázs</firstname>        
        </personname>    
        <affiliation>
            <shortaffil>Hallgató</shortaffil>
            <jobtitle>Hallgató</jobtitle>
            <orgname>Debreceni Egyetem</orgname>
            <orgdiv>PTI</orgdiv>
            <address>
                <email>windsake@mailbox.unideb.hu</email>
                <email>gawnoris@gmail.com</email>
            </address>
        </affiliation>
        <address>
            <street>-</street>
            <city>Debrecen</city>
            <postcode>4028</postcode>
            <country>Magyarország</country>
                <email>windsake@mailbox.unideb.hu</email>
            <otheraddr>
                <link xlink:href="https://web.unideb.hu/~windsake">http://web.unideb.hu/~windsake</link>
            </otheraddr>
        </address>
    </author>    
</authorgroup>               

    <edition xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">BHAX, DEBRECEN, 2019. február 19, v. 0.0.4</edition>               

    <pubdate>2019</pubdate>
    <copyright>
        <year>2019</year>
        <holder>Dr. Bátfai Norbert</holder>
    </copyright>
    <legalnotice>           
        <para>                
            Copyright (C) 2019, Norbert Bátfai Ph.D., batfai.norbert@inf.unideb.hu, nbatfai@gmail.com, 
        </para>
        <para>
            Permission is granted to copy, distribute and/or modify this document
            under the terms of the GNU Free Documentation License, Version 1.3
            or any later version published by the Free Software Foundation;
            with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
            A copy of the license is included in the section entitled "GNU
            Free Documentation License".                
        </para>
        <para>
            <link xlink:href="https://www.gnu.org/licenses/fdl.html">https://www.gnu.org/licenses/fdl.html</link>                
        </para>
            
        <para>
            Engedélyt adunk Önnek a jelen dokumentum sokszorosítására, terjesztésére és/vagy módosítására 
            a Free Software Foundation által kiadott GNU FDL 1.3-as, vagy bármely azt követő verziójának 
            feltételei alapján. Nincs Nem Változtatható szakasz, nincs Címlapszöveg, nincs Hátlapszöveg.                
        </para>
        <para>
            <link xlink:href="http://gnu.hu/fdl.html">http://gnu.hu/fdl.html</link>                
        </para>
    </legalnotice>   
    
    <revhistory xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <revision>
        <revnumber>0.0.1</revnumber>
        <date>2019-02-12</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            Az iniciális dokumentum szerkezetének kialakítása.
        </revremark>
    </revision>
    <revision>
        <revnumber>0.0.2</revnumber>
        <date>2019-02-14</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            Inciális feladatlisták összeállítása.
        </revremark>
    </revision>    
    <revision>
        <revnumber>0.0.3</revnumber>
        <date>2019-02-16</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            Feladatlisták folytatása.
            Feltöltés a BHAX csatorna 
            <link xlink:href="https://gitlab.com/nbatfai/bhax">https://gitlab.com/nbatfai/bhax</link>
            repójába.
        </revremark>
    </revision>
    <revision>
        <revnumber>0.0.4</revnumber>
        <date>2019-02-19</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            Aktualizálás, javítások.
        </revremark>
    </revision>
    <revision>
        <revnumber>0.1.0</revnumber>
        <date>2019-02-26</date>
        <authorinitials>Balázs Tóth</authorinitials>
        <revremark>
            Feladatok elkezdése, chapter 1
        </revremark>
    </revision>
    <revision>
        <revnumber>0.1.1</revnumber>
        <date>2019-03-03</date>
        <authorinitials>Balázs Tóth</authorinitials>
        <revremark>
            Feladatok elkezdése, chapter 2
        </revremark>
    </revision>
    <revision>
        <revnumber>0.1.2</revnumber>
        <date>2019-03-11</date>
        <authorinitials>Balázs Tóth</authorinitials>
        <revremark>
            Feladatok elkezdése, chapter 3
        </revremark>
    </revision>
    <revision>
        <revnumber>0.1.3</revnumber>
        <date>2019-03-18</date>
        <authorinitials>Balázs Tóth</authorinitials>
        <revremark>
            Feladatok elkezdése, chapter 4
        </revremark>
    </revision>
    <revision>
        <revnumber>0.1.4</revnumber>
        <date>2019-03-27</date>
        <authorinitials>Balázs Tóth</authorinitials>
        <revremark>
            Feladatok elkezdése, chapter 5
        </revremark>
    </revision>
    <revision>
        <revnumber>0.1.5</revnumber>
        <date>2019-04-05</date>
        <authorinitials>Balázs Tóth</authorinitials>
        <revremark>
            Feladatok elkezdése, chapter 6
        </revremark>
    </revision>
    <revision>
        <revnumber>0.1.6</revnumber>
        <date>2019-04-12</date>
        <authorinitials>Balázs Tóth</authorinitials>
        <revremark>
            Feladatok elkezdése, chapter 7
        </revremark>
    </revision>
    <revision>
        <revnumber>0.1.7</revnumber>
        <date>2019-04-19</date>
        <authorinitials>Balázs Tóth</authorinitials>
        <revremark>
            Feladatok elkezdése, chapter 8 és olvasónapló
        </revremark>
    </revision>
    <revision>
        <revnumber>0.1.8</revnumber>
        <date>2019-04-26</date>
        <authorinitials>Balázs Tóth</authorinitials>
        <revremark>
            Feladatok elkezdése, chapter 9
        </revremark>
    </revision>
    <revision>
        <revnumber>0.1.9</revnumber>
        <date>2019-04-30</date>
        <authorinitials>Balázs Tóth</authorinitials>
        <revremark>
            Feladatok elkezdése, chapter 10
        </revremark>
    </revision>
    <revision>
        <revnumber>0.2.0</revnumber>
        <date>2019-05-05</date>
        <authorinitials>Balázs Tóth</authorinitials>
        <revremark>
            Feladatok finomítása, bejezezés
        </revremark>
    </revision>
    <revision>
        <revnumber>1.0.1</revnumber>
        <date>2019-09-09</date>
        <authorinitials>Balázs Tóth</authorinitials>
        <revremark>
            Második felvonás elkezdése
        </revremark>
    </revision>
    <revision>
        <revnumber>1.0.2</revnumber>
        <date>2019-09-11</date>
        <authorinitials>Balázs Tóth</authorinitials>
        <revremark>
            Hello Berners beillesztése, arroway inicializálása
        </revremark>
    </revision>
    <revision>
        <revnumber>1.0.3</revnumber>
        <date>2019-09-14</date>
        <authorinitials>Balázs Tóth</authorinitials>

        <revremark>
            Java és C++ könyvek összehasonlításának elkezdése/első oldal megírása</revremark>
    </revision>
	 <revision>
        <revnumber>1.0.4</revnumber>
        <date>2019-09-16</date>
        <authorinitials>Balázs Tóth</authorinitials>

        <revremark>
            összehasonlítás folytatása, python napló elkezdése</revremark>
    </revision>
</revhistory>               
                               
</info>     
        
    <dedication xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <para>

    </para>
<blockquote>
    <attribution>Gregory Chaitin, <citetitle>META MATH! The Quest for Omega</citetitle>, <citation>METAMATH</citation></attribution>
    <para>
        „To me, you understand something only if you can program it.  
        (You, not someone else!)  Otherwise you don’t really understand it, 
        you only think you understand it.”
    </para>
</blockquote>
</dedication>     
    
    <preface xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Előszó</title>
    <para xml:id="bhax-textbook-pre.Eloszo">
        Amikor programozónak terveztem állni, ellenezték a környezetemben, mondván, hogy kell  
        szövegszerkesztő meg táblázatkezelő, de az már van... nem lesz programozói munka.
    </para>                 
    <para>
        Tévedtek. Hogy egy generáció múlva kell-e még tömegesen hús-vér programozó vagy
        olcsóbb lesz allokálni igény szerint pár robot programozót a felhőből?
        A programozók dolgozók lesznek vagy papok?
        Ki tudhatná ma. 
    </para>
    <para>
        Mindenesetre a programozás a teoretikus kultúra csúcsa. A GNU mozgalomban látom annak 
        garanciáját, hogy ebben a szellemi kalandban a gyerekeim is részt vehessenek majd. Ezért programozunk.
    </para>          
    <section>
        <title>Hogyan forgasd</title>
        <para>
            A könyv célja egy stabil programozási szemlélet kialakítása az olvasóban. Módszere, hogy hetekre 
            bontva ad egy tematikus feladatcsokrot. Minden feladathoz megadja a megoldás forráskódját és forrásokat
            feldolgozó videókat.
            Az olvasó feladata, hogy ezek tanulmányozása után maga adja meg a feladat megoldásának lényegi
            magyarázatát, avagy írja meg a könyvet.
        </para>
        <para>
            Miért univerzális? Mert az olvasótól (kvázi az írótól) függ, hogy kinek szól a könyv. 
            Alapértelmezésben gyerekeknek, mert velük készítem az iniciális változatot. 
            Ám tervezem felhasználását az egyetemi programozás oktatásban is. Ahogy szélesedni tudna a 
            felhasználók köre, akkor lehetne kiadása különböző korosztályú gyerekeknek, családoknak, 
            szakköröknek, programozás kurzusoknak, felnőtt és továbbképzési műhelyeknek és sorolhatnánk... 
        </para>
        <section>
            <title>Milyen nyelven nyomjuk?</title>
            <para>
                C (mutatók), C++ (másoló és mozgató szemantika) és Java (lebutított C++) nyelvekből kell egy jó alap, 
                ezt kell kiegészíteni pár R (vektoros szemlélet), Python (gépi tanulás bevezető), Lisp és Prolog (hogy lássuk
                mást is) példával.
            </para>
        </section>
        <section>
            <title>Hogyan nyomjuk?</title>
            <para>
                Rántsd le a <link xlink:href="https://gitlab.com/nbatfai/bhax">https://gitlab.com/nbatfai/bhax</link>
                git repót, vagy méginkább forkolj belőle magadnak egy sajátot a GitLabon, ha már saját könyvön dolgozol!
            
                <screen><![CDATA[]]></screen> 
            
            </para>
            <para>
                Ha megvannak a könyv DocBook XML forrásai, 
                akkor az alább látható <command>make</command> parancs ellenőrzi, hogy „jól formázottak” és 
                „érvényesek-e” ezek az XML források, majd 
                elkészíti a <application>dblatex</application> programmal a könyved pdf változatát, íme:
                <screen><![CDATA[batfai@entropy:~$ cd glrepos/bhax/thematic_tutorials/bhax_textbook/
batfai@entropy:~/glrepos/bhax/thematic_tutorials/bhax_textbook$ make
rm -f bhax-textbook-fdl.pdf
xmllint --xinclude bhax-textbook-fdl.xml --output output.xml
xmllint --relaxng http://docbook.org/xml/5.0/rng/docbookxi.rng output.xml --noout
output.xml validates
rm -f output.xml	
dblatex bhax-textbook-fdl.xml -p bhax-textbook.xls
Build the book set list...
Build the listings...
XSLT stylesheets DocBook - LaTeX 2e (0.3.10)
===================================================
Stripping NS from DocBook 5/NG document.
Processing stripped document.
Image 'dblatex' not found
Build bhax-textbook-fdl.pdf
'bhax-textbook-fdl.pdf' successfully built]]></screen>             

            Ha minden igaz, akkor most éppen ezt a legenerált <filename>bhax-textbook-fdl.pdf</filename> fájlt olvasod.
            </para>
<tip>
              <title>A DocBook XML 5.1 új neked?</title>
              <para>
                  Ez esetben forgasd a <link xlink:href="https://tdg.docbook.org/tdg/5.1/">https://tdg.docbook.org/tdg/5.1/</link>
                  könyvet, a végén találod az informatikai szövegek jelölésére használható gazdag „API” elemenkénti
                  bemutatását.                  
              </para>            
            </tip>            
        </section>
        
    </section>            

</preface> 

    <!-- 
        <xi:include href="bhax-textbook-glossary.xml">
            <xi:fallback>
                <para>
                    <emphasis>XInclude: bhax-textbook-glossary.xml file not found</emphasis>
                </para>
            </xi:fallback>
        </xi:include> 
    -->

    <part xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Bevezetés</title>
    <partintro>
        <para> 
        </para>
    </partintro>
    <chapter>
        <info>
            <title>Vízió</title>
            <keywordset>
                <keyword/>
            </keywordset>
        </info>
        <section>
            <title>Mi a programozás?</title>
            <para>                  
                          
            </para>
        </section>
        <section>
            <title>Milyen doksikat olvassak el?</title>
            <itemizedlist>
                <listitem>
                    <para>Olvasgasd a kézikönyv lapjait, kezd a <command>man man</command> parancs kiadásával. A C programozásban
                    a 3-as szintű lapokat fogod nézegetni, például az első feladat kapcsán ezt a 
                    <command>man 3 sleep</command> lapot</para>                        
                </listitem>
                <listitem>
                    <para><citation>KERNIGHANRITCHIE</citation></para>                        
                </listitem>
                <listitem>
                    <para><citation>BMECPP</citation></para>                        
                </listitem>
                <listitem>
                    <para>Az igazi kockák persze csemegéznek a C nyelvi szabvány 
                        <link xlink:href="https://web.archive.org/web/20181230041359if_/http://www.open-std.org/jtc1/sc22/wg14/www/abq/c17_updated_proposed_fdis.pdf">ISO/IEC 9899:2017</link> kódcsipeteiből is.
                    </para>                        
                </listitem>
            </itemizedlist>            
        </section>
        <section>
            <title>Milyen filmeket nézzek meg?</title>
            <itemizedlist>
                <listitem>
                    <para>21 - Las Vegas ostroma, 
                        <link xlink:href="https://www.imdb.com/title/tt0478087/">https://www.imdb.com/title/tt0478087/</link>,
                        benne a <link xlink:href="#bhax-textbook-feladatok-turing.MontyHall">Monty Hall probléma</link> bemutatása.
                    </para>                        
                </listitem>
            </itemizedlist> 
        </section>
    </chapter>                
</part> 

    <part xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Tematikus feladatok</title>
    <partintro>
        <para> 
        </para>
<tip>
              <title>Bátf41 Haxor Stream</title>
              <para>
                  A feladatokkal kapcsolatos élő adásokat sugároz
                  a <link xlink:href="https://www.twitch.tv/nbatfai">https://www.twitch.tv/nbatfai</link> csatorna,
                  melynek permanens archívuma a <link xlink:href="https://www.youtube.com/c/nbatfai">https://www.youtube.com/c/nbatfai</link> 
                  csatornán található.
              </para>            
            </tip>    
        
    </partintro>
    
    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Turing!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Végtelen ciklus</title>
        <para>
            Írj olyan C végtelen ciklusokat, amelyek 0 illetve 100 százalékban dolgoztatnak egy magot és egy olyat, amely  
            100 százalékban minden magot!
        </para>
        <para>
            Megoldás videó: <link xlink:href=" https://github.com/ghjbku/DE/blob/master/video.flv"> https://github.com/ghjbku/DE/blob/master/video.flv</link>
        </para>
        <para>
          Megoldás forrása:
			</para>
			<para>
Elsőként a 100%-os végtelen ciklust készítettem el, hiszen ezt volt a legegyszerűbb megírni.
Amint láthatjuk elég egyszerűen meg lehet oldani, hogy a cpu 100%-ban dolgozzon a program futása alatt. 
Itt én a WHILE ciklus-t választottam, de FOR-ral is hasonlóképpen lehet megvalósítani a végtelenítést.
Az egész program lényege egyetlen értéken alapszik, amit az *asd* változó hordoz.
Mivel ez a változó semmiképp sem kap 1-et értékül, a program soha sem fog kilépni a ciklusból.
<programlisting language="c"><![CDATA[
//100%-ban megdolgoztat egy magot
//lefordítás: gcc forrásnév -o késznév
#include <stdio.h>
int main()
{
int asd =0;
while (asd=1){}
return 0;
}]]>
</programlisting>A következő program a 0%-os végtelen ciklus volt. Ha ismerjük az API-t, vagy tapraesettek vagyunk a google-n való keresést illetően, akkor itt is egyszerű dolgunk volt.
Amint azt észrevehettük, a programkód nagyon hasonlít az előző kódra, csupán annyi változás történt, hogy a ciklus belsejében megjelent egy függvény, a *sleep()*.
Ez a függvény annyi milisecond-ig állítja meg a programot, amely számot a két zárójel közé írtunk. Jelen esetben ez *1*, de mivel egy végtelen ciklusban vagyunk, ezért végtelen sokszor vár majd 1 milisec-ot a program, így tehát nem használ erőforrást.<programlisting language="c">
<![CDATA[
//0%-os cpu használat
//lefordítás: gcc forrásnév -o késznév
#include <stdio.h>
int main()
{
int asd =0;
while (asd=1)
{
sleep(1);
}
return 0;
}     
]]> 
</programlisting>Utolsóként pedig jön a "legnehezebb", minden magot 100%-on futtatni.
Az igazat megvallva, ez sem valami nagy ördöngősség, itt is csak egy pár dolog változott a legelső programhoz képest.
A legfontosabb dolog ez a sor *#include "omp.h"*, ez a header fájl előfeltétele annak, hogy a *#pragma omp parallel* kódot értelmezni tudja a fordítóprogram.
A *#pragma...* sor veszi rá a programunkat, hogy párhuzamos módon, az összes magon futtassa a programot a számítógép.<programlisting language="c">
<![CDATA[//minden mag 100%-on fut
//lefordítás: gcc -fopenmp forrásnév -o késznév
#include <stdio.h>
#include <unistd.h>
#include "omp.h"
int main () {
int asd=0;

#pragma omp parallel
	while(asd=1)
	{
	}
   return 0;
}  
]]> 
</programlisting>
         
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...			
			</para><para>
			Amint láthattuk, elég egyszerű dolgunk volt ezen programok megírását illetően, viszont ez nem azt jelenti, hogy félválról vehetjük a programozást,
			hiszen kevés olyan program létezik, aminek valamilyen hétköznapi haszna van, és mégis ilyen egyszerű lenne megírni.
			Ezen programkódok csak az egyszerűbb megértést segítik elő, gyakorlati hasznuk sajnos nincs.
        </para>            
    </section>        
        
    <section>
        <title>Lefagyott, nem fagyott, akkor most mi van?</title>
        <para>
            Mutasd meg, hogy nem lehet olyan programot írni, amely bármely más programról eldönti, hogy le fog-e fagyni vagy sem!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása:  tegyük fel, hogy akkora haxorok vagyunk, hogy meg tudjuk írni a <function>Lefagy</function>
            függvényt, amely tetszőleges programról el tudja dönteni, hogy van-e benne vlgtelen ciklus:              
        </para>
        <programlisting language="c"><![CDATA[Program T100
{

	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}

	main(Input Q)
	{
		Lefagy(Q)
	}
}]]></programlisting>            
        <para>
            A program futtatása, például akár az előző <filename>v.c</filename> ilyen pszeudókódjára:
            <screen><![CDATA[T100(t.c.pseudo)
true]]></screen>            
            akár önmagára
            <screen><![CDATA[T100(T100)
false]]></screen>  
            ezt a kimenetet adja.          
        </para>
        <para>
            A T100-as programot felhasználva készítsük most el az alábbi T1000-set, amelyben a
            Lefagy-ra épőlő Lefagy2 már nem tartalmaz feltételezett, csak csak konkrét kódot:
        </para>
        <programlisting language="c"><![CDATA[Program T1000
{

	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}

	boolean Lefagy2(Program P)
	{
		 if(Lefagy(P))
			return true;
		 else
			for(;;); 
	}

	main(Input Q)
	{
		Lefagy2(Q)
	}

}]]></programlisting>            
        <programlisting><![CDATA[]]></programlisting>            
        <para>
            Mit for kiírni erre a <computeroutput>T1000(T1000)</computeroutput> futtatásra?
                                
            <itemizedlist>
                <listitem>
                    <para>Ha T1000 lefagyó, akkor nem fog lefagyni, kiírja, hogy true</para>                        
                </listitem>
                <listitem>
                    <para>Ha T1000 nem fagyó, akkor pedig le fog fagyni...</para>                        
                </listitem>
            </itemizedlist>
            akkor most hogy fog működni? Sehogy, mert ilyen <function>Lefagy</function>
            függvényt, azaz a T100 program nem is létezik.                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>
        Amint láthatjuk, lehetetlen olyan programot írni, amely egy másik programról eldöntené, hogy az le fog-e fagyni, vagy sem.
        </para>
    </section>        
                
    <section>
        <title>Változók értékének felcserélése</title>
        <para>
            Írj olyan C programot, amely felcseréli két változó értékét, bármiféle logikai utasítás vagy kifejezés
            nasználata nélkül!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk">https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk</link>
        </para>
        <para>
            Megoldás forrása:</para><para> 
		Ezen feladat megoldása igencsak egyszerűnek bizonyult.Na persze nem annyira egyszerű, mint egy végtelen ciklus megírása, de közel azonos szinten mozognak.
		A lentebb lévő forráskód elég egyszerűen értelmezhető, ezért hát nem megyek bele részletesen, csak a nagyon fontos dolgokat mondom el.
		A *C* nyelvben a változók értékét egy paranccsal tudjuk hozzáfűzni egy printf függvényhez, attól függően, hogy milyen típusú adatot hordoz a változó.
		Esetünkben mindkét változó *szám/Digit* típust hordoz, ezért a kód, amivel meghívjuk a behelyettesítő paramétert, ez lesz: * %d *, majd ha végeztünk a kiírni kívánt szöveggel, egy vesszővel jelezzük a fordítóprogramnak, hogy most a behelyettesítendő változók következnek.
		A kódban megjelenik egy másik kód is, ami ismeretlen lehet az olvasó számára, ez a * \n * , amely annyit tesz, hogy új sorba kezdi az *n* után beírt szöveget, és a szóközt is értelmezi!
			<programlisting language="c"><![CDATA[#include <stdio.h>
int main()
{
int a=5,b=3;
printf("A value = %d\n",a);
printf("B value = %d\n",b);
b=b-a;
a=a+b;
b=a-b;
printf("A value = %d\n",a);
printf("B value = %d\n",b);
return 0;
}]]></programlisting>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
		<para>Ne tévesszen meg bennünket a feladat komplexitása, ha nem gondolunk bele, hogy pontosan hogyan is kellene segédváltozó nélkül elérni céljainkat, elég sokáig el tudunk időzni ezen az egyszerű feladaton.
		Tehát próbáljunk meg minden feladatot úgy kezdeni, hogy elgondolkozunk azon, hogyan tudnánk megvalósítani a feladatban megírtakat.</para>
    </section>                     

    <section>
        <title>Labdapattogás</title>
        <para>
        <command>Tutoráltam:Nagy Krisztinánt</command>
            Először if-ekkel, majd bármiféle logikai utasítás vagy kifejezés
            nasználata nélkül írj egy olyan programot, ami egy labdát pattogtat a karakteres konzolon! (Hogy mit értek
            pattogtatás alatt, alább láthatod a videókon.)
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/08/28/labdapattogas">https://bhaxor.blog.hu/2018/08/28/labdapattogas</link>
        </para>
        <para>
            Megoldás forrása:  </para>
			<para>A feladat nehézségi szintjét tekintve már egy magassabb szinten van, vagyis inkább, gondolkodást igényel.
			Ebben a forráskódban már megjelenik egy pár új parancs, melyeket eddig még nem láttunk.
			Kezdve az új Header fájllal, a <![CDATA[<math.h>]]> fájllal, amely a matematikai függvényekért felel és minden értéket double típussal kezel(double típust kér, és azt ad vissza), ilyen függvény például az *abs*, amely az abszolút értéket jelöli,
			de ebben a header fájlban található a *pow* és az *sqrt* is, az előbbi a hatványozást, míg utóbbi a négyzetgyököt kezeli.
			Aztán ott van az a furcsa sor két sorral alább, az a bizonyos *#define*... ezeket a sorokat úgynevezett "Nevesített konstansok" definiálásánál használjuk.
			Ezek a konstansok értéket nem változtatnak a program futása során, és bármilyen értéket adhatunk nekik.
			<programlisting language="c"><![CDATA[
//Labdapattogás if nélkül (mentorálva Gila Attila által)
#include<stdio.h>
#include<math.h>

#define szel 80  
#define mag 24

int putX(x,y)
{
int ix,iy;

for(ix=0;ix<x;ix++)
printf("\n");

for(iy=0;iy<y;iy++)
printf(" ");

printf("O\n");

return 0;
}

int main()
{
long int x=0,y=0;

while(1)
{
system("clear");
putX(abs(mag-(x++%(mag*2))),abs(szel-(y++%(szel*2))));
usleep(15000);
}

return 0;
} 
]]></programlisting>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para><para>A labda "pattogása" egyszerű módon van megoldva, miszerint minden egyes "tick" után, amit a program a végtelen ciklusban tölt, a *system("clear")* parancs miatt a terminál jelenlegi tartalma törlődik, de mivel az túl gyorsan történik, mi csak úgy érezzük, hogy a labda szépen mozog az ablakban.
		a "tick" periódust az *usleep()* függvény zárójelében megadott szám határozza meg, a mértékegység microsecond.
		Viszont ha fontos a pontosság, akkor számolnunk kell a számítógép kalkulációs képességeivel, plusz az is időbe telik, hogy a program eljut az *usleep* függvényhez, ezután az egész program "alvó" állapotba kerül, kilép a processor ütemezési sorából, és a delay attól is függhet, hogy a processor maga mikor válassza újra a programot, miután a *usleep* függvény lefutott.
		Tehát ne lepődjünk meg, ha néhány ezer microsec-ot téved a program.</para>
    </section>                     

    <section>
        <title>Szóhossz és a Linus Torvalds féle BogoMIPS</title>
        <para>
            Írj egy programot, ami megnézi, hogy hány bites a szó a gépeden, azaz mekkora az <type>int</type> mérete.
            Használd ugyanazt a while ciklus fejet, amit Linus Torvalds a BogoMIPS rutinjában! 
        </para>
        <para>
            Megoldás videó: <link xlink:href=""/>
        </para>
        <para>
        <command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása: <link xlink:href="https://github.com/ghjbku/DE/blob/cpp/bitshift.cpp"/>
        </para>
		<para>A feladat megoldása C++ nyelven történt, viszont C-ben is hasonló módon kell megoldani a problémát.
		<programlisting language="c"><![CDATA[//a bitshift C nyelvben
#include <stdio.h>

int main(){

	unsigned int the_Bit = 1;
	int length = 0;

	do
		length++;
	while((the_Bit <<= 1));

	printf("A szóhossz mérete: %u\n", length);

	return 0;
}]]></programlisting>
A C megoldás BogoMIPS-el: <link xlink:href="https://github.com/ghjbku/DE/blob/master/c%20cuccok/szohossz.c">itt található</link>
		</para>
        <para>
            Tanulságok, tapasztalatok, magyarázat... 
        </para>
        <para>
        A bit méretét a <command>length</command> változó tárolja, amit úgy töltünk fel, hogy amíg a bit el nem éri a kezdési értéket, addig a ciklusban mingíg növeljük a változó értékét 1-el.
        Majd ezen értéket a végén kiírjuk.
        Az unsigned típus 2<superscript>n</superscript> különböző értéket vehet fel 0 és n között.
        </para>
    </section>                     

    <section>
        <title>Helló, Google!</title>
        <para>
            Írj olyan C programot, amely egy 4 honlapból álló hálózatra kiszámolja a négy lap Page-Rank 
            értékét!
        </para>
        <para>
            Megoldás videó: <link xlink:href=""/>
        </para>
        <para>
        <command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása C++-ban: <link xlink:href="https://github.com/ghjbku/DE/blob/cpp/bearazas.cpp"/>
            és C-ben: <link xlink:href="https://github.com/ghjbku/DE/blob/master/c%20cuccok/bearaz.c"/>
        </para>
        <para>
        <programlisting language="c"><![CDATA[
#include <stdio.h>
#include <math.h>

void
kiir (double tomb[], int db)
{
int i;
for (i=0; i<db; i++)
printf("PageRank [%d]: %lf\n", i, tomb[i]);
}

double tavolsag(double pagerank[],double pagerank_temp[],int db)
{
double tav = 0.0;
int i;
for(i=0;i<db;i++)
tav +=abs(pagerank[i] - pagerank_temp[i]);
return tav;
}

int main(void)
{
double L[4][4] = {
{0.0, 0.0, 1.0 / 3.0, 0.0},
{1.0, 1.0 / 2.0, 1.0 / 3.0, 1.0},
{0.0, 1.0 / 2.0, 0.0, 0.0},
{0.0, 0.0, 1.0 / 3.0, 0.0}
};

double PR[4] = {0.0, 0.0, 0.0, 0.0};
double PRv[4] = {1.0 / 4.0, 1.0 / 4.0, 1.0 / 4.0, 1.0 / 4.0};

long int i,j,h;
i=0; j=0; h=5;

for (;;)
{
for(i=0;i<4;i++)
PR[i] = PRv[i];
for (i=0;i<4;i++)
{
double temp=0;
for (j=0;j<4;j++)
temp+=L[i][j]*PR[j];
PRv[i]=temp;
}

if ( tavolsag(PR,PRv, 4) < 0.00001)
break;
}
kiir (PR,4);
return 0;

} 
]]></programlisting>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...

        </para>
        <para>A pagerank algoritmust a google fejlesztette ki azzal a céllal, hogy a weboldalak minőségét rangsorolja.</para>
   <para>A feladat komplexitása miatt a soronkénti értelemzést választottam.Kezdjük is el.</para>
   <programlisting language="c"><![CDATA[void
kiir (double tomb[], int db)
{
int i;
for (i=0; i<db; i++)
printf("PageRank [%d]: %lf\n", i, tomb[i]);
}]]>
   </programlisting>
    <para>Ez a függvény a minsősítés végeredményét fogja kiírni.
    Egy egyszerű for ciklusból áll, amely a függvényparaméterként megadott <command>db</command>-szor fog lefutni és kiírja az ugyancsak függvényparaméterből származó <command>tomb[]</command> tömb elemeit.</para>
    <programlisting language="c"><![CDATA[
double tavolsag(double pagerank[],double pagerank_temp[],int db)
{
double tav = 0.0;
int i;
for(i=0;i<db;i++)
tav +=abs(pagerank[i] - pagerank_temp[i]);
return tav;
}
]]></programlisting>
     <para>Ez a következő függvény már bonyolultabb.A függvényünk két double típusú tömböt és egy számot kér paraméterül.
     A távolság kiszámítására itt is egy for-ciklus lesz segítségünkre, azon belűl pedig egy abszolútérték függvény, amelyben a <command>pagerank</command> tömbből kivonjuk a <command>pagerank_temp</command> tömböt.</para>
     <programlisting language="c"><![CDATA[int main(void)
{
double L[4][4] = {
{0.0, 0.0, 1.0 / 3.0, 0.0},
{1.0, 1.0 / 2.0, 1.0 / 3.0, 1.0},
{0.0, 1.0 / 2.0, 0.0, 0.0},
{0.0, 0.0, 1.0 / 3.0, 0.0}
};

double PR[4] = {0.0, 0.0, 0.0, 0.0};
double PRv[4] = {1.0 / 4.0, 1.0 / 4.0, 1.0 / 4.0, 1.0 / 4.0};

long int i,j,h;
i=0; j=0; h=5;
]]></programlisting>
      <para>Amint láthatjuk, a main függvényen belül elkezdjük definiálni a változókat, melyeket az előbbi két függvényre majd ráeresztünk.
      </para>
      <programlisting language="c"><![CDATA[
for (;;)
{
 for(i=0;i<4;i++)
 PR[i] = PRv[i];
  for (i=0;i<4;i++)
  {
  double temp=0;
    for (j=0;j<4;j++)
    temp+=L[i][j]*PR[j];
    PRv[i]=temp;
  }

if ( tavolsag(PR,PRv, 4) < 0.00001)
break;
}
kiir (PR,4);
return 0;
]]></programlisting>
    <para>Továbbra is a main függvényben vagyunk. Már megtörtént a változó deklarálás, tehát elkezdődhet a rangsorolás.
    Belépünk egy for-ciklusba, majd azon belűl rétegezve létrehozunk még 3 másik for-ciklust.
    Az első réteg a <command>PR</command> tömböt azonosítja a <command>PRv</command> tömbbel.
    A második réteg egy <command>temp</command> változóban összeszorozza az <command>L[][]</command> kétdimenziós tömböt és az újonan kapott <command>PR</command> tömböt.
    Majd minden ciklus végén hozzáadja az új értékeket az előző értékhez.
    Ezután a <command>PRv</command> tömb értékéül adjuk a temp változót.
    ezután visszatérünk az első for-ciklusba, ahol pedig egy if elágazással megnézzük, hogy a <command>tavolsag()</command> függvény visszatérési értéke kissebb-e, mint 0.00001
    . Ha igen, akkor kilép a ciklusból.
    A program a végén kiírja a <command>PR</command> tömb tartalmát a <command>kiir()</command> függvény segítségével.</para>
    </section>

    <section xml:id="Brun">
        <title>100 éves a Brun tétel</title>
        <para>
            Írj R szimulációt a Brun tétel demonstrálására!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/xbYhp9G6VqQ">https://youtu.be/xbYhp9G6VqQ</link>
        </para>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R">https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R</link>
        </para>
        <programlisting language="r"><![CDATA[library(matlab)

stp <- function(x){

    primes = primes(x)
    diff = primes[2:length(primes)]-primes[1:length(primes)-1]
    idx = which(diff==2)
    t1primes = primes[idx]
    t2primes = primes[idx]+2
    rt1plust2 = 1/t1primes+1/t2primes
    return(sum(rt1plust2))
}

x=seq(13, 1000000, by=10000)
y=sapply(x, FUN = stp)
plot(x,y,type="b")
]]></programlisting>
       <para>A Brun tétel az ikerprímekkel foglalkozik, és kimondja, hogy ezen prímek reciprokösszege egy véges értékhez konvergál, ún. Brun-konstans felé.
       jelölése: <command>B<subscript>2</subscript></command></para>
       <para>Mivel az R nyelvben még gyakorlatlanok vagyunk, így megint soronként fogok magyarázatot adni a forráskódra.
       </para>
       <programlisting language="r"><![CDATA[library(matlab)

stp <- function(x){

    primes = primes(x)
    diff = primes[2:length(primes)]-primes[1:length(primes)-1]
    idx = which(diff==2)
    t1primes = primes[idx]
    t2primes = primes[idx]+2
    rt1plust2 = 1/t1primes+1/t2primes
    return(sum(rt1plust2))
}
]]></programlisting>
 <para>A library(matlab) paranncsal meghívjuk a matlab külső fájlt, amelyben egyéb függvények mellett megtalálható a <command>primes()</command> függvény.
Ez a függvény a paraméterként megadott számig kiszámolja a prímszámokat. 
R-ben a függvény létrehozása így történik:</para>
<para><![CDATA[függvénynév <- function(paraméter lista){függvény törzs
return(visszatérési érték)} ]]></para>
<para>az első sorban feltöltjük a primes változót a <command>primes(x)</command> függvény értékeivel.
majd a második sorban a diff változóba belerakjuk nd&gt; és a <command>primes[1:length(primes)-1]</command> vektorok különbségét.
</para>
<para>a <command>primes[2:length(primes)]</command> vektor a primes 2. elemétől a változó hosszáig tartalmazza a számokat.
Ezzel szemben a <command>primes[1:length(primes)-1]</command> rész a primes 1. elemétől az utolsó előtti elemig tartalmazza a számokat.
Ezeket kivonva megkapjuk a prímszámok különbségét.
Ha ez a külnbség 2, akkor beszélünk ikerprímekről.
Azt, hogy a különbség 2-e, az idx változó nézi meg, majd az indexüket eltárolja.</para>
<para>a t1primes változó tartalmazza azokat a prímeket, amelyeknek a helyét már meghatároztuk az idx változóban.
Tehát az ikerprímek első fele.
A t2primes viszont nem szimplán a primes[idx]-et adja vissza, hiszen az az ikrek első fele lenne, de tudjuk, hogy a különbség a kettő prím között 2, tehát a másik felét úgy kapjuk meg, ha hozzáadunk az [idx] helyen álló számhoz 2-őt.
</para>
<para>Az rt1plust2 változóban összeadjuk a t1 és a t2 reciprokait.
majd végezetül visszaadjuk a return()-ben a reciprokértékek összegét.</para>   
 </section>
    
    <section xml:id="bhax-textbook-feladatok-turing.MontyHall">
        <title>A Monty Hall probléma</title>
        <para>
            Írj R szimulációt a Monty Hall problémára!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan">https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan</link>
        </para>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/MontyHall_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/MontyHall_R</link>
        </para>
        <para><programlisting language="r">
        <![CDATA[kiserletek_szama=10000000
kiserlet = sample(1:3, kiserletek_szama, replace=T)
jatekos = sample(1:3, kiserletek_szama, replace=T)
musorvezeto=vector(length = kiserletek_szama)

for (i in 1:kiserletek_szama) {

    if(kiserlet[i]==jatekos[i]){
    
        mibol=setdiff(c(1,2,3), kiserlet[i])
    
    }else{
    
        mibol=setdiff(c(1,2,3), c(kiserlet[i], jatekos[i]))
    
    }

    musorvezeto[i] = mibol[sample(1:length(mibol),1)]

}

nemvaltoztatesnyer= which(kiserlet==jatekos)
valtoztat=vector(length = kiserletek_szama)

for (i in 1:kiserletek_szama) {

    holvalt = setdiff(c(1,2,3), c(musorvezeto[i], jatekos[i]))
    valtoztat[i] = holvalt[sample(1:length(holvalt),1)]
    
}

valtoztatesnyer = which(kiserlet==valtoztat)


sprintf("Kiserletek szama: %i", kiserletek_szama)
length(nemvaltoztatesnyer)
length(valtoztatesnyer)
length(nemvaltoztatesnyer)/length(valtoztatesnyer)
length(nemvaltoztatesnyer)+length(valtoztatesnyer)
]]>
        </programlisting></para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
            </para><para>a kísérlet változóban található a nyeremény helye,
            a játékos változóban található a játékos által választott ajtó.
            Az első for ciklusban megnézzük, hogy a játékos eltalálta-e a helyes ajtó számát, és a műsorvezető ezen feltételtől függően választ ajtót magának.
            Ha eltalálta, akkor a műsorvezető véŁetlenszerűen választ a két üres ajtó közül.
            Viszont ha nem találta el a játékos, akkor a vezető csak 1 ajtót választhat, hiszen nem nyithatja ki a nyereményt, se a játékos által választott ajtót.
        </para>
        <para/>
    </section>

</chapter>     
    
    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chomsky!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Decimálisból unárisba átváltó Turing gép</title>
        <para>
            Állapotátmenet gráfjával megadva írd meg ezt a gépet!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <figure>
            <title>Az <type> átváltó</type> Turing gép</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="elmélet/unar_dec.png" scale="70"/>
                </imageobject>
                <textobject>
                    <phrase>Az <type> átváltó</type> Turing gép</phrase>
                </textobject>
            </mediaobject>
        </figure>    
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>Az átváltó bekér egy Decimális számot, legyen ez egy tetszőleges szám, és nevezzük el N-nek.
        Ezután egy képlettel átváltja azt Unáris számrendszerbe.
        Ez a képlet a következő: <command>unar=egysegelem*N</command>
        majd "kirajzolja" az eredményt.</para>
    </section>        
        
    <section>
        <title>Az a<superscript>n</superscript>b<superscript>n</superscript>c<superscript>n</superscript> nyelv nem környezetfüggetlen</title>
        <para>
            Mutass be legalább két környezetfüggő generatív grammatikát, amely ezt a nyelvet generálja!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:    <link xlink:href="https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog1_1.pdf?fbclid=IwAR2APDrK-Cky5lqHy_fCBzTZ_9fEhFCRuHHHExeK3WUQuOfzcUSfeVbNfqI">A lentebb látható képek itt megtalálhatóak a 30. oldalon</link>   
        </para>
        <figure>
            <title>A <type> környezetfüggő</type> grammatikák</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="elmélet/nyelvosztaly.png" scale="40"/>
                </imageobject>
                <textobject>
                    <phrase>Környezetfüggés két példában</phrase>
                </textobject>
            </mediaobject>
        </figure>  
        <para>
            Tanulságok, tapasztalatok, magyarázat...
       </para>
       <para>A konstansok és változók alatt helyezkednek el a helyettesítési szabályok.
       Ezeket a szabályokat alkalmazva addig változtatjuk a megadott szót, amíg a szó maga már csak konstansokból áll.
       Mivel nincs olyan lehetőség, hogy a szó csak változókból áll, ezért a nyelvezet nem lehet környezetfüggetlen.</para>
       <para>Környezetfüggő(hossznemcsökkentő)</para><para>P1XP2 → P1QP2, P1, P2 eleme (VN U VT)*, X VN beli, Q (VN U VT)+ beli, kivéve S → üres, de akkor S nem lehet jobb oldali egyetlen szabályban sem, tehát Az a<superscript>n</superscript>b<superscript>n</superscript>c<superscript>n</superscript> nyelv nem környezetfüggetlen
        </para>
        <para/>
    </section>        
                
    <section>
        <title>Hivatkozási nyelv</title>
        <para>
            A <citation>KERNIGHANRITCHIE</citation> könyv C referencia-kézikönyv/Utasítások melléklete alapján definiáld 
            BNF-ben a C utasítás fogalmát!
            Majd mutass be olyan kódcsipeteket, amelyek adott szabvánnyal nem fordulnak (például C89), mással (például C99) igen.
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása:  
        </para>
        <para>
        <programlisting language="c"><![CDATA[#include <stdio.h>

int main()
{
	int inline asdfunc(int a)
	{
	int b = a*a;
	a=b*a;
	return a;
	}

asdfunc(5);
return 0;
}]]></programlisting>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>
        <link xlink:href="https://github.com/ghjbku/DE/blob/master/c%20cuccok/Bildschirmfoto%20von%202019-03-12%2011-35-07.png"/>
        Amint láthatjuk, a funkcíó minden gond nélkül lefordul C99-ben, míg C89-ben hibát észlel.
        A hiba az *inline* parancs miatt van.
        ez a cmd a C99-el jött be, amely általában *extern inline* -al párban jelenik meg egy programkódban.
        Segítségével egy program nagyobb sebességre képes, viszont ezért cserébe nagyobb a helyigénye.
        Az inline függvények a sorba illesztődnek be, ha arra szükség van, így jön létre a nagyobb sebesség.
        </para>
    </section>                     

    <section>
        <title>Saját lexikális elemző</title>
        <para>
            Írj olyan programot, ami számolja a bemenetén megjelenő valós számokat! 
            Nem elfogadható olyan megoldás, amely maga olvassa betűnként a bemenetet, 
            a feladat lényege, hogy lexert használjunk, azaz óriások vállán álljunk és ne kispályázzunk!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/9KnMqrkj_kU">https://youtu.be/9KnMqrkj_kU</link> (15:01-től).
        </para>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása: <link xlink:href="Chomsky/realnumber.l">
                <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Chomsky/realnumber.l</filename>
            </link> 
       
        <programlisting language="c"><![CDATA[
        //lex fájl
        //fordítás c-re : lex -o output.c lexfajl.l (szükséges hozzá a flex)
        //jelen esetben: lex -o realnumbers.c realnumbers.l
%{
#include <stdio.h>
int realnumbers = 0;
%}
digit	[0-9]
%%
{digit}*(\.{digit}+)?	{++realnumbers; 
    printf("[realnum=%s %f]", yytext, atof(yytext));}
%%
int
main ()
{
 yylex ();
 printf("The number of real numbers is %d\n", realnumbers);
 return 0;
}
]]></programlisting>
<link xlink:href="https://github.com/ghjbku/DE/blob/master/c%20cuccok/realnumber.c">a C-re fordított program</link>
 ha készen van a fordítás, akkor mondhatjuk a gcc-nek, hogy csináljon nekünk futtatható programot a c forrásból.
 Ezt a következő sor beírásával tehetjük meg: 
 * gcc realnumber.c -o realnumber -lfl *     
         </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>Ebben a feladatban kicsit eltértünk a megszokott dolgoktól, ugyanis nem mi írtuk meg a C forráskódot, hanem a lexer.
        Ez nagyban megkönnyíti a dolgunkat, hiszen ha megnézzük a C forrást, amit a lex elkészített helyettünk, láthatjuk, hogy nem éppen egy rövid kis kódsorozatról van szó
        A lexer segítségével nekünk már csak annyi a dolgunk,hogy megmondjuk neki, milyen típust keressen az inputban"digit[0-9]", és hogyan ismerje azt fel " {digit}*(\.{digit}+)? "</para>
    </section>                     

    <section>
        <title>Leetspeak</title>
        <para>
            Lexelj össze egy l33t ciphert!
        </para>
        <para><command>Tutoráltam: Zsolt Schachinger-t</command>
            Megoldás videó: <link xlink:href="https://youtu.be/06C_PqDpD_k">https://youtu.be/06C_PqDpD_k</link>
        </para>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása: <link xlink:href="Chomsky/l337d1c7.l">
                <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Chomsky/l337d1c7.l</filename>
            </link>  
        </para>
        <programlisting language="c"><![CDATA[%{
//a fordítás megegyezik az előző feladatéval: lex -o output.c lexfájl.l
//majd gcc output.c -o output
  #include <stdio.h>
  #include <stdlib.h>
  #include <time.h>
  #include <ctype.h>

  #define L337SIZE (sizeof l337d1c7 / sizeof (struct cipher))
    
  struct cipher {
    char c;
    char *leet[4];
  } l337d1c7 [] = {

  {'a', {"4", "4", "@", "/-\\"}},
  {'b', {"b", "8", "|3", "|}"}},
  {'c', {"c", "(", "<", "{"}},
  {'d', {"d", "|)", "|]", "|}"}},
  {'e', {"3", "3", "3", "3"}},
  {'f', {"f", "|=", "ph", "|#"}},
  {'g', {"g", "6", "[", "[+"}},
  {'h', {"h", "4", "|-|", "[-]"}},
  {'i', {"1", "1", "|", "!"}},
  {'j', {"j", "7", "_|", "_/"}},
  {'k', {"k", "|<", "1<", "|{"}},
  {'l', {"l", "1", "|", "|_"}},
  {'m', {"m", "44", "(V)", "|\\/|"}},
  {'n', {"n", "|\\|", "/\\/", "/V"}},
  {'o', {"0", "0", "()", "[]"}},
  {'p', {"p", "/o", "|D", "|o"}},
  {'q', {"q", "9", "O_", "(,)"}},
  {'r', {"r", "12", "12", "|2"}},
  {'s', {"s", "5", "$", "$"}},
  {'t', {"t", "7", "7", "'|'"}},
  {'u', {"u", "|_|", "(_)", "[_]"}},
  {'v', {"v", "\\/", "\\/", "\\/"}},
  {'w', {"w", "VV", "\\/\\/", "(/\\)"}},
  {'x', {"x", "%", ")(", ")("}},
  {'y', {"y", "", "", ""}},
  {'z', {"z", "2", "7_", ">_"}},
  
  {'0', {"D", "0", "D", "0"}},
  {'1', {"I", "I", "L", "L"}},
  {'2', {"Z", "Z", "Z", "e"}},
  {'3', {"E", "E", "E", "E"}},
  {'4', {"h", "h", "A", "A"}},
  {'5', {"S", "S", "S", "S"}},
  {'6', {"b", "b", "G", "G"}},
  {'7', {"T", "T", "j", "j"}},
  {'8', {"X", "X", "X", "X"}},
  {'9', {"g", "g", "j", "j"}}
  
// https://simple.wikipedia.org/wiki/Leet
  };
  
%}
%%
.	{
	  
	  int found = 0;
	  for(int i=0; i<L337SIZE; ++i)
	  {
	  
	    if(l337d1c7[i].c == tolower(*yytext))
	    {
	    
	      int r = 1+(int) (100.0*rand()/(RAND_MAX+1.0));
	    
          if(r<91)
	        printf("%s", l337d1c7[i].leet[0]);
          else if(r<95)
	        printf("%s", l337d1c7[i].leet[1]);
	      else if(r<98)
	        printf("%s", l337d1c7[i].leet[2]);
	      else 
	        printf("%s", l337d1c7[i].leet[3]);

	      found = 1;
	      break;
	    }
	    
	  }
	  
	  if(!found)
	     printf("%c", *yytext);	  
	  
	}
%%
int 
main()
{
  srand(time(NULL)+getpid());
  yylex();
  return 0;
}
]]></programlisting>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>Ez a program a terminálról beolvassa a karaktereket, és randomizálva 4 különböző karaktert rak az eredeti helyére.
        Ha számára ismeretlen karaktert írunk be, akkor visszaadja ugyan azt.
        A program magja egy l337d1c7 tömb, amely tárolja a helyettesítési értékeket minden karakterhez.
        Ha nem talál egyetlen karaktert sem az inputban, akkor nem ír ki semmit.</para>
    </section>                     


    <section>
        <title>A források olvasása</title>
        <para>
            Hogyan olvasod, hogyan értelmezed természetes nyelven az alábbi kódcsipeteket? Például
            <programlisting><![CDATA[if(signal(SIGINT, jelkezelo)==SIG_IGN)
    signal(SIGINT, SIG_IGN);]]></programlisting>
            Ha a SIGINT jel kezelése figyelmen kívül volt hagyva, akkor ezen túl is legyen
            figyelmen kívül hagyva, ha nem volt figyelmen kívül hagyva, akkor a jelkezelo függvény
            kezelje. (Miután a <command>man 7 signal</command> lapon megismertem a SIGINT jelet, a
            <command>man 2 signal</command> lapon pedig a használt rendszerhívást.)
        </para>

        <caution>
            <title>Bugok</title>
            <para>
                Vigyázz, sok csipet kerülendő, mert bugokat visz a kódba! Melyek ezek és miért? 
                Ha nem megy ránézésre, elkapja valamelyiket esetleg a splint vagy a frama?
            </para>
        </caution>
            
        <orderedlist numeration="lowerroman">
            <listitem>                                    
                <programlisting><![CDATA[if(signal(SIGINT, SIG_IGN)!=SIG_IGN)
    signal(SIGINT, jelkezelo);]]></programlisting>
            <para>Ha a <command>SIGINT</command> jelzés nem volt ignorálva, akkor ignorálja.</para>
            </listitem>
            <listitem>                                    
                <programlisting><![CDATA[for(i=0; i<5; ++i)]]></programlisting>
                <para>egy for ciklus, amely 0-tól 5-ig tart, tehát 5x fut le, és minden lefutás után inkrementálja az i értékét 1-el, majd az inkrementálási értéket adja vissza.</para>          
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[for(i=0; i<5; i++)]]></programlisting>
                <para>ez is egy for ciklus, viszont ebben az esetben az i inkrementálása után az eredeti, növelés előtti értéket adja vissza.</para>
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[for(i=0; i<5; tomb[i] = i++)]]></programlisting>
                <para>Ebben a for ciklusban nem csak, hogy növeljük az i értékét minden kör után, de ezen értéket behelyezzük egy tömbbe is.</para>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[for(i=0; i<n && (*d++ = *s++); ++i)]]></programlisting>            
             <para>a ciklus 0tól indul, és addig megy, amíg i kissebb mint n, továbbá a <command>d</command> pointer növelt értéke megegysezik az <command>s</command> pointer növelt értékével.</para>
            
            </listitem>
           <listitem>                                    

                <programlisting><![CDATA[printf("%d %d", f(a, ++a), f(++a, a));]]></programlisting>            
            <para>kiír két függvényt, melyek számokat adnak vissza, viszont a visszatérési érték precedenciát sugall.</para>
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[printf("%d %d", f(a), a);]]></programlisting>            
               <para>visszaad kettő számot, melyekből az egyik egy függvény visszatérési értéke</para>
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[printf("%d %d", f(&a), a);]]></programlisting>            
            <para>ugyanúgy két számot ad vissza, de az f függvényben az <command>a</command> változó memóriacíme helyezkedik el.</para>
            </listitem>
        </orderedlist>
    
    </section>                     

    <section>
        <title>Logikus</title>
        <para>
            Hogyan olvasod természetes nyelven az alábbi Ar nyelvű formulákat?
        </para>
        <programlisting language="tex"><![CDATA[$(\forall x \exists y ((x<y)\wedge(y \text{ prím})))$ 

$(\forall x \exists y ((x<y)\wedge(y \text{ prím})\wedge(SSy \text{ prím})))$ 

$(\exists y \forall x (x \text{ prím}) \supset (x<y)) $ 

$(\exists y \forall x (y<x) \supset \neg (x \text{ prím}))$
]]></programlisting>        
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/MatLog_LaTeX">https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/MatLog_LaTeX</link>
        </para>

        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/ZexiPy3ZxsA">https://youtu.be/ZexiPy3ZxsA</link>, <link xlink:href="https://youtu.be/AJSXOQFF_wk">https://youtu.be/AJSXOQFF_wk</link>
        </para>

        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>az első formula természetes nyelvi értelmezése:
        <command> minden x számra létezik egy olyan y szám, amely nagyobb, mint x és y prím</command> </para>
        <para>a második formula természetes nyelvi értelmezése:
        <command> minden x számra létezik egy olyan y szám, amely nagyobb, mint x és y prím.Továbbá y rákövetkezőjének a rákövetkezője is prím.</command> </para>
        <para>a harmadik formula természetes nyelvi értelmezése:
        <command> minden y számra létezik egy olyan x szám, hogy x prím és x kisebb, mint y</command> </para>
        <para>a negyedik formula természetes nyelvi értelmezése:
        <command> minden y számra létezik egy olyan x szám, hogy y kisebb, mint x, és x nem prím.</command> </para>
    
    </section>                                                                                                                                                                            
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
    <section>
        <title>Deklaráció</title>
            
        <para>
           <command>Tutorálva Nagy Krisztián által.</command>
            Vezesd be egy programba (forduljon le) a következőket: 
        </para>

        <itemizedlist>
            <listitem>
                <para>egész</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutató</para>                        
            </listitem>
            <listitem>
                <para>egész referenciája</para>                        
            </listitem>
            <listitem>
                <para>egészek tömbje</para>                        
            </listitem>
            <listitem>
                <para>egészek tömbjének referenciája (nem az első elemé)</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatók tömbje</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatót visszaadó függvény</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatót visszaadó függvényre mutató mutató</para>                        
            </listitem>
            <listitem>
                <para>egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvény</para>                        
            </listitem>            
            <listitem>
                <para>függvénymutató egy egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvényre</para>                        
            </listitem>            
        </itemizedlist>            

        <para>
            Mit vezetnek be a programba a következő nevek?
        </para>

        <itemizedlist>
            <listitem>
                <programlisting><![CDATA[int a;]]></programlisting>  
                <para>egy szám típusú <command>a</command> változót</para>          
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *b = &a;]]></programlisting>   
                 <para>egy szám typusú <command>b pointert</command>, aminek az értéke <command>a memóriában foglalt helye</command></para>             
            </listitem>
            <listitem>
                <programlisting><![CDATA[int &r = a;]]></programlisting>
                 <para>integer típusú <command>r értéke</command> <command>a</command> lesz</para>                
            </listitem>
            <listitem>
                <programlisting><![CDATA[int c[5];]]></programlisting>   
                 <para>létrehoz egy 5 számnak helyet adó <command>c</command> tömböt</para>             
            </listitem>
            <listitem>
                <programlisting><![CDATA[int (&tr)[5] = c;]]></programlisting>  
                 <para>létrehoz egy <command>tr tömb referenciát</command>, melynek az értéke c</para>              
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *d[5];]]></programlisting>   
                 <para>egy egészekre mutató <command>d tömb pointer</command></para>             
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *h ();]]></programlisting>   
                 <para><command>h funkcíóra mutató pointer</command></para>             
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *(*l) ();]]></programlisting> 
                 <para>egy pointer, ami az <command>l függvényre mutató pointerre mutat</command></para>               
            </listitem>
            <listitem>
                <programlisting><![CDATA[int (*v (int c)) (int a, int b)]]></programlisting> 
                  <para>egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvény</para>                        
                        
            </listitem>            
            <listitem>
                <programlisting><![CDATA[int (*(*z) (int)) (int, int);]]></programlisting> 
                 <para>függvénymutató egy egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvényre</para>                                      
            </listitem>            
        </itemizedlist>       


        <para>
            Megoldás videó: 
        </para>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása:  
        </para>
        <para>
            Az utolsó két deklarációs példa demonstrálására két olyan kódot
            írtunk, amelyek összahasonlítása azt mutatja meg, hogy miért 
            érdemes a <command>typedef</command> használata: <link xlink:href="Chomsky/fptr.c">
                <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Chomsky/fptr.c</filename>
            </link>,
            <link xlink:href="Chomsky/fptr2.c">
                <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Chomsky/fptr2.c</filename>.
            </link>  
            
        </para>
        <programlisting><![CDATA[#include <stdio.h>

int
sum (int a, int b)
{
    return a + b;
}

int
mul (int a, int b)
{
    return a * b;
}

int (*sumormul (int c)) (int a, int b)
{
    if (c)
        return mul;
    else
        return sum;

}

int
main ()
{

    int (*f) (int, int);

    f = sum;

    printf ("%d\n", f (2, 3));

    int (*(*g) (int)) (int, int);

    g = sumormul;

    f = *g (42);

    printf ("%d\n", f (2, 3));

    return 0;
}]]></programlisting>            
        <programlisting><![CDATA[#include <stdio.h>

typedef int (*F) (int, int);
typedef int (*(*G) (int)) (int, int);

int
sum (int a, int b)
{
    return a + b;
}

int
mul (int a, int b)
{
    return a * b;
}

F sumormul (int c)
{
    if (c)
        return mul;
    else
        return sum;
}

int
main ()
{

    F f = sum;

    printf ("%d\n", f (2, 3));

    G g = sumormul;

    f = *g (42);

    printf ("%d\n", f (2, 3));

    return 0;
}
]]></programlisting>            

    </section>                     

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Caesar!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title><type>double **</type> háromszögmátrix</title>
        <para>
            Írj egy olyan <function>malloc</function> és <function>free</function>
            párost használó C programot, amely helyet foglal
            egy alsó háromszög mátrixnak a szabad tárban!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/1MRTuKwRsB0">https://youtu.be/1MRTuKwRsB0</link>,
            <link xlink:href="https://youtu.be/RKbX5-EWpzA">https://youtu.be/RKbX5-EWpzA</link>.

        </para>
        <para>
            Megoldás forrása: <link xlink:href="Caesar/tm.c">
                <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Caesar/tm.c</filename>
            </link> 
        </para>
        <para>
        <programlisting language="c"><![CDATA[
#include <stdio.h>
#include <stdlib.h>

int
main ()
{
    int nr = 5;
    double **tm;
    
    printf("%p\n", &tm);
    
    if ((tm = (double **) malloc (nr * sizeof (double *))) == NULL)
    {
        return -1;
    }

    printf("%p\n", tm);
    
    for (int i = 0; i < nr; ++i)
    {
        if ((tm[i] = (double *) malloc ((i + 1) * sizeof (double))) == NULL)
        {
            return -1;
        }

    }

    printf("%p\n", tm[0]);    
    
    for (int i = 0; i < nr; ++i)
        for (int j = 0; j < i + 1; ++j)
            tm[i][j] = i * (i + 1) / 2 + j;

    for (int i = 0; i < nr; ++i)
    {
        for (int j = 0; j < i + 1; ++j)
            printf ("%f, ", tm[i][j]);
        printf ("\n");
    }

    tm[3][0] = 42.0;
    (*(tm + 3))[1] = 43.0;	// mi van, ha itt hiányzik a külső ()
    *(tm[3] + 2) = 44.0;
    *(*(tm + 3) + 3) = 45.0;

    for (int i = 0; i < nr; ++i)
    {
        for (int j = 0; j < i + 1; ++j)
            printf ("%f, ", tm[i][j]);
        printf ("\n");
    }

    for (int i = 0; i < nr; ++i)
        free (tm[i]);

    free (tm);

    return 0;
}
]]></programlisting>
        <figure>
            <title>A <type>double **</type> háromszögmátrix a memóriában</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/doublecscs.png" scale="50"/>
                </imageobject>
                <textobject>
                    <phrase>A <type>double **</type> háromszögmátrix a memóriában</phrase>
                </textobject>
            </mediaobject>
        </figure>                             
</para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
        <para>
    Az<programlisting language="c"><![CDATA[int nr = 5;]]></programlisting>sorral létrehozunk egy integer változót, amelynek az értéke 5, ez a változó lesz a háromszög sorainak száma.
    A<programlisting language="c"><![CDATA[double **tm;]]></programlisting>sor pedig létrehoz egy double típusú változót, ez lesz később a programunk magja.
    </para><para>Ezek a sorok:<programlisting language="c"><![CDATA[if ((tm = (double **) malloc (nr * sizeof (double *))) == NULL)
    {
        return -1;
    }]]></programlisting>pedig megnézik, hogy a programunk le tud e foglalni <command>nr*8</command> bájtot, ha nem, akkor kilép a programból a <command>-1</command> visszatérési értékkel.
        </para><para><programlisting language="c"><![CDATA[for (int i = 0; i < nr; ++i)
    {
        if ((tm[i] = (double *) malloc ((i + 1) * sizeof (double))) == NULL)
        {
            return -1;
        }
    }]]></programlisting>Itt azt láthatjuk, hogy a program a tm változót tömbként kezelve bejárja azt, és mindíg <command>(i+1)*8</command>bájtot allokál/foglal le az aktuális tömb pozíciójához.
    Ha ez nem sikerül, akkor megint csak kilép <command>-1</command>es visszatérési értékkel.
        </para><para><programlisting language="c"><![CDATA[
        for (int i = 0; i < nr; ++i)
        for (int j = 0; j < i + 1; ++j)
            tm[i][j] = i * (i + 1) / 2 + j; 0 1 

    for (int i = 0; i < nr; ++i)
    {
        for (int j = 0; j < i + 1; ++j)
            printf ("%f, ", tm[i][j]);
        printf ("\n");
    }]]></programlisting>Ezek a ciklusok a kiíratásért felelnek. <command>az első egybeágyazott for ciklus pár</command> a tm változót tölti fe1 számokkal 0-tól 15-ig, majd <command>a második cikluspár</command> kiíratja azokat</para>
    <para><programlisting language="c"><![CDATA[for (int i = 0; i < nr; ++i)
        free (tm[i]);

    free (tm);]]></programlisting>Ezek a sorok a program végén felszabadítják a lefoglalt memóriahelyeket, először a változó tömbelemeitől kezdve, majd végül a most már üres változót is letörli.</para></section>        
    <section>
        <title>C EXOR titkosító</title>
        <para>
            Írj egy EXOR titkosítót C-ben!
        </para>
        <para><command>Tutoráltam: Schachinger Zsoltot</command>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása :          
        </para>
        <para><programlisting language="c"><![CDATA[
#include <stdio.h>
#include <unistd.h>
#include <string.h>

#define MAX_KULCS 100
#define BUFFER_MERET 256

int
main(int argc, char **argv)
{

char kulcs[MAX_KULCS];
char buffer[BUFFER_MERET];
int kulcs_index=0;
int olvasott_bajtok=0;
int kulcs_meret=strlen (argv[1]);
strncpy (kulcs,argv[1], MAX_KULCS);

while ((olvasott_bajtok=read(0,(void *) buffer, BUFFER_MERET)))
 {
	for (int i=0; i<olvasott_bajtok;++i)
	{
	buffer[i]=buffer[i]^ kulcs[kulcs_index];
	kulcs_index=(kulcs_index+1)% kulcs_meret;
	}
write (1, buffer,olvasott_bajtok);
 }
}]]></programlisting></para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>   
        <para>Amint láthatjuk, a main() függvényben megjelent két ismeretlen paraméter.
        ezek a program futtatásánál játszanak szerepet:<command> az argc</command> jelöli az argumentumok számát, beleértve a <command>./programnév</command> sort is.
        ezzel szemben a <command>**argv</command> egy vektor, amely az argumentumokat tárolja. Itt például, ha a terminálba ezt a sort írjuk:<command> ./fájlnév 1234 -o output.txt</command>, akkor az argc értéke 4 lesz, míg a **argv vektor így néz ki:<![CDATA[ <./fájlnév; 1234; -o; output.txt>]]></para>         
    <para>
<programlisting language="c"><![CDATA[int kulcs_meret=strlen (argv[1]);
strncpy (kulcs,argv[1], MAX_KULCS);]]></programlisting>
Ez a két sor is ismeretlen lehet számunkra, de nem kell tőlük megijedni, elég egyszerű a kezelésük.
az első sor az argumentum_vektor 1. elemét(ami az előző példában az 1234 volt) lekéri, és megszámolja annak hosszát(<command>ez az strlen() függvény dolga</command>), majd a kulcs_meret nevű változónak ezt a hosszt értékül adja.
a második sor pedig egy string másoló függvény, ennek szintaktikája a következő: <command>strncpy(char cél_változó,char másolni_kívánt_érték,a_másolni_kívánt_érték_hossza)</command> (ha a másolt érték kisebb, mint az utolsó paraméterben megadott szám, akkor a maradékot <command>NULL</command> bájtokkal fogja kipótolni a program)</para>
    </section>        
    <section>
        <title>Java EXOR titkosító</title>
        <para>
            Írj egy EXOR titkosítót Java-ban!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/ch01.html#exor_titkosito">https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/ch01.html#exor_titkosito</link>                               
        <programlisting language="java"><![CDATA[public class ExorTitkosító {
    
    public ExorTitkosító(String kulcsSzöveg,
            java.io.InputStream bejövőCsatorna,
            java.io.OutputStream kimenőCsatorna)
            throws java.io.IOException 
    {
        
        byte [] kulcs = kulcsSzöveg.getBytes();
        byte [] buffer = new byte[256];
        int kulcsIndex = 0;
        int olvasottBájtok = 0;

        while((olvasottBájtok =
        bejövőCsatorna.read(buffer)) != -1)
        {
            
            for(int i=0; i<olvasottBájtok; ++i) 
            {
                
                buffer[i] = (byte)(buffer[i] ^ kulcs[kulcsIndex]);
                kulcsIndex = (kulcsIndex+1) % kulcs.length;
                
            }
            
            kimenőCsatorna.write(buffer, 0, olvasottBájtok);
            
        }
        
    }
    
    public static void main(String[] args) {
        
        try {
            
            new ExorTitkosító(args[0], System.in, System.out);
            
        } catch(java.io.IOException e) {
            
            e.printStackTrace();
            
        }
        
    }
    
}]]></programlisting>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>     
        <para>A Java verzió is hasonlóképpen működik, mint a C verzió, csak a nyelvi sajátosságoknak köszönhetően találhatóak különbségek a két kód között.
        Mivel a Java is magasszintű programozási nyelv, ezért a forráskód értelmezése könnyebb, mint egy assembly nyelvé.
        </para><para>A main függvényben található egy try-catch blokk, ez egyfajta hibakeresés.
        A try részbe kerülnek a kódok, amik nagy eséllyel hibát dobhatnak, és a catch részben ezeket a hibákat elkapja a program, és a programozó által megadott üzenetet dobja ki.
        Itt például Ha valami nem stimmel a megadott argumentumokkal, a program kiad egy exception-t.
        Ez a C programban nincs jelen, de ha szeretnénk, akár oda is beleírthatjuk.
        </para> 
        </section>        
    <section>
        <title>C EXOR törő</title>
        <para>
            Írj egy olyan C programot, amely megtöri az első feladatban előállított titkos szövegeket!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para><programlisting language="c"><![CDATA[
#define MAX_TITKOS 4096
#define OLVASAS_BUFFER 256
#define KULCS_MERET 8
#define _GNU_SOURCE

#include <stdio.h>
#include <unistd.h>
#include <string.h>

double
atlagos_szohossz (const char *titkos, int titkos_meret)
{
    int sz = 0;
    for (int i = 0; i < titkos_meret; ++i)
        if (titkos[i] == ' ')
            ++sz;

    return (double) titkos_meret / sz;
}

int
tiszta_lehet (const char *titkos, int titkos_meret)
{
    // a tiszta szoveg valszeg tartalmazza a gyakori magyar szavakat
    // illetve az átlagos szóhossz vizsgálatával csökkentjük a
    // potenciális töréseket

    double szohossz = atlagos_szohossz (titkos, titkos_meret);

    return szohossz > 6.0 && szohossz < 9.0
           && strcasestr (titkos, "hogy") && strcasestr (titkos, "nem")
           && strcasestr (titkos, "az") && strcasestr (titkos, "ha");

}

void
exor (const char kulcs[], int kulcs_meret, char titkos[], int titkos_meret)
{

    int kulcs_index = 0;

    for (int i = 0; i < titkos_meret; ++i)
    {

        titkos[i] = titkos[i] ^ kulcs[kulcs_index];
        kulcs_index = (kulcs_index + 1) % kulcs_meret;

    }

}

int
exor_tores (const char kulcs[], int kulcs_meret, char titkos[],
            int titkos_meret)
{

    exor (kulcs, kulcs_meret, titkos, titkos_meret);

    return tiszta_lehet (titkos, titkos_meret);

}

int
main (void)
{

    char kulcs[KULCS_MERET];
    char titkos[MAX_TITKOS];
    char *p = titkos;
    int olvasott_bajtok;

    // titkos fajt berantasa
    while ((olvasott_bajtok =
                read (0, (void *) p,
                      (p - titkos + OLVASAS_BUFFER <
                       MAX_TITKOS) ? OLVASAS_BUFFER : titkos + MAX_TITKOS - p)))
        p += olvasott_bajtok;

    // maradek hely nullazasa a titkos bufferben
    for (int i = 0; i < MAX_TITKOS - (p - titkos); ++i)
        titkos[p - titkos + i] = '\0';

    // osszes kulcs eloallitasa
    for (int ii = '0'; ii <= '9'; ++ii)
        for (int ji = '0'; ji <= '9'; ++ji)
            for (int ki = '0'; ki <= '9'; ++ki)
                for (int li = '0'; li <= '9'; ++li)
                    for (int mi = '0'; mi <= '9'; ++mi)
                        for (int ni = '0'; ni <= '9'; ++ni)
                            for (int oi = '0'; oi <= '9'; ++oi)
                                for (int pi = '0'; pi <= '9'; ++pi)
                                {
                                    kulcs[0] = ii;
                                    kulcs[1] = ji;
                                    kulcs[2] = ki;
                                    kulcs[3] = li;
                                    kulcs[4] = mi;
                                    kulcs[5] = ni;
                                    kulcs[6] = oi;
                                    kulcs[7] = pi;

                                    if (exor_tores (kulcs, KULCS_MERET, titkos, p - titkos))
                                        printf
                                        ("Kulcs: [%c%c%c%c%c%c%c%c]\nTiszta szoveg: [%s]\n",
                                         ii, ji, ki, li, mi, ni, oi, pi, titkos);

                                    // ujra EXOR-ozunk, igy nem kell egy masodik buffer
                                    exor (kulcs, KULCS_MERET, titkos, p - titkos);
                                }

    return 0;
}]]></programlisting></para>
    <para>és a több magos változat:</para>
        <para><programlisting language="c"><![CDATA[
#define MAX_TITKOS 4096
#define OLVASAS_BUFFER 256
#define KULCS_MERET 8
#define _GNU_SOURCE

#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>

double
atlagos_szohossz (const char *titkos, int titkos_meret)
{
    int sz = 0;
    for (int i = 0; i < titkos_meret; ++i)
        if (titkos[i] == ' ')
            ++sz;

    return (double) titkos_meret / sz;
}

int
tiszta_lehet (const char *titkos, int titkos_meret)
{
    // a tiszta szoveg valszeg tartalmazza a gyakori magyar szavakat
    // illetve az átlagos szóhossz vizsgálatával csökkentjük a
    // potenciális töréseket

    double szohossz = atlagos_szohossz (titkos, titkos_meret);

    return szohossz > 6.0 && szohossz < 9.0
           && strcasestr (titkos, "hogy") && strcasestr (titkos, "nem")
           && strcasestr (titkos, "az") && strcasestr (titkos, "ha");

}

void
exor (const char kulcs[], int kulcs_meret, char titkos[], int titkos_meret, char *buffer)
{

    int kulcs_index = 0;

    for (int i = 0; i < titkos_meret; ++i)
    {

        buffer[i] = titkos[i] ^ kulcs[kulcs_index];
        kulcs_index = (kulcs_index + 1) % kulcs_meret;

    }

}

void
exor_tores (const char kulcs[], int kulcs_meret, char titkos[],
            int titkos_meret)
{

    char *buffer;

    if ((buffer = (char *)malloc(sizeof(char)*titkos_meret)) == NULL)
    {
        printf("Memoria (buffer) faliora\n");
        exit(-1);
    }

    exor (kulcs, kulcs_meret, titkos, titkos_meret, buffer);

    if (tiszta_lehet (buffer, titkos_meret))
    {
        printf("Kulcs: [%c%c%c%c%c%c%c%c]\nTiszta szoveg: [%s]\n",
               kulcs[0],kulcs[1],kulcs[2],kulcs[3],kulcs[4],kulcs[5],kulcs[6],kulcs[7], buffer);
    }

    free(buffer);

}

int
main (void)
{

    char kulcs[KULCS_MERET];
    char titkos[MAX_TITKOS];
    char *p = titkos;
    int olvasott_bajtok;

    // titkos fajt berantasa
    while ((olvasott_bajtok =
                read (0, (void *) p,
                      (p - titkos + OLVASAS_BUFFER <
                       MAX_TITKOS) ? OLVASAS_BUFFER : titkos + MAX_TITKOS - p)))
        p += olvasott_bajtok;

    // maradek hely nullazasa a titkos bufferben
    for (int i = 0; i < MAX_TITKOS - (p - titkos); ++i)
        titkos[p - titkos + i] = '\0';

    // osszes kulcs eloallitasa
#pragma omp parallel for private(kulcs)
    for (int ii = '0'; ii <= '9'; ++ii)
        for (int ji = '0'; ji <= '9'; ++ji)
            for (int ki = '0'; ki <= '9'; ++ki)
                for (int li = '0'; li <= '9'; ++li)
                    for (int mi = '0'; mi <= '9'; ++mi)
                        for (int ni = '0'; ni <= '9'; ++ni)
                            for (int oi = '0'; oi <= '9'; ++oi)
                                for (int pi = '0'; pi <= '9'; ++pi)
                                {
                                    kulcs[0] = ii;
                                    kulcs[1] = ji;
                                    kulcs[2] = ki;
                                    kulcs[3] = li;
                                    kulcs[4] = mi;
                                    kulcs[5] = ni;
                                    kulcs[6] = oi;
                                    kulcs[7] = pi;

                                    exor_tores (kulcs, KULCS_MERET, titkos, p - titkos);

                                }

    return 0;
}]]></programlisting></para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>   
        <para>az atlagos_szohossz függvény bekéri a titkos szöveget és méretét, majd egy 'sz' változóban megszámolja, hogy hány szóköz található a szövegben.
        Ezután a szöveg teljes méretét elosztja az 'sz' változó értékével, így megkapva az átlagos szóhosszt.
        </para>
        <para>az strcasestr függvény azt keresi, hogy a titkos-ban megtalálható-e a <command>2. paraméterben megadott szöveg</command> eg.:"hogy" és "nem"</para>         
        <para>A többmagos változatban a különbség ott mutatkozik meg, hogy az <command>összes kulcs előállítása</command> résznél a #pragma sor megjelenik.
        Ez a processzor magok között szétosztja a tennivalót, és "párhuzamosan" számolja majd írja ki az összes lehetséges kulcsot.</para>
    </section>        
    <section>
        <title>Neurális OR, AND és EXOR kapu</title>
        <para>
            R
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/Koyw6IH5ScQ">https://youtu.be/Koyw6IH5ScQ</link>
        </para>
        <para>
           Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R</link>               
        </para>
        <para><programlisting language="r"><![CDATA[
#   Copyright (C) 2019  Dr. Norbert Bátfai, nbatfai@gmail.com
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>
#
# https://youtu.be/Koyw6IH5ScQ

library(neuralnet)

a1    <- c(0,1,0,1)
a2    <- c(0,0,1,1)
OR    <- c(0,1,1,1)

or.data <- data.frame(a1, a2, OR)

nn.or <- neuralnet(OR~a1+a2, or.data, hidden=0, linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)

plot(nn.or)

compute(nn.or, or.data[,1:2])


a1    <- c(0,1,0,1)
a2    <- c(0,0,1,1)
OR    <- c(0,1,1,1)
AND   <- c(0,0,0,1)

orand.data <- data.frame(a1, a2, OR, AND)

nn.orand <- neuralnet(OR+AND~a1+a2, orand.data, hidden=0, linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)

plot(nn.orand)

compute(nn.orand, orand.data[,1:2])



a1      <- c(0,1,0,1)
a2      <- c(0,0,1,1)
EXOR    <- c(0,1,1,0)

exor.data <- data.frame(a1, a2, EXOR)

nn.exor <- neuralnet(EXOR~a1+a2, exor.data, hidden=0, linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)

plot(nn.exor)

compute(nn.exor, exor.data[,1:2])



a1      <- c(0,1,0,1)
a2      <- c(0,0,1,1)
EXOR    <- c(0,1,1,0)

exor.data <- data.frame(a1, a2, EXOR)

nn.exor <- neuralnet(EXOR~a1+a2, exor.data, hidden=c(6, 4, 6), linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)

plot(nn.exor)

compute(nn.exor, exor.data[,1:2])

]]></programlisting></para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>Ez a program a neurális hálóra alapszik.
        <command>A neurális hálózat biológiai neuronok összekapcsolt csoportja. Modern használatban a szó alatt a mesterséges neurális hálót értjük, amelyek mesterséges neuronokból állnak.</command>
        forrás: <link xlink:href="https://hu.wikipedia.org/wiki/Neur%C3%A1lis_h%C3%A1l%C3%B3zat">https://hu.wikipedia.org/wiki/Neur%C3%A1lis_h%C3%A1l%C3%B3zat</link></para><para>
        Itt a library(neuralnet) sor hasonlóképpen működik, mint a #include parancs a C nyelvekben.
        A számításokért ez a könyvtár felel.
        Ezek a neurális hálók egyfajta ai-ként tekinthetőek, azaz megtanítjuk a számítógépnek, hogy az egyes kapukat felismerje.
        Ez a három kapu az OR,AND,ORAND és az EXOR.
        </para>
        <para>Az OR kapu és annak "plotolása" itt található</para>
        <programlisting><![CDATA[or.data <- data.frame(a1, a2, OR)

nn.or <- neuralnet(OR~a1+a2, or.data, hidden=0, linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)

plot(nn.or)]]></programlisting> 
          <para>Az ORAND pedig itt:</para>    
        <programlisting><![CDATA[a1    <- c(0,1,0,1)
a2    <- c(0,0,1,1)
OR    <- c(0,1,1,1)
AND   <- c(0,0,0,1)

orand.data <- data.frame(a1, a2, OR, AND)

nn.orand <- neuralnet(OR+AND~a1+a2, orand.data, hidden=0, linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)

plot(nn.orand)

compute(nn.orand, orand.data[,1:2])]]></programlisting>  
          <para>Végül pedig az EXOR kapu:</para>
        <programlisting><![CDATA[a1      <- c(0,1,0,1)
a2      <- c(0,0,1,1)
EXOR    <- c(0,1,1,0)

exor.data <- data.frame(a1, a2, EXOR)

nn.exor <- neuralnet(EXOR~a1+a2, exor.data, hidden=c(6, 4, 6), linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)

plot(nn.exor)

compute(nn.exor, exor.data[,1:2])]]></programlisting>       
    </section>        
    <section>
        <title>Hiba-visszaterjesztéses perceptron</title>
        <para>
            C++
        </para>
        <para>
             Megoldás videó: <link xlink:href="https://youtu.be/XpBnR31BRJY">https://youtu.be/XpBnR31BRJY</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/nbatfai/nahshon/blob/master/ql.hpp#L64">https://github.com/nbatfai/nahshon/blob/master/ql.hpp#L64</link>               
        </para>
        <para>
        <!--<programlisting language="c++"><![CDATA[]]></programlisting>-->
        A forráskódot a hossza miatt nem tenném bele a könyvbe, de kódsnippet-eket fogok használni.
        </para>
        <para><programlisting language="c++">
        <![CDATA[//main.cpp fájl tartalma
        #include <iostream>
        #include "mlp.cpp"
        #include <png++/png.hpp>

        int main (int argc, char **argv)
        {
        png::image <png::rgb_pixel> png_image (argv[1]);

        int size = png_image.get_width()*png_image.get_height();

        Perceptron* p = new Perceptron (3, size, 256,1);
        double* image = new double(size);

            for(int i {0};i<png_image.get_width();++i)
                for(int j{0};j<png_image.get_height();++j)
                    image[i*png_image.get_Width()+j]= png_image[i][j].red;
        double value = (*p) (image);
        std::cout <<value<<std:endl;

        delete p;
        delete [] image;
        }
        ]]>
        </programlisting></para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>   
        <para>A program lényegében annyit csinál, hogy végigfut a bemeneten, és megszámolja a piros pixeleket.
        Ezt a két egymásba épített forciklusban láthatjuk.
        az első ciklus <command><![CDATA[for(int i {0};i<png_image.get_width();++i)]]></command> 0-tól a kép szélességéig fut, míg a második ciklus
        <command><![CDATA[for(int j{0};j<png_image.get_height();++j)]]></command> a kép magasságáig fut,
        a ciklus belsejében található maga a számolási művelet.
        <command><![CDATA[image[i*png_image.get_Width()+j]= png_image[i][j].red;]]></command>
        A kép szélességét szorozza i-vel és hozzáad j-t, és ez lesz az <command>image</command> változónk indexe.
        ezen változót egyenlővé tesszük a png_image[i][j] kép piros(red) tagjával.
        ezután egy value változóban eltároljuk az image változó értékét, amely perceptronra mutat.
        Végül kiírjuk a <command>value</command> értékét.
        a lefordításhoz ezt kell beírni:<command>g++ mpl.hpp main.cpp -o perceptron -lpng -std=c++11</command></para>         
    </section>        
        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Mandelbrot!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section xml:id="bhax-textbook-feladatok-mandelbrot.Mandelbrot">
        <title>A Mandelbrot halmaz</title>
        <para>
            Írj olyan C programot, amely kiszámolja a Mandelbrot halmazt!     
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/gvaqijHlRUs">https://youtu.be/gvaqijHlRUs</link>
        </para>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása:                
 <link xlink:href="../mandelpngt.c++">
                <filename>/mandelpngt.c++</filename>
            </link> nevű állománya.            
        </para>
                <figure>
            <title>A Mandelbrot halmaz a komplex síkon</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandel.png" scale="50"/>
                </imageobject>
                <textobject>
                    <phrase>A Mandelbrot halmaz a komplex síkon</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <para>
            A Mandelbrot halmazt 1980-ban találta meg Benoit Mandelbrot a 
            komplex számsíkon. Komplex számok azok a számok, amelyek körében 
            válaszolni lehet az olyan egyébként értelmezhetetlen kérdésekre, 
            hogy melyik az a két szám, amelyet összeszorozva -9-et kapunk, 
            mert ez a szám például a 3i komplex szám.
        </para>
        <para>             
            A Mandelbrot halmazt úgy láthatjuk meg, hogy a sík origója középpontú 4 
            oldalhosszúságú négyzetbe lefektetünk egy, mondjuk 800x800-as 
            rácsot és kiszámoljuk, hogy a rács pontjai mely komplex számoknak 
            felelnek meg. A rács minden pontját megvizsgáljuk a 
            z<subscript>n+1</subscript>=z<subscript>n</subscript>
            <superscript>2</superscript>+c, 
            (0&lt;=n) képlet alapján úgy, hogy a c az éppen vizsgált rácspont. 
            A z0 az origó. Alkalmazva a képletet a 
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    z<subscript>0</subscript> = 0
                </para>
            </listitem>
            <listitem>
                <para>
                    z<subscript>1</subscript> = 0<superscript>2</superscript>+c = c
                </para>
            </listitem>
            <listitem>
                <para>
                    z<subscript>2</subscript> = c<superscript>2</superscript>+c
                </para>
            </listitem>
            <listitem>
                <para>
                    z<subscript>3</subscript> = (c<superscript>2</superscript>+c)<superscript>2</superscript>+c
                </para>
            </listitem>
            <listitem>
                <para>
                    z<subscript>4</subscript> = ((c<superscript>2</superscript>+c)<superscript>2</superscript>+c)<superscript>2</superscript>+c
                </para>
            </listitem>
            <listitem>
                <para>
                    ... s így tovább.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            Azaz kiindulunk az origóból (z<subscript>0</subscript>) 
            és elugrunk a rács első pontjába a z<subscript>1</subscript> = c-be, 
            aztán a c-től függően a további z-kbe. Ha ez az utazás kivezet a 
            2 sugarú körből, akkor azt mondjuk, hogy az a vizsgált rácspont 
            nem a Mandelbrot halmaz eleme. Nyilván nem tudunk végtelen sok 
            z-t megvizsgálni, ezért csak véges sok z elemet nézünk meg minden 
            rácsponthoz. Ha eközben nem lép ki a körből, akkor feketére 
            színezzük, hogy az a c rácspont a halmaz része. (Színes meg úgy 
            lesz a kép, hogy változatosan színezzük, például minél későbbi 
            z-nél lép ki a körből, annál sötétebbre). 
        </para>       
        <para>   
             
        </para>

    </section>        
        
    <section>
        <title>A Mandelbrot halmaz a <filename>std::complex</filename> osztállyal</title>
        <para>
            Írj olyan C++ programot, amely kiszámolja a Mandelbrot halmazt!                     
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/gvaqijHlRUs">https://youtu.be/gvaqijHlRUs</link>
        </para>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása:                
        </para>
        <para>        
A <link xlink:href="#bhax-textbook-feladatok-mandelbrot.Mandelbrot">Mandelbrot halmaz</link> pontban vázolt
ismert algoritmust valósítja meg a repó <link xlink:href="../../../bhax/attention_raising/Mandelbrot/3.1.2.cpp">
                <filename>bhax/attention_raising/Mandelbrot/3.1.2.cpp</filename>
            </link> nevű állománya.
        </para>
        
        <programlisting language="c++">
<![CDATA[// Verzio: 3.1.2.cpp
// Forditas:
// g++ 3.1.2.cpp -lpng -O3 -o 3.1.2
// Futtatas:
// ./3.1.2 mandel.png 1920 1080 2040 -0.01947381057309366392260585598705802112818 -0.0194738105725413418456426484226540196687 0.7985057569338268601555341774655971676111 0.798505756934379196110285192844457924366
// ./3.1.2 mandel.png 1920 1080 1020 0.4127655418209589255340574709407519549131 0.4127655418245818053080142817634623497725 0.2135387051768746491386963270997512154281 0.2135387051804975289126531379224616102874
// Nyomtatas:
// a2ps 3.1.2.cpp -o 3.1.2.cpp.pdf -1 --line-numbers=1  --left-footer="BATF41 HAXOR STR34M" --right-footer="https://bhaxor.blog.hu/" --pro=color
// ps2pdf 3.1.2.cpp.pdf 3.1.2.cpp.pdf.pdf
//
//
// Copyright (C) 2019
// Norbert Bátfai, batfai.norbert@inf.unideb.hu
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.


#include <iostream>
#include "png++/png.hpp"
#include <complex>

int
main ( int argc, char *argv[] )
{

  int szelesseg = 1920;
  int magassag = 1080;
  int iteraciosHatar = 255;
  double a = -1.9;
  double b = 0.7;
  double c = -1.3;
  double d = 1.3;

  if ( argc == 9 )
    {
      szelesseg = atoi ( argv[2] );
      magassag =  atoi ( argv[3] );
      iteraciosHatar =  atoi ( argv[4] );
      a = atof ( argv[5] );
      b = atof ( argv[6] );
      c = atof ( argv[7] );
      d = atof ( argv[8] );
    }
  else
    {
      std::cout << "Hasznalat: ./3.1.2 fajlnev szelesseg magassag n a b c d" << std::endl;
      return -1;
    }

  png::image < png::rgb_pixel > kep ( szelesseg, magassag );

  double dx = ( b - a ) / szelesseg;
  double dy = ( d - c ) / magassag;
  double reC, imC, reZ, imZ;
  int iteracio = 0;

  std::cout << "Szamitas\n";

  // j megy a sorokon
  for ( int j = 0; j < magassag; ++j )
    {
      // k megy az oszlopokon

      for ( int k = 0; k < szelesseg; ++k )
        {

          // c = (reC, imC) a halo racspontjainak
          // megfelelo komplex szam

          reC = a + k * dx;
          imC = d - j * dy;
          std::complex<double> c ( reC, imC );

          std::complex<double> z_n ( 0, 0 );
          iteracio = 0;

          while ( std::abs ( z_n ) < 4 && iteracio < iteraciosHatar )
            {
              z_n = z_n * z_n + c;

              ++iteracio;
            }

          kep.set_pixel ( k, j,
                          png::rgb_pixel ( iteracio%255, (iteracio*iteracio)%255, 0 ) );
        }

      int szazalek = ( double ) j / ( double ) magassag * 100.0;
      std::cout << "\r" << szazalek << "%" << std::flush;
    }

  kep.write ( argv[1] );
  std::cout << "\r" << argv[1] << " mentve." << std::endl;

}
]]>
        </programlisting>   
        <para>A program megírásához szükségünk lesz az STD::complex könyvtárra, és a png++/png.cpp könyvtárra.
        Ez utóbbi felel az adatok képként való megjelenítéséért.
        A kep.set_pixel függvény felel a kép elkészítéséért, míg a benne lévő rgb_pixel a színének módosításáért.</para>     
     
     <programlisting language="c++"><![CDATA[int
main ( int argc, char *argv[] )
{

  int szelesseg = 1920;
  int magassag = 1080;
  int iteraciosHatar = 255;
  double a = -1.9;
  double b = 0.7;
  double c = -1.3;
  double d = 1.3;

  if ( argc == 9 )
    {
      szelesseg = atoi ( argv[2] );
      magassag =  atoi ( argv[3] );
      iteraciosHatar =  atoi ( argv[4] );
      a = atof ( argv[5] );
      b = atof ( argv[6] );
      c = atof ( argv[7] );
      d = atof ( argv[8] );
    }
  else
    {
      std::cout << "Hasznalat: ./3.1.2 fajlnev szelesseg magassag n a b c d" << std::endl;
      return -1;
    }
]]></programlisting>
<para>
Ebben a kódsnippetben láthatjuk, ahogy a main-ben megadunk egy kezdő értéket a létrehozandó képnek.
Az alatta lévő elágazásban megnézzük, hogy az argumentumok száma 9-e, ha igen, akkor
a szelesseg változó értékét megváltoztatja a második argumentummal, a magassag változóét a harmadik argumentummal, az iteraciosHatar változóét
a negyedik argumentummal, és ezeket mind az atoi funkcióval.
Az atoi funkció stringet int-té alakít át.
az a,b,c,d változók értékeit pedit az 5-dik, 6-dik,7-dik és 8-dik argumentummal cseréli ki.
Ezeket mind az atof függvény segytségével érik el, amely stringből double-t csinál.
Ha a feltétel nem teljesül, akkor pedig kiírja a standard kimenetre a használatot, majd <command>-1</command>-el tér vissza. 

</para>
<programlisting language="c++"><![CDATA[png::image < png::rgb_pixel > kep ( szelesseg, magassag );
double dx = ( b - a ) / szelesseg; double dy = ( d - c ) / magassag; double reC, imC, reZ, imZ; int iteracio = 0;
std::cout << "Szamitas\n";
// j megy a sorokon for ( int j = 0; j < magassag; ++j )
{
// k megy az oszlopokon
for ( int k = 0; k < szelesseg; ++k ) {
// c = (reC, imC) a halo racspontjainak // megfelelo komplex szam
reC = a + k * dx; imC = d - j * dy;
std::complex<double> c ( reC, imC );
std::complex<double> z_n ( 0, 0 );
iteracio = 0;
while ( std::abs ( z_n ) < 4 && iteracio < iteraciosHatar ) { z_n = z_n * z_n + c;
++iteracio;
}
kep.set_pixel ( k, j,
                          png::rgb_pixel ( iteracio%255, (iteracio*iteracio)%255, 0 ) );
        }

      int szazalek = ( double ) j / ( double ) magassag * 100.0;
      std::cout << "\r" << szazalek << "%" << std::flush;
    }

  kep.write ( argv[1] );
  std::cout << "\r" << argv[1] << " mentve." << std::endl;

}
]]></programlisting>
<para>
    Ebben a kódrészben történik a halmaz előállítása, 
    a reC és imC változók értékmegadása,a c és z_n inicializálása.
    egy while ciklusban iteráljuka z_n változót, megszorozzuk önmagával és hozzáadjuk a c-t.
    Amíg a z_n abszolutértéke kissebb mint 4, és az iteráció kissebb, mint az iterációs határ.
    Alatta láthatjuk a kép elkészítését a set_pixel funkcióval.
    Ezalatt található egy visszajelzés, majd végül a kep.write funkció segítségével az 1. argumentumba megadott 
    fájlnévként kimenti a program a képet.
    Végül pedig kiírja annak nevét a konzolra.
    </para>     
    </section>        
                
    <section>
        <title>Biomorfok</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/IJMbgRzY76E">https://youtu.be/IJMbgRzY76E</link>
        </para>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/Biomorf">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/Biomorf</link>
        </para>
        <para>
            A biomorfokra (a Julia halmazokat rajzoló bug-os programjával) 
            rátaláló Clifford Pickover azt hitte természeti törvényre 
            bukkant: <link xlink:href="https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf">https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf</link> (lásd a 2307. oldal aljától).
        </para>       
        <para>
            A különbség a <link xlink:href="#bhax-textbook-feladatok-mandelbrot.Mandelbrot">Mandelbrot halmaz</link>
            és a Julia halmazok között az, hogy a komplex iterációban az előbbiben a c változó, utóbbiban pedig állandó. 
            A következő Mandelbrot csipet azt mutatja, hogy a c befutja a vizsgált összes rácspontot.
        </para>       
        <programlisting language="c++">
<![CDATA[  // j megy a sorokon
  for ( int j = 0; j < magassag; ++j )
    {
      for ( int k = 0; k < szelesseg; ++k )
        {

          // c = (reC, imC) a halo racspontjainak
          // megfelelo komplex szam

          reC = a + k * dx;
          imC = d - j * dy;
          std::complex<double> c ( reC, imC );

          std::complex<double> z_n ( 0, 0 );
          iteracio = 0;

          while ( std::abs ( z_n ) < 4 && iteracio < iteraciosHatar )
            {
              z_n = z_n * z_n + c;

              ++iteracio;
            }
]]>
        </programlisting>        
        <para>
            Ezzel szemben a Julia halmazos csipetben a cc nem változik, hanem minden vizsgált
            z rácspontra ugyanaz.
        </para>
        <programlisting language="c++">
<![CDATA[    // j megy a sorokon
    for ( int j = 0; j < magassag; ++j )
    {
        // k megy az oszlopokon
        for ( int k = 0; k < szelesseg; ++k )
        {
            double reZ = a + k * dx;
            double imZ = d - j * dy;
            std::complex<double> z_n ( reZ, imZ );

            int iteracio = 0;
            for (int i=0; i < iteraciosHatar; ++i)
            {
                z_n = std::pow(z_n, 3) + cc;
                if(std::real ( z_n ) > R || std::imag ( z_n ) > R)
                {
                    iteracio = i;
                    break;
                }
            }
]]>
        </programlisting>                         
        
        <para>
            A bimorfos algoritmus pontos megismeréséhez ezt a cikket javasoljuk: 
            <link xlink:href="https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf">https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf</link>.
            Az is jó gyakorlat, ha magából ebből a cikkből from scratch kódoljuk be a sajátunkat, de mi a királyi úton járva a 
            korábbi <link xlink:href="#bhax-textbook-feladatok-mandelbrot.Mandelbrot">Mandelbrot halmazt</link> kiszámoló 
            forrásunkat módosítjuk. Viszont a program változóinak elnevezését összhangba hozzuk a közlemény jelöléseivel:
        </para>       
        <programlisting language="c++">
<![CDATA[// Verzio: 3.1.3.cpp
// Forditas:
// g++ 3.1.3.cpp -lpng -O3 -o 3.1.3
// Futtatas:
// ./3.1.3 bmorf.png 800 800 10 -2 2 -2 2 .285 0 10
// Nyomtatas:
// a2ps 3.1.3.cpp -o 3.1.3.cpp.pdf -1 --line-numbers=1  --left-footer="BATF41 HAXOR STR34M" --right-footer="https://bhaxor.blog.hu/" --pro=color
// 
// BHAX Biomorphs
// Copyright (C) 2019
// Norbert Batfai, batfai.norbert@inf.unideb.hu
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.
//
// Version history
//
// https://youtu.be/IJMbgRzY76E
// See also https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf
//

#include <iostream>
#include "png++/png.hpp"
#include <complex>

int
main ( int argc, char *argv[] )
{

    int szelesseg = 1920;
    int magassag = 1080;
    int iteraciosHatar = 255;
    double xmin = -1.9;
    double xmax = 0.7;
    double ymin = -1.3;
    double ymax = 1.3;
    double reC = .285, imC = 0;
    double R = 10.0;

    if ( argc == 12 )
    {
        szelesseg = atoi ( argv[2] );
        magassag =  atoi ( argv[3] );
        iteraciosHatar =  atoi ( argv[4] );
        xmin = atof ( argv[5] );
        xmax = atof ( argv[6] );
        ymin = atof ( argv[7] );
        ymax = atof ( argv[8] );
        reC = atof ( argv[9] );
        imC = atof ( argv[10] );
        R = atof ( argv[11] );

    }
    else
    {
        std::cout << "Hasznalat: ./3.1.2 fajlnev szelesseg magassag n a b c d reC imC R" << std::endl;
        return -1;
    }

    png::image < png::rgb_pixel > kep ( szelesseg, magassag );

    double dx = ( xmax - xmin ) / szelesseg;
    double dy = ( ymax - ymin ) / magassag;

    std::complex<double> cc ( reC, imC );

    std::cout << "Szamitas\n";

    // j megy a sorokon
    for ( int y = 0; y < magassag; ++y )
    {
        // k megy az oszlopokon

        for ( int x = 0; x < szelesseg; ++x )
        {

            double reZ = xmin + x * dx;
            double imZ = ymax - y * dy;
            std::complex<double> z_n ( reZ, imZ );

            int iteracio = 0;
            for (int i=0; i < iteraciosHatar; ++i)
            {

                z_n = std::pow(z_n, 3) + cc;
                //z_n = std::pow(z_n, 2) + std::sin(z_n) + cc;
                if(std::real ( z_n ) > R || std::imag ( z_n ) > R)
                {
                    iteracio = i;
                    break;
                }
            }

            kep.set_pixel ( x, y,
                            png::rgb_pixel ( (iteracio*20)%255, (iteracio*40)%255, (iteracio*60)%255 ));
        }

        int szazalek = ( double ) y / ( double ) magassag * 100.0;
        std::cout << "\r" << szazalek << "%" << std::flush;
    }

    kep.write ( argv[1] );
    std::cout << "\r" << argv[1] << " mentve." << std::endl;

}
]]>
        </programlisting>                                 
      <para>A mandelbrothoz képest ez a program több argumentummal rendelkezik, 9 helyett 12 van.
      Az új argumentumok a <command>d,reC,imC és az R</command>.
      A reC és imC argumentumokból állítsuk elő a cc-t.
       Megtörténik a halmaz előállítása, a z_n változó harmadik hatványra emelése és cc hozzáadása. 
    Ha az R(valós) kissebb, mint a z_n, vagy ha R(képzetes) kissebb, mint z_n, akkor 
    az iteracio változó értékét i-vel tesszük egyenlővé.
    Alatta láthatjuk a kép elkészítését a set_pixel funkcióval.
    Ezalatt található egy visszajelzés, majd végül a kep.write funkció segítségével az 1. argumentumba megadott 
    fájlnévként kimenti a program a képet.
    Végül pedig kiírja annak nevét a konzolra.
      </para>                               
                                                                            
    </section>                     

    <section>
        <title>A Mandelbrot halmaz CUDA megvalósítása</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/gvaqijHlRUs">https://youtu.be/gvaqijHlRUs</link>
        </para>
        <para>
            Megoldás forrása:                
 <link xlink:href="../../../bhax/attention_raising/CUDA/mandelpngc_60x60_100.cu">
                <filename>bhax/attention_raising/CUDA/mandelpngc_60x60_100.cu</filename>
            </link> nevű állománya.            
        </para>
    </section>                     

    <section>
        <title>Mandelbrot nagyító és utazó C++ nyelven</title>
        <para>
            Építs GUI-t a Mandelbrot algoritmusra, lehessen egérrel nagyítani egy területet, illetve egy pontot
            egérrel kiválasztva vizualizálja onnan a komplex iteréció bejárta z<subscript>n</subscript> komplex számokat!
        </para>
        <para>
            Megoldás videó: <link xlink:href=""/>
            Illetve <link xlink:href="https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal">https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal</link>.        </para>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása: <link xlink:href="https://github.com/ghjbku/DE/tree/master/sajat/biomoprhs"/>
        </para>
        <para>Ezen feladat megoldása hihetetlenül sokáig tartott, és ez alatt nem a program megírását értem, hanem annak lefordítását.
        a legnagyobb fejfájást a makefile legenerálása okozta, viszont hosszas keresgélés után ráleltem a megoldásra, ami egyetlen sor:<command>sudo apt-get install qt5-default</command> ezután jöhet a <command>qmake -project</command> parancs, amivel létrehozzuk a *.pro fájlunkat, ebből lesz a make fájl.
        A makefile legenerálása ezen parancs beírásával történik: <command>qmake profájlneve.pro</command>, majd <command>make</command> és már futtatható a program.
        a képet a jobb egérgomb használatával lehet nagyítani.</para>
    </section>                     
                                                                                                                                                                            
    <section>
        <title>Mandelbrot nagyító és utazó Java nyelven</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/Ui3B6IJnssY">https://youtu.be/Ui3B6IJnssY</link>, 4:27-től.
            Illetve <link xlink:href="https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal">https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal</link>.
        </para>
        <para>
	Köszönet a forráskódért:<link xlink:href="https://github.com/lovaszbotond/Mandelbrot/blob/master/Javanagyito">Lovász Botond</link>        </para>
       <programlisting><![CDATA[
import java.awt.*;
import java.awt.image.BufferedImage;
import javax.swing.*;
import java.awt.event.*;
 
public class Mandelbrot extends JFrame implements ActionListener {
 
	private JPanel ctrlPanel;
	private JPanel btnPanel;
    private int numIter = 50;
    private double zoom = 130;
    private double zoomIncrease = 100;
    private int colorIter = 20;
    private BufferedImage I;
    private double zx, zy, cx, cy, temp;
    private int xMove, yMove = 0;
    private JButton[] ctrlBtns = new JButton[9];
    private Color themeColor = new Color(150,180,200);
 
    public Mandelbrot() {
        super("Mandelbrot Set");
        setBounds(100, 100, 800, 600);
        setResizable(false);
        setDefaultCloseOperation(EXIT_ON_CLOSE);
        plotPoints();
        
        Container contentPane = getContentPane();
        
        contentPane.setLayout(null);
        
        
        
        
        ctrlPanel = new JPanel();
        ctrlPanel.setBounds(600,0,200,600);
        ctrlPanel.setBackground(themeColor);
        ctrlPanel.setLayout(null);
        
        btnPanel = new JPanel();
        btnPanel.setBounds(0,200,200,200);
        btnPanel.setLayout(new GridLayout(3,3));
        btnPanel.setBackground(themeColor);
        
        ctrlBtns[1] = new JButton("up");
        ctrlBtns[7] = new JButton("down");
        ctrlBtns[3] = new JButton ("left");
        ctrlBtns[5] = new JButton("right");
        ctrlBtns[2] = new JButton("+");
        ctrlBtns[0] = new JButton("-");
        ctrlBtns[8] = new JButton(">");
        ctrlBtns[6] = new JButton("<");
        ctrlBtns[4] = new JButton();
        
        contentPane.add(ctrlPanel);
        contentPane.add(new imgPanel());
        ctrlPanel.add(btnPanel);
        
        for (int x = 0; x<ctrlBtns.length;x++){
        	btnPanel.add(ctrlBtns[x]);
        	ctrlBtns[x].addActionListener(this);
        }
        
        validate();
        
    }
 
    public class imgPanel extends JPanel{
    	public imgPanel(){
    		setBounds(0,0,600,600);
    		
    	}
    	
    	@Override
    	public void paint (Graphics g){
    		super.paint(g);
    		g.drawImage(I, 0, 0, this);
    	}
    }
    
    public void plotPoints(){
    	I = new BufferedImage(getWidth(), getHeight(), BufferedImage.TYPE_INT_RGB);
        for (int y = 0; y < getHeight(); y++) {
            for (int x = 0; x < getWidth(); x++) {
                zx = zy = 0;
                cx = (x - 320+xMove) / zoom;
                cy = (y - 290+yMove) / zoom;
                int iter = numIter;
                while (zx * zx + zy * zy < 4 && iter > 0) {
                    temp = zx * zx - zy * zy + cx;
                    zy = 2 * zx * zy + cy;
                    zx = temp;
                    iter--;
                }
                I.setRGB(x, y, iter | (iter << colorIter));
            }
        }
    }
    
    public void actionPerformed(ActionEvent ae){
    	String event = ae.getActionCommand();
    	
    	switch (event){
    	case "up":
    		yMove-=100;
    		break;
    	case "down":
    		yMove+=100;
    		break;
    	case "left":
    		xMove-=100;
    		break;
    	case "right":
    		xMove+=100;
    		break;
    	case "+":
    		zoom+=zoomIncrease;
    		zoomIncrease+=100;
    		break;
    	case "-":
    		zoom-=zoomIncrease;
    		zoomIncrease-=100;
    		break;
    	case ">":
    		colorIter++;
    		break;
    	case "<":
    		colorIter--;
    		break;
    	}
    	
    	
    	
    	plotPoints();
    	validate();
    	repaint();
    }
    
    
    
 
    public static void main(String[] args) {
        new Mandelbrot().setVisible(true);
    }
}
]]></programlisting>
<para>A program hasonlóképp funkcionál, mint a c++ verzió, viszont itt már több lehetőségünk van manipulálni a mutatott képet.
</para><para>Először létrehozzuk a "ctrlBtns[*]" változókat, majd lehallgatjuk őket a <command>ctrlBtns[x].addActionListener(this)</command> parancssal.
A Switch-ben inicializáljuk a gombok funkcióját.
A felfelé nyíl esetén az y koordinátánkat csökkentsük 100-al, lefelé nyíl esetén növeljük azt.
Bal nyíl megnyomására az x koordináta csökken 100-al, jobb nyíl-nál pedig növekszik.
A plusz gomb nagyít a képen, a mínusz nyíl távolít.
Végül a két kacsacsőr a szín megjelenítésén változtat.

</para>
    </section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Welch!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Első osztályom</title>
        <para>
            Valósítsd meg C++-ban és Java-ban az módosított polártranszformációs algoritmust! A matek háttér 
            teljesen irreleváns, csak annyiban érdekes, hogy az algoritmus egy számítása során két normálist
            számol ki, az egyiket elspájzolod és egy további logikai taggal az osztályban jelzed, hogy van vagy
            nincs eltéve kiszámolt szám.
        </para>
        <para>
            Megoldás videó:
        </para>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása Java-ban:                
        </para>
        <programlisting language="java"><![CDATA[
        public class PolárGenerátor {
    
    boolean nincsTárolt = true;
    double tárolt;
    
    public PolárGenerátor() {
        
        nincsTárolt = true;
        
    }
    
    public double következő() {
        
        if(nincsTárolt) {
            
            double u1, u2, v1, v2, w;
            do {
                u1 = Math.random();
                u2 = Math.random();
                
                v1 = 2*u1 - 1;
                v2 = 2*u2 - 1;
                
                w = v1*v1 + v2*v2;
                
            } while(w > 1);
            
            double r = Math.sqrt((-2*Math.log(w))/w);
            
            tárolt = r*v2;
            nincsTárolt = !nincsTárolt;
            
            return r*v1;
            
        } else {
            nincsTárolt = !nincsTárolt;
            return tárolt;
        }
    }
    
    public static void main(String[] args) {
        
        PolárGenerátor g = new PolárGenerátor();
        
        for(int i=0; i<10; ++i)
            System.out.println(g.következő());
        
    }
    
}]]></programlisting>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása C++-ban:                
        </para>
        <programlisting language="c++"><![CDATA[#include "std_lib_facilities.h" 


class PolarGenerator{

bool nincsTarolt=true;
double tarolt;

 public :
double kovetkezo()
 {
	

	if(nincsTarolt)
	{
	double u1,u2,v1,v2,w;
	u1= ((double) rand() / (double)(RAND_MAX));
	u2= ((double) rand() / (double)(RAND_MAX));
	v1=(2*u1)-1;
	v2=(2*u2)-1;
	
	w=(v1*v1)+(v2*v2);
	 while(w>1)
	 {double r = sqrt((-2*log(w))/w);
	  tarolt=r*v2;
	  nincsTarolt=!nincsTarolt;
	  return r*v1;
	 }
	}
	else
	{
	 nincsTarolt=!nincsTarolt;
	return tarolt;
	}
 };

};

int main()
{
std::srand(std::time(0));
PolarGenerator g;
for(int i=0; i<10; ++i)
	std::cout<<g.kovetkezo()<<std::endl;
return 0;
}]]></programlisting>
        <para>
            Tanulságok, tapasztalatok, magyarázat... térj ki arra is, hogy a JDK forrásaiban a Sun programozói
            pont úgy csinálták meg ahogyan te is, azaz az OO nemhogy nem nehéz, hanem éppen természetes neked!
        
        A java forrás szemantikailag megegyezik a JDK forrásokkal.
        </para>  
        <para>A Java kódhoz képes van egy kis változtatás a kódban.
        Már az elején található egy különbség, a <command>public</command> kulcsszó, amely Java-ban minden függvény elé bekerül, amit public-ként szeretnénk kezelni, amíg C++-ban egy egyszerű <command>public:</command> kulcsszó után bármennyi függvényt deklarálhatunk, az minden publikus lesz.</para>
        <para>Egy másik különbség, hogy amíg Java-ban a matematikai műveleteket a <command>Math.művelet</command> előtaggal hívjuk meg, addig C++-ban az összes ilyen művelet függvényként van beépítve egy cmath header fájlba, így csak a függvény neveit kell meghívnunk.
        Viszont hátrányként tekinthető, hogy az <command>#inculde <![CDATA[<cmath>]]></command> sor nélkül egy művelet se használható.(persze az alapműveletek kivételek: +-*/%)</para>              
    </section>        

    <section>
        <title>LZW</title>
        <para>
            Valósítsd meg C-ben az LZW algoritmus fa-építését!
            <command>Tutorált benne: Nagy Laszló Mihály</command>
        </para>
        <para>
            Megoldás videó:
        </para>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása: </para>
            <programlisting language="c"><![CDATA[// z.c
//
// LZW fa építő
// Programozó Páternoszter
//
// Copyright (C) 2011, Bátfai Norbert, nbatfai@inf.unideb.hu, nbatfai@gmail.com
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
// Ez a program szabad szoftver; terjeszthetõ illetve módosítható a
// Free Software Foundation által kiadott GNU General Public License
// dokumentumában leírtak; akár a licenc 3-as, akár (tetszõleges) késõbbi
// változata szerint.
//
// Ez a program abban a reményben kerül közreadásra, hogy hasznos lesz,
// de minden egyéb GARANCIA NÉLKÜL, az ELADHATÓSÁGRA vagy VALAMELY CÉLRA
// VALÓ ALKALMAZHATÓSÁGRA való származtatott garanciát is beleértve.
// További részleteket a GNU General Public License tartalmaz.
//
// A felhasználónak a programmal együtt meg kell kapnia a GNU General
// Public License egy példányát; ha mégsem kapta meg, akkor
// tekintse meg a <http://www.gnu.org/licenses/> oldalon.
//
//
// Version history:
//
// 0.0.1, http://progpater.blog.hu/2011/02/19/gyonyor_a_tomor
// 0.0.2, csomópontok mutatóinak NULLázása (nem fejtette meg senki :)
// 0.0.3, http://progpater.blog.hu/2011/03/05/labormeres_otthon_avagy_hogyan_dolgozok_fel_egy_pedat
//

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <math.h>

typedef struct binfa
{
  int ertek;
  struct binfa *bal_nulla;
  struct binfa *jobb_egy;

} BINFA, *BINFA_PTR;

BINFA_PTR
uj_elem ()
{
  BINFA_PTR p;

  if ((p = (BINFA_PTR) malloc (sizeof (BINFA))) == NULL)
    {
      perror ("memoria");
      exit (EXIT_FAILURE);
    }
  return p;
}

extern void kiir (BINFA_PTR elem);
extern void ratlag (BINFA_PTR elem);
extern void rszoras (BINFA_PTR elem);
extern void szabadit (BINFA_PTR elem);

int
main (int argc, char **argv)
{
  char b;

  BINFA_PTR gyoker = uj_elem ();
  gyoker->ertek = '/';
  gyoker->bal_nulla = gyoker->jobb_egy = NULL;
  BINFA_PTR fa = gyoker;

  while (read (0, (void *) &b, 1))
    {
//      write (1, &b, 1);
      if (b == '0')
	{
	  if (fa->bal_nulla == NULL)
	    {
	      fa->bal_nulla = uj_elem ();
	      fa->bal_nulla->ertek = 0;
	      fa->bal_nulla->bal_nulla = fa->bal_nulla->jobb_egy = NULL;
	      fa = gyoker;
	    }
	  else
	    {
	      fa = fa->bal_nulla;
	    }
	}
      else
	{
	  if (fa->jobb_egy == NULL)
	    {
	      fa->jobb_egy = uj_elem ();
	      fa->jobb_egy->ertek = 1;
	      fa->jobb_egy->bal_nulla = fa->jobb_egy->jobb_egy = NULL;
	      fa = gyoker;
	    }
	  else
	    {
	      fa = fa->jobb_egy;
	    }
	}
    }

  printf ("\n");
  kiir (gyoker);
  
  extern int max_melyseg, atlagosszeg, melyseg, atlagdb;
  extern double szorasosszeg, atlag;
 

  printf ("melyseg=%d\n", max_melyseg-1);

  /* Átlagos ághossz kiszámítása */
  atlagosszeg = 0;
  melyseg = 0;
  atlagdb = 0;
  ratlag (gyoker);
  // atlag = atlagosszeg / atlagdb;
  // (int) / (int) "elromlik", ezért casoljuk
  // K&R tudatlansági védelem miatt a sok () :)
  atlag = ((double)atlagosszeg) / atlagdb;

  /* Ághosszak szórásának kiszámítása */
  atlagosszeg = 0;
  melyseg = 0;
  atlagdb = 0;
  szorasosszeg = 0.0;

  rszoras (gyoker);

  double szoras = 0.0;

  if (atlagdb - 1 > 0)
    szoras = sqrt( szorasosszeg / (atlagdb - 1));
  else
    szoras = sqrt (szorasosszeg);

  printf ("altag=%f\nszoras=%f\n", atlag, szoras);

  szabadit (gyoker);
}


 // a Javacska ONE projekt Hetedik Szem/TudatSzamitas.java mintajara
 // http://sourceforge.net/projects/javacska/ 
 // az atlag() hivasakor is inicializalni kell oket, a
 // a rekurziv bejaras hasznalja
int atlagosszeg = 0, melyseg = 0, atlagdb = 0;

void
ratlag (BINFA_PTR fa)
{

  if (fa != NULL)
    {
      ++melyseg;
      ratlag (fa->jobb_egy);
      ratlag (fa->bal_nulla);
      --melyseg;

      if (fa->jobb_egy == NULL && fa->bal_nulla == NULL)
	{

	  ++atlagdb;
	  atlagosszeg += melyseg;

	}

    }

}

 // a Javacska ONE projekt Hetedik Szem/TudatSzamitas.java mintajara
 // http://sourceforge.net/projects/javacska/ 
 // az atlag() hivasakor is inicializalni kell oket, a
 // a rekurziv bejaras hasznalja
double szorasosszeg = 0.0, atlag = 0.0;

void
rszoras (BINFA_PTR fa)
{

  if (fa != NULL)
    {
      ++melyseg;
      rszoras (fa->jobb_egy);
      rszoras (fa->bal_nulla);
      --melyseg;

      if (fa->jobb_egy == NULL && fa->bal_nulla == NULL)
	{

	  ++atlagdb;
	  szorasosszeg += ((melyseg - atlag) * (melyseg - atlag));

	}

    }

}

//static int melyseg = 0;
int max_melyseg = 0;

void
kiir (BINFA_PTR elem)
{
  if (elem != NULL)
    {
      ++melyseg;
      if (melyseg > max_melyseg)
	max_melyseg = melyseg;
      kiir (elem->jobb_egy);
      // ez a postorder bejáráshoz képest
      // 1-el nagyobb mélység, ezért -1
      for (int i = 0; i < melyseg; ++i)
	printf ("---");
      printf ("%c(%d)\n", elem->ertek < 2 ? '0' + elem->ertek : elem->ertek,
	      melyseg-1);
      kiir (elem->bal_nulla);
      --melyseg;
    }
}

void
szabadit (BINFA_PTR elem)
{
  if (elem != NULL)
    {
      szabadit (elem->jobb_egy);
      szabadit (elem->bal_nulla);
      free (elem);
    }
}
]]></programlisting>

<para/>
<programlisting language="c"><![CDATA[
BINFA_PTR
uj_elem ()
{
  BINFA_PTR p;

  if ((p = (BINFA_PTR) malloc (sizeof (BINFA))) == NULL)
    {
      perror ("memoria");
      exit (EXIT_FAILURE);
    }
  return p;
}]]></programlisting>
<para>Ez a függvény egy p nevű BINFA_PTR típusú változót hoz létre,
ha a memóriafoglalás nem valósul meg, akkor a <command>perror()</command>-ban megadott szöveget adja vissza, majd kilép az EXIT_FAILURE kulcsszóval.
visszatérési értéke ez a p változó lesz.
</para>
<programlisting language="c"><![CDATA[[
extern void kiir (BINFA_PTR elem);
extern void ratlag (BINFA_PTR elem);
extern void rszoras (BINFA_PTR elem);
extern void szabadit (BINFA_PTR elem);]]></programlisting>
<para>ez a négy függvény extern, ami annyit jelent, hogy globálisan használható.
Egyébként visszatérési értéket nem várnak a függvények, argumentumként pedig egy BINFA_PTR típusú adatot várnak.</para>
    <programlisting language="c">
    <![CDATA[int
main (int argc, char **argv)
{
  char b;

  BINFA_PTR gyoker = uj_elem ();
  gyoker->ertek = '/';
  gyoker->bal_nulla = gyoker->jobb_egy = NULL;
  BINFA_PTR fa = gyoker;
]]>
    </programlisting>
    <para>
    A BINFA_PTR gyoker = uj_elem (); sor egy BINFA_PTR típusú változót hoz létre, és értékül az uj_elem függvény visszatérési értékét kapja, ami a p változó volt.
    Ez a gyoker változó rendelkezik <command>ertek</command> alváltozóval, aminek az értékére a '/' jelet állítsuk be. 
    a következő sorban a gyoker változó bal_nulla és jobb_egy értékeit lenullázzuk.
    Majd létrehozunk egy újabb változót, és értékül adjuk neki a gyoker változót.
    </para>
    <programlisting language="c"><![CDATA[
       if (b == '0')
	{
	  if (fa->bal_nulla == NULL)
	    {
	      fa->bal_nulla = uj_elem ();
	      fa->bal_nulla->ertek = 0;
	      fa->bal_nulla->bal_nulla = fa->bal_nulla->jobb_egy = NULL;
	      fa = gyoker;
	    }
	  else
	    {
	      fa = fa->bal_nulla;
	    }
	}]]></programlisting>
    <para>Nézzük a nullás ágat először:
    ha a b változó 0-át tartalmaz ebben a tickben, akkor :
    Ha a fa változó bal_nulla tagja eddig nem tartlamazott értéket, akkor 
    legyen az értéke az uj_elem függvény visszatérési értéke.
    a bal_nulla változó ertek tag értéke pedig legyen "0";
    Ezután a bal_nulla változóra mutató bal_nulla objektum értékét tesszük egyenlővé a jobb_egy változóéval, és azt lenullázzuk.
    Végül a fa objektumot egyenlővé tesszük a gyoker-rel.
    Ha a bal_nulla nem volt üres, akkor a fa változót tovább léptetjük a bal_nulla ágra.
    </para>
    <programlisting language="c"><![CDATA[  else
	{
	  if (fa->jobb_egy == NULL)
	    {
	      fa->jobb_egy = uj_elem ();
	      fa->jobb_egy->ertek = 1;
	      fa->jobb_egy->bal_nulla = fa->jobb_egy->jobb_egy = NULL;
	      fa = gyoker;
	    }
	  else
	    {
	      fa = fa->jobb_egy;
	    }
	}]]></programlisting>
    <para>Végül jöhet az eggyes ág:
    ha a jobb_egy objektum értéke eddig NULL volt, akkor:
    a jobb_egy legyen az uj_elem függvény p értéke.
    a jobb_egy ertek változó értéke legyen "1".
    A jobb_egy-&gt;bal_nulla objektum értékéül válaszzuk a jobb_egy-et, aminek pedig a NULL értéket adjuk.
    végül a fa objektumot egyenlővé tesszük a gyoker-el.
    Ha a jobb_egy nem volt NULL értékű, akkor a fa változót léptessük oda.</para>
    </section>        
        
    <section>
        <title>Fabejárás</title>
        <para>
            Járd be az előző (inorder bejárású) fát pre- és posztorder is!
        </para>
        <para>
            Megoldás videó:
        </para>

        <para>Preorderbejárás: azaz a gyökér elem majd a bal oldali részfa preorder bejárása, végül ajobboldali részfa preorder bejárása.</para>
         <programlisting language="C"><![CDATA[void
kiir (BINFA_PTR elem)
{
    if (elem != NULL)
        {
        ++melyseg;
        for (int i = 0; i < melyseg; ++i)
            printf ("---");
        printf ("%c(%d)\n", elem->ertek < 2 ? '0' + elem->ertek : elem->ertek,
                melyseg);
        if (melyseg > max_melyseg)
            max_melyseg = melyseg;
            
        kiir (elem->jobb_egy);
        kiir (elem->bal_nulla);
        --melyseg;
    }
}
]]></programlisting>
        <para>Inorderbejárás: azaz először a bal részfa inorder bejárása, majd a gyökérelem, végül ajobboldali részfa inorder bejárása.</para>
        <para>Postorderbejárás: azaz először a bal részfa posztorder bejárása, majd a jobboldali részfaposztorder bejárása, végül a gyökérelem feldolgozása.</para>
         <programlisting language="C"><![CDATA[void
kiir (BINFA_PTR elem)
{
    if (elem != NULL)
    {
        ++melyseg;
        
        if (melyseg > max_melyseg)
            max_melyseg = melyseg;
            
        kiir (elem->jobb_egy);
        kiir (elem->bal_nulla);

        for (int i = 0; i < melyseg; ++i)
            printf ("---");
        printf ("%c(%d)\n", elem->ertek < 2 ? '0' + elem->ertek : elem->ertek,
                melyseg);

        --melyseg;
    }
}
]]></programlisting>
    <para><link xlink:href="http://tananyag.ntszki.hu/BajanF/11-B/fabejaras.pdf">forrás</link></para>
    </section>        
                        
    <section>
        <title>Tag a gyökér</title>
        <para>
            Az LZW algoritmust ültesd át egy C++ osztályba, legyen egy Tree és egy beágyazott Node
            osztálya. A gyökér csomópont legyen kompozícióban a fával!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
         Megoldás forrása: <link xlink:href="https://raw.githubusercontent.com/ghjbku/DE/cpp/z3a7(1).cpp">a nagy forráskód miatt csak linkként jelenítem meg</link>                
     </para>
     <programlisting language="c++"><![CDATA[
     protected:			// ha esetleg egyszer majd kiterjesztjük az osztályt, mert
    // akarunk benne valami újdonságot csinálni, vagy meglévő tevékenységet máshogy... stb.
    // akkor ezek látszanak majd a gyerek osztályban is

    /* A fában tagként benne van egy csomópont, ez erősen ki van tüntetve, Ő a gyökér: */
    Csomopont gyoker;
    int maxMelyseg;
    double atlag, szoras;

    void rmelyseg (Csomopont * elem);
    void ratlag (Csomopont * elem);
    void rszoras (Csomopont * elem);

};]]></programlisting>
<para>
Amint láthatjuk, a binfa osztály protected ágában megtalálható a Csomopont típusú gyoker változó.
a fa objektum jelképezi a tree-t, míg a node-t jelképezi a Csomopont.
</para>
    </section>        
                
    <section>
        <title>Mutató a gyökér</title>
        <para>
          <command>Tutorálva Nagy Krisztián által.</command>
            Írd át az előző forrást, hogy a gyökér csomópont ne kompozícióban, csak aggregációban legyen a 
            fával!
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para><command>A forráskód-részlet Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása:  <link xlink:href="z3a7_gyoker.cpp"/>
        </para>
        <programlisting language="c++"><![CDATA[ LZWBinFa ():fa (gyoker = new Csomopont('/'))
    {
    }
    ~LZWBinFa ()
    {
        szabadit (gyoker->egyesGyermek ());
        szabadit (gyoker->nullasGyermek ());
	delete gyoker;
    }]]></programlisting>
    <para>Ehhez szükségünk lesz arra, hogy az előző feladatban megadott <command>Csomopont gyoker;</command>
    sort átírjuk <command>Csomopont gyoker*;</command>-ra</para>
    <para>Viszont mivel mutató lett belőle, valahol inicializálnunk kell a változót.
    Ezt jelenti a(z) <command><![CDATA[LZWBinFa ():fa (gyoker = new Csomopont('/'))]]></command> sor</para>
    <para>Át kell írnunk továbbá a programban található <command>gyoker</command> változó hívásokat <command>gyoker*</command>-ra.</para>
    <para>Viszont ez még mindíg nem elég, hiszen a memóriafoglalást követően valahogy fel is kell őket szabadítani.
  És itt jön be az ~LZWBinFa destruktor.  
  </para>
    </section>                     

    <section>
        <title>Mozgató szemantika</title>
        <para><command>Tutorált Gila Attila Zoltán</command>
            Írj az előző programhoz mozgató konstruktort és értékadást, a mozgató konstruktor legyen a mozgató
            értékadásra alapozva!
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para><command>A forráskód Tamás Racs tulajdonában áll.</command>
            Megoldás forrása:  
            std::move parancs API: <link xlink:href="https://en.cppreference.com/w/cpp/utility/move"/>
        </para>
        <programlisting language="c++"><![CDATA[
#include <iostream>
#include <fstream>
class LZWBinaryTree
{
public:
LZWBinaryTree ()
{
currentNode = root;
}
~LZWBinaryTree ()
{
free (root);
}
LZWBinaryTree (LZWBinaryTree&& other)
{
root = nullptr;
*this = std::move(other);
}
LZWBinaryTree& operator=(LZWBinaryTree&& other)
{
std::swap(root, other.root);
return *this;
}
void operator<< (char b)
{
if (b == ’0’)
{
if (!currentNode->getLeftChild ())
{
Node *uj = new Node (’0’);
currentNode->newLeftChild (uj);
currentNode = root;
}
else
{
currentNode = currentNode->getLeftChild ();
}
}
else
{
if (!currentNode->getRightChild ())
{
Node *uj = new Node (’1’);
currentNode->newRightChild (uj);
currentNode = root;
}
else
{
currentNode = currentNode->getRightChild ();
}
}
}
void print (void)
{
depth = 0;
print (root, std::cout);
}

int getDepth (void);
friend std::ostream & operator<< (std::ostream & os, LZWBinaryTree & bf ←-
)
{
bf.print (os);
return os;
}
void print (std::ostream & os)
{
depth = 0;
print (root, os);
}
private:
class Node
{
public:
Node (char b = ’/’):value (b), leftChild (0), rightChild (0)
{
};
~Node ()
{
};
Node *getLeftChild () const
{
return leftChild;
}
Node *getRightChild () const
{
return rightChild;
}
void newLeftChild (Node * gy)
{
leftChild = gy;
}
void newRightChild (Node * gy)
{
rightChild = gy;
}
char getValue () const
{
return value;
}
private:
char value;
Node *leftChild;
Node *rightChild;
Node (const Node &);
Node & operator= (const Node &);
};
Node *currentNode;
int depth;
LZWBinaryTree (const LZWBinaryTree &);
LZWBinaryTree & operator= (const LZWBinaryTree &);
void print (Node * n, std::ostream & os)
{
if (n != NULL)
{
++depth;
print (n->getLeftChild (), os);
for (int i = 0; i < depth; ++i)
os << "---";
os << n->getValue () << "(" << depth << ")" << std::endl;
print (n->getRightChild (), os);
--depth;
}
}
void free (Node * n)
{
if (n != NULL)
{
free (n->getLeftChild ());
free (n->getRightChild ());
delete n;
}
}
protected:
Node* root = new Node();
int maxDepth;
void getDepthRec (Node * n);
};
int LZWBinaryTree::getDepth (void)
{
depth = maxDepth = 0;
getDepthRec (root);
return maxDepth;
}
void LZWBinaryTree::getDepthRec (Node * n)
{
if (n != NULL)
{
++depth;
if (depth > maxDepth)
maxDepth = depth;
getDepthRec (n->getRightChild ());
getDepthRec (n->getLeftChild ());
--depth;
}
}
void usage (void)
{
std::cout << "Usage: lzwtree in_file" << std::endl;
}
int main (int argc, char *argv[])
{
if (argc != 2)
{
usage ();
return -1;
}
char *inFile = *++argv;
std::fstream beFile (inFile, std::ios_base::in);
if (!beFile)
{
std::cout << inFile << "Nem létezik a bemeneti fájl!" << std::endl;
usage ();
return -3;
}
char b;
LZWBinaryTree binFa;
while (beFile.read ((char *) &b, sizeof (char)))
{
if(b == ’0’)
{
binFa << b;
}
else if(b == ’1’)
{
binFa << b;
}
}
std::cout << "Eredeti fa:\n\n";
std::cout << binFa;
std::cout << "depth = " << binFa.getDepth () << std::endl;
LZWBinaryTree binFa2 = std::move(binFa);
std::cout << "\nEredeti fa mozgatás után:\n";
std::cout << binFa;
std::cout << "depth = " << binFa.getDepth () << std::endl;
std::cout << "\nMozgatással létrejött fa:\n\n";
std::cout << binFa2;
std::cout << "depth = " << binFa2.getDepth () << std::endl;
beFile.close ();
return 0;
}
]]>
</programlisting>
<para>A lent található két függvény teszi lehetővé az objektumok mozgatását.</para>
<para>Amint láthatjuk, az első sorban a jelenlegi root-ot lecseréli a program nullptr-re, majd 
a *this, tehát ezen tree értékét egyenlővé teszi az std::move(other) funkció visszatérési értékével.
Maga a move függvény nem tesz semmit az objektumunkkal, egyszerűen csak a baloldali értékből
jobboldali értéket készít.</para>
 <programlisting language="c++"><![CDATA[
LZWBinaryTree (LZWBinaryTree&& other)
{
root = nullptr;
*this = std::move(other);
}]]></programlisting>
<para>Majd az std::swap függvény segítségével kicseréljük a két objektum memóriacímét,
végül visszatérési értékként a *this pointert adjuk meg. </para>
 <programlisting language="c++">
 <![CDATA[
LZWBinaryTree& operator=(LZWBinaryTree&& other)
{
std::swap(root, other.root);
return *this;
}]]>
 </programlisting>

    </section>                     
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Conway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Hangyaszimulációk</title>
        <para>
            Írj Qt C++-ban egy hangyaszimulációs programot, a forrásaidról utólag reverse engineering jelleggel
            készíts UML osztálydiagramot is!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/10/10/myrmecologist">https://bhaxor.blog.hu/2018/10/10/myrmecologist</link>
        </para>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása: <link xlink:href=""/>               
        </para>
         <figure>
            <title>A hangyaszimuláció UML diagram</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="hangya/changya8.png" scale="50"/>
                </imageobject>
                <textobject>
                    <phrase>A hangyák akcióban</phrase>
                </textobject>
            </mediaobject>
        </figure>  
         <figure>
            <title>A hangyák akcióban</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="hangya/hangya.png" scale="30"/>
                </imageobject>
                <textobject>
                    <phrase>A hangyák akcióban</phrase>
                </textobject>
            </mediaobject>
        </figure>  
        <programlisting language="c++"><![CDATA[// BHAX Myrmecologist
//
// Copyright (C) 2019
// Norbert Bátfai, batfai.norbert@inf.unideb.hu
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.
//
// https://bhaxor.blog.hu/2018/09/26/hangyaszimulaciok
// https://bhaxor.blog.hu/2018/10/10/myrmecologist
// 

#include <QApplication>
#include <QDesktopWidget>
#include <QDebug>
#include <QDateTime>
#include <QCommandLineOption>
#include <QCommandLineParser>

#include "antwin.h"

/*
 * 
 * ./myrmecologist -w 250 -m 150 -n 400 -t 10 -p 5 -f 80 -d 0 -a 255 -i 3 -s 3  -c 22
 *
 */

int main ( int argc, char *argv[] )
{

    QApplication a ( argc, argv );

    QCommandLineOption szeles_opt ( {"w","szelesseg"}, "Oszlopok (cellakban) szama.", "szelesseg", "200" );
    QCommandLineOption magas_opt ( {"m","magassag"}, "Sorok (cellakban) szama.", "magassag", "150" );
    QCommandLineOption hangyaszam_opt ( {"n","hangyaszam"}, "Hangyak szama.", "hangyaszam", "100" );
    QCommandLineOption sebesseg_opt ( {"t","sebesseg"}, "2 lepes kozotti ido (millisec-ben).", "sebesseg", "100" );
    QCommandLineOption parolgas_opt ( {"p","parolgas"}, "A parolgas erteke.", "parolgas", "8" );
    QCommandLineOption feromon_opt ( {"f","feromon"}, "A hagyott nyom erteke.", "feromon", "11" );
    QCommandLineOption szomszed_opt ( {"s","szomszed"}, "A hagyott nyom erteke a szomszedokban.", "szomszed", "3" );
    QCommandLineOption alapertek_opt ( {"d","alapertek"}, "Indulo ertek a cellakban.", "alapertek", "1" );
    QCommandLineOption maxcella_opt ( {"a","maxcella"}, "Cella max erteke.", "maxcella", "50" );
    QCommandLineOption mincella_opt ( {"i","mincella"}, "Cella min erteke.", "mincella", "2" );
    QCommandLineOption cellamerete_opt ( {"c","cellameret"}, "Hany hangya fer egy cellaba.", "cellameret", "4" );
    QCommandLineParser parser;

    parser.addHelpOption();
    parser.addVersionOption();
    parser.addOption ( szeles_opt );
    parser.addOption ( magas_opt );
    parser.addOption ( hangyaszam_opt );
    parser.addOption ( sebesseg_opt );
    parser.addOption ( parolgas_opt );
    parser.addOption ( feromon_opt );
    parser.addOption ( szomszed_opt );
    parser.addOption ( alapertek_opt );
    parser.addOption ( maxcella_opt );
    parser.addOption ( mincella_opt );
    parser.addOption ( cellamerete_opt );

    parser.process ( a );

    QString szeles = parser.value ( szeles_opt );
    QString magas = parser.value ( magas_opt );
    QString n = parser.value ( hangyaszam_opt );
    QString t = parser.value ( sebesseg_opt );
    QString parolgas = parser.value ( parolgas_opt );
    QString feromon = parser.value ( feromon_opt );
    QString szomszed = parser.value ( szomszed_opt );
    QString alapertek = parser.value ( alapertek_opt );
    QString maxcella = parser.value ( maxcella_opt );
    QString mincella = parser.value ( mincella_opt );
    QString cellameret = parser.value ( cellamerete_opt );

    qsrand ( QDateTime::currentMSecsSinceEpoch() );

    AntWin w ( szeles.toInt(), magas.toInt(), t.toInt(), n.toInt(), feromon.toInt(), szomszed.toInt(), parolgas.toInt(),
                  alapertek.toInt(), mincella.toInt(), maxcella.toInt(),
                  cellameret.toInt() );

    w.show();

    return a.exec();
}]]></programlisting>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
            A hangyaszimuláció célja a hangyák viselkedésének rekonstruálása.
            A hangyák a szaglásuk segítségével tájékozódnak, mindíg a legerősebb szagot követik és ha szagot fognak, ők maguk is elkezdenek szagot kibocsátani, így a többi hangya is arra az útra jön.
            A szimulációhoz szükségünk van a QT5-ös verziójára.
        </para> 
        <para>
        Ez a forráskód a grafikus megjelenítési beállításokat és a hangyák tulajdonságait tartalmazza:
        A <command>QCommandLineOption szeles_opt</command> rész az ablak szélességét,
        A <command>QCommandLineOption magas_opt</command> pedig a magasságát.
          A <command>QCommandLineOption hangyaszam_opt</command>, <command>QCommandLineOption sebesseg_opt</command>,
          <command>QCommandLineOption parolgas_opt</command>, <command>QCommandLineOption feromon_opt</command> és
           <command>QCommandLineOption szomszed_opt</command>
          sorok a hangyák tulajdonságait szabályozzák.
        A <command>parser</command> parancs adja hozzá az ablakot a kerethez.     
        A <command>w.show();</command> parancs jeleníti meg az ablakot, és a végén a program visszatér az <command>a.exec()</command> objektummal.
        </para>           
    </section>        
    <section>
        <title>Java életjáték</title>
        <para>
        
            Írd meg Java-ban a John Horton Conway-féle életjátékot, 
            valósítsa meg a sikló-kilövőt!
        <command>Tutoráltam Nagy Krisztiánt </command>
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása: <link xlink:href="https://github.com/ghjbku/DE/blob/master/sajat/eletjatek/Sejtautomata.java"/>               
        </para>
        <para>
        </para>
        <programlisting language="java">
        <![CDATA[public class Sejtautomata extends java.awt.Frame implements Runnable {
    public static final boolean ÉLŐ = true;
    public static final boolean HALOTT = false;
    protected boolean [][][] rácsok = new boolean [2][][];
    protected boolean [][] rács;
    protected int rácsIndex = 0;
    protected int cellaSzélesség = 20;
    protected int cellaMagasság = 20;
    protected int szélesség = 20;
    protected int magasság = 10;
    protected int várakozás = 1000;
    private java.awt.Robot robot;
    private boolean pillanatfelvétel = false;
    private static int pillanatfelvételSzámláló = 0;

    public Sejtautomata(int szélesség, int magasság) {
        this.szélesség = szélesség;
        this.magasság = magasság;
        rácsok[0] = new boolean[magasság][szélesség];
        rácsok[1] = new boolean[magasság][szélesség];
        rácsIndex = 0;
        rács = rácsok[rácsIndex];
        for(int i=0; i<rács.length; ++i)
            for(int j=0; j<rács[0].length; ++j)
                rács[i][j] = HALOTT;
        siklóKilövő(rács, 5, 60);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent e) {
                setVisible(false);
                System.exit(0);
            }
        });
addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent e) {
                if(e.getKeyCode() == java.awt.event.KeyEvent.VK_K) {
                    cellaSzélesség /= 2;
                    cellaMagasság /= 2;
                    setSize(Sejtautomata.this.szélesség*cellaSzélesség,
                            Sejtautomata.this.magasság*cellaMagasság);
                    validate();
                } else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_N) {
                    cellaSzélesség *= 2;
                    cellaMagasság *= 2;
                    setSize(Sejtautomata.this.szélesség*cellaSzélesség,
                            Sejtautomata.this.magasság*cellaMagasság);
                    validate();
                } else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_S)
                    pillanatfelvétel = !pillanatfelvétel;
                else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_G)
                    várakozás /= 2;
                else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_L)
                    várakozás *= 2;
                repaint();
            }
        });

        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent m) {
                int x = m.getX()/cellaSzélesség;
                int y = m.getY()/cellaMagasság;
                rácsok[rácsIndex][y][x] = !rácsok[rácsIndex][y][x];
                repaint();
            }
        });

        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent m) {
                int x = m.getX()/cellaSzélesség;
                int y = m.getY()/cellaMagasság;
                rácsok[rácsIndex][y][x] = ÉLŐ;
                repaint();
            }
        });
 cellaSzélesség = 10;
        cellaMagasság = 10;
        try {
            robot = new java.awt.Robot(
                    java.awt.GraphicsEnvironment.
                    getLocalGraphicsEnvironment().
                    getDefaultScreenDevice());
        } catch(java.awt.AWTException e) {
            e.printStackTrace();
        }

        setTitle("Sejtautomata");
        setResizable(false);
        setSize(szélesség*cellaSzélesség,
                magasság*cellaMagasság);
        setVisible(true);
        new Thread(this).start();
 }


public void paint(java.awt.Graphics g) {
        boolean [][] rács = rácsok[rácsIndex];
        for(int i=0; i<rács.length; ++i) {
            for(int j=0; j<rács[0].length; ++j) {
                if(rács[i][j] == ÉLŐ)
                    g.setColor(java.awt.Color.BLACK);
                else
                    g.setColor(java.awt.Color.WHITE);
                g.fillRect(j*cellaSzélesség, i*cellaMagasság,
                        cellaSzélesség, cellaMagasság);
                g.setColor(java.awt.Color.LIGHT_GRAY);
                g.drawRect(j*cellaSzélesség, i*cellaMagasság,
                        cellaSzélesség, cellaMagasság);
            }
        }

        if(pillanatfelvétel) {
            pillanatfelvétel = false;
            pillanatfelvétel(robot.createScreenCapture
                    (new java.awt.Rectangle
                    (getLocation().x, getLocation().y,
                    szélesség*cellaSzélesség,
                    magasság*cellaMagasság)));
        }
    }

    public int szomszédokSzáma(boolean [][] rács,
            int sor, int oszlop, boolean állapot) {        
        int állapotúSzomszéd = 0;
        for(int i=-1; i<2; ++i)
            for(int j=-1; j<2; ++j)
                if(!((i==0) && (j==0))) {
            int o = oszlop + j;
            if(o < 0)
                o = szélesség-1;
            else if(o >= szélesség)
                o = 0;
            
            int s = sor + i;
            if(s < 0)
                s = magasság-1;
            else if(s >= magasság)
                s = 0;
            
            if(rács[s][o] == állapot)
                ++állapotúSzomszéd;
                }
        
        return állapotúSzomszéd;
    }
public void időFejlődés() {
        
        boolean [][] rácsElőtte = rácsok[rácsIndex];
        boolean [][] rácsUtána = rácsok[(rácsIndex+1)%2];
        
        for(int i=0; i<rácsElőtte.length; ++i) {
            for(int j=0; j<rácsElőtte[0].length; ++j) {
                
                int élők = szomszédokSzáma(rácsElőtte, i, j, ÉLŐ);
                
                if(rácsElőtte[i][j] == ÉLŐ) {

                    if(élők==2 || élők==3)
                        rácsUtána[i][j] = ÉLŐ;
                    else
                        rácsUtána[i][j] = HALOTT;
                }  else {

                    if(élők==3)
                        rácsUtána[i][j] = ÉLŐ;
                    else
                        rácsUtána[i][j] = HALOTT;
                }
            }
        }
        rácsIndex = (rácsIndex+1)%2;
    }

    public void run() {
        
        while(true) {
            try {
                Thread.sleep(várakozás);
            } catch (InterruptedException e) {}
            
            időFejlődés();
            repaint();
        }
    }

    public void sikló(boolean [][] rács, int x, int y) {
        
        rács[y+ 0][x+ 2] = ÉLŐ;
        rács[y+ 1][x+ 1] = ÉLŐ;
        rács[y+ 2][x+ 1] = ÉLŐ;
        rács[y+ 2][x+ 2] = ÉLŐ;
        rács[y+ 2][x+ 3] = ÉLŐ;
        
    }
public void siklóKilövő(boolean [][] rács, int x, int y) {
        
        rács[y+ 6][x+ 0] = ÉLŐ;
        rács[y+ 6][x+ 1] = ÉLŐ;
        rács[y+ 7][x+ 0] = ÉLŐ;
        rács[y+ 7][x+ 1] = ÉLŐ;
        
        rács[y+ 3][x+ 13] = ÉLŐ;
        
        rács[y+ 4][x+ 12] = ÉLŐ;
        rács[y+ 4][x+ 14] = ÉLŐ;
        
        rács[y+ 5][x+ 11] = ÉLŐ;
        rács[y+ 5][x+ 15] = ÉLŐ;
        rács[y+ 5][x+ 16] = ÉLŐ;
        rács[y+ 5][x+ 25] = ÉLŐ;
        
        rács[y+ 6][x+ 11] = ÉLŐ;
        rács[y+ 6][x+ 15] = ÉLŐ;
        rács[y+ 6][x+ 16] = ÉLŐ;
        rács[y+ 6][x+ 22] = ÉLŐ;
        rács[y+ 6][x+ 23] = ÉLŐ;
        rács[y+ 6][x+ 24] = ÉLŐ;
        rács[y+ 6][x+ 25] = ÉLŐ;
        
        rács[y+ 7][x+ 11] = ÉLŐ;
        rács[y+ 7][x+ 15] = ÉLŐ;
        rács[y+ 7][x+ 16] = ÉLŐ;
        rács[y+ 7][x+ 21] = ÉLŐ;
        rács[y+ 7][x+ 22] = ÉLŐ;
        rács[y+ 7][x+ 23] = ÉLŐ;
        rács[y+ 7][x+ 24] = ÉLŐ;
        
        rács[y+ 8][x+ 12] = ÉLŐ;
        rács[y+ 8][x+ 14] = ÉLŐ;
        rács[y+ 8][x+ 21] = ÉLŐ;
        rács[y+ 8][x+ 24] = ÉLŐ;
        rács[y+ 8][x+ 34] = ÉLŐ;
        rács[y+ 8][x+ 35] = ÉLŐ;
        
        rács[y+ 9][x+ 13] = ÉLŐ;
        rács[y+ 9][x+ 21] = ÉLŐ;
        rács[y+ 9][x+ 22] = ÉLŐ;
        rács[y+ 9][x+ 23] = ÉLŐ;
        rács[y+ 9][x+ 24] = ÉLŐ;
        rács[y+ 9][x+ 34] = ÉLŐ;
        rács[y+ 9][x+ 35] = ÉLŐ;
        
        rács[y+ 10][x+ 22] = ÉLŐ;
        rács[y+ 10][x+ 23] = ÉLŐ;
        rács[y+ 10][x+ 24] = ÉLŐ;
        rács[y+ 10][x+ 25] = ÉLŐ;
        
        rács[y+ 11][x+ 25] = ÉLŐ;
        
    }

    public void pillanatfelvétel(java.awt.image.BufferedImage felvetel) {
        StringBuffer sb = new StringBuffer();
        sb = sb.delete(0, sb.length());
        sb.append("sejtautomata");
        sb.append(++pillanatfelvételSzámláló);
        sb.append(".png");
        try {
            javax.imageio.ImageIO.write(felvetel, "png",
                    new java.io.File(sb.toString()));
        } catch(java.io.IOException e) {
            e.printStackTrace();
        }
    }
  
    public void update(java.awt.Graphics g) {
        paint(g);
    }    
  
    public static void main(String[] args) {
        new Sejtautomata(100, 75);
    }
}



]]>
        </programlisting>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
            A Java verzió ugyanazt tudja, mint a C++ verzió, persze a programnyelv miatt vannak különbségek a forrsákódban.
            A Java kompatibilitása miatt viszont szinte bárhol lefuttatható a program, ahol jvm található.
            A programban megtalálható pár billentyű funkció is, melyekkel a program működését befolyásolhatjuk.
            Az <command>s</command> betű megállítja a programot, a <command>k</command> az ablakot kicsinyíti, míg az <command>n</command> nagyítja.
            van még a <command>g és az l</command>, ezek gyorsítják és lassítják a programot.
        </para>            
    </section>        
    <section>
        <title>Qt C++ életjáték</title>
        <para>
            Most Qt C++-ban!
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása: <link xlink:href="eletjatek/main.cpp"/>               
        </para>
        <figure>
            <title>Az életjáték futás közben</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="eletjatek/elet1.png" scale="50"/>
                </imageobject>
                <textobject>
                    <phrase>A hangyák akcióban</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <programlisting language="c++"><![CDATA[//main.cpp tartalma
#include <QApplication>
#include "sejtablak.h"
#include <QDesktopWidget>

int main(int argc, char *argv[])
{
  QApplication a(argc, argv);
  SejtAblak w(100, 75);
  w.show();
  
  return a.exec();
}
]]></programlisting>
<para>
A main fájl rövid, hiszen csak annyi a dolga, hogy meghívja magát a program-ablakot, melyet meg is tesz ebben a sorban:
<command>SejtAblak w(100,75);</command> itt a sejtablak osztályt felhasználva készítünk egy w objektumot, melyeknek a 100 szélesség és 75
magasság paramétereket adjuk meg.
Majd a következő sorban a w.show(); függvényhívással megjelenítjük azt ablakot.
</para>
<programlisting language="c++"><![CDATA[//sejtablak.h tartalma
#ifndef SEJTABLAK_H
#define SEJTABLAK_H

#include <QMainWindow>
#include <QPainter>
#include "sejtszal.h"

class SejtSzal;

class SejtAblak : public QMainWindow
{
  Q_OBJECT
  
public:
  SejtAblak(int szelesseg = 100, int magassag = 75, QWidget *parent = 0);

  ~SejtAblak();
  // Egy sejt lehet élő
  static const bool ELO = true;
  // vagy halott
  static const bool HALOTT = false;
  void vissza(int racsIndex);
  
protected:
  // Két rácsot használunk majd, az egyik a sejttár állapotút
  // a t_n, a másik a t_n+1 időpillanatban jellemzi.
  bool ***racsok;
  // Valamelyik rácsra mutat, technikai jellegű, hogy ne kelljen a
  // [2][][]-ból az első dimenziót használni, mert vagy az egyikre
  // állítjuk, vagy a másikra.
  bool **racs;
  // Megmutatja melyik rács az aktuális: [rácsIndex][][]
  int racsIndex;
  // Pixelben egy cella adatai.
  int cellaSzelesseg;
  int cellaMagassag;
  
  int szelesseg;
  int magassag;    
  void paintEvent(QPaintEvent*);
  void siklo(bool **racs, int x, int y);
  void sikloKilovo(bool **racs, int x, int y);
  
private:
  SejtSzal* eletjatek;
  
};

#endif // SEJTABLAK_H
]]></programlisting>
 <para>Ha betekintünk a SejtAblak.h fájlba, láthatjuk magát az osztályt, amit a main.cpp-ben felhasználtunk.
 Az osztály public ágában találhatunk egy konstruktort, egy destruktort, és két bool típusú változót, 
 amely a sejtek állapotát szimbolizálja, halott, vagy él.
 A protected ágban megjelenik a ***racsok és a **racs pointer objektumok.
 Itt inicializáljuk a paintEvent funkciót és a két fő objektumunkat is, a siklót és a siklókilövőt.
 Ez utóbbi kettő a **racs pointert használja argumentumként, míg a paintEvent a QT-be integrált QPaintEvent osztályban található tagot használja.
 A fájl elején láthatunk még egy header fájlt, a sejtszal.h-t.

 </para>
 <programlisting language="c++"><![CDATA[//sejtszal.h tartalma
 #ifndef SEJTSZAL_H
#define SEJTSZAL_H

#include <QThread>
#include "sejtablak.h"

class SejtAblak;

class SejtSzal : public QThread
{
    Q_OBJECT

public:
    SejtSzal(bool ***racsok, int szelesseg, int magassag,
             int varakozas, SejtAblak *sejtAblak);
    ~SejtSzal();
    void run();

protected:
    bool ***racsok;
    int szelesseg, magassag;
    // Megmutatja melyik rács az aktuális: [rácsIndex][][]
    int racsIndex;
    // A sejttár két egymást követő t_n és t_n+1 diszkrét időpillanata
    // közötti valós idő.
    int varakozas;
    void idoFejlodes();
    int szomszedokSzama(bool **racs,
                        int sor, int oszlop, bool allapot);
    SejtAblak* sejtAblak;

};

#endif // SEJTSZAL_H
]]></programlisting>
<para>
a SejtSzal egy paraméterezett default konstruktor, mely bekéri a  racsok pointer-t, a szélességet, a magasságot,
a várakozást és egy sejtAblak típusú sejtablak pointert.
Alatta megtalálható a default destruktor az osztályhoz.
A protected ágban is láthatjuk a racsok pointert, a szelesseg és magassag változókat inicializálódni.
Itt deklaráljuk a várakozást, az idoFejlodes funkciót és a szomszedokSzama funkciót, legvégül pedig 
a sejtAblak* sejtAblak objektum is itt jelenik meg.
</para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
            A program forráskódja több fájlra esik szét, melyet <command>make</command> parancssal tudunk egy futtatható fájl-á konvertálni.
             Ez az életjáték a siklóKilövő szimulációt valósítja meg.

        </para>            
    </section>        
    <section>
        <title>BrainB Benchmark</title>
        <para>
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href="/esport-talent-search/"/>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     

<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Gutenberg!</title>
        <keywordset>
            <keyword/>
        </keywordset>
        <cover>
            <para>
                Programozás tankönyvek rövid olvasónaplói.
            </para>
        </cover>
    </info>
    <section>
        <title>Programozási alapfogalmak</title>
        <para>         
            <citation>PICI</citation>       
        </para>
        <para>Egy számítógép programozására három nyelvi szintet különböztetünk meg:</para>
<para>-Gépi kód</para>
<para>-assembly szint</para>
<para>-Magas szint</para>
<para>A magas szintű nyelveken megírt algoritmusokat forráskódoknak nevezzük.
A forráskódok nyelvtani szabályi a szintaktikai szabályok, míg a jelentésbeli, tartalmi szabályzat a szemantika.
Ezeket a kódokat interpreterrel, vagy fordítóprogrammal gépi kóddá kell konvertálni, hogy a processor értelmezni tudja.
Egy fordítóprogram tetszőleges nyelvről tetszőleges nyelvre fordít.Amíg ez az egész kódból egy tárgyprogramot készít, addig az interpreter értelezi és rögtön lefuttatja a kódot, programfájl nélkül.
</para>
<para>
<command>Kifejezések:</command>
Két részből állnak, értékből és típusból.
Egy kifejezés ezekből az összetevőkből áll:</para>
<programlisting language="c">
<![CDATA[-operandus: ez egy literál, változó vagy konstans, ez a kifejezés "értéke".
-operátor: ezek a műveleti jelek, aritmetikai/logikai műveletek végrehajtására.
-kerek zárójelek: a műveleti sorrend befolyásolására.]]>
</programlisting>
<para>
Léteznek konstans kifejezések, ezek értéke fordításkor eldől, a program futása közben nem változik.
</para>
<para>
<command>Utasítások:</command></para><programlisting>
értékadó utasítás: Ezen típusú utasítás a változók értékét módosítja a program futása során.
Üres utasítás: ilyenkor a processor egy üres gépi utasítást hajt végre.
Ugró utasítás: A program egyik soráról a másikra ugrik a vezérlés, általános alak a <command>GOTO</command>.
Elágazásos utasítás(kétfelé ágazás utasítás): A program egy pontján két lehetőség közül választ a program egy feltétel alapján.
Formája: if...then...else...
Többirányú elágazás:A program egy pontján meghatározott számú opciókból kiválaszt egyet, amelyet végrehajt.
A választást egy kifejezés értéke szerint határozzuk meg.
Formája: switch(kifejezés){
case egész_kifejezés: [tevékenység]
case egész_kifejezés: [tevékenység]
default: tevékenység };
A case-ágak értékei különbözzenek.
Ha a case-ágak közül egyik sem egyezik a feltétellel, akkor a default tevékenység hajtódik végre.
</programlisting>
<para>
<command>Blokk:</command>
Egy programegység egy másik program belsejében.Eljárásorientált nyelvekben csak a <command>hatáskör</command>ben van szerepe.
Kétféle hatáskörkezelés létezik, statikus és dinamikus.
Előbbi a fordítási időben valósul meg, a fordítóprogram által.
A hatáskör csak befelé terjed, kintről nem látni, ha a változót látjuk kintről, akkor az globális változó.
A dinamikus hatáskörkezelés futási idő közben zajlik le, azt a rendszer végzi.
Ha szabad nevet talál, a hívási láncon keresztül lépked felfelé, amíg a nevet meg nem találja.
Az Eljárásorientált nyelvek a statikus kezelést használják.

</para>
<para>
<command>I/O</command>:
A programnyelvek azon eszközrendszere, amely a perifériákkal való kommunikációt hajtja végre, az operatív tárból küld, vagy vár adatokat.
Az I/O középpontja az állomány.
Ez lehet logikai és fizikai.
Az előbbi egy olyan programozási eszköz, amely névvel rendelkezik, és állományjellemzői attribútumként vannak jelen.
Fizikai állománynak pedig a hétköznapi, perifériákon megjelenő, adatokat tároló vagy tartalmazó állományt nevezzük.
</para>

    </section>        
    <section>
        <title>Programozás bevezetés</title>
        <para>                
            <citation>KERNIGHANRITCHIE</citation>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/zmfT9miB-jY">https://youtu.be/zmfT9miB-jY</link>
        </para>
        <para>
            A C nyelvben kevés adattípust találhatunk<command>(char, int, float, double)</command>,
             de hozzájuk egyfajta minősítők is tartozhatnak:(short(16 bit), long(32 bit) int).
            ezek Különböző hosszúságú egészeket írnak le.
            Az ún. "bűvös számok" elkerülésére használhatjuk a #define parancsot, amellyel Szimbolikus állandókat hozhatunk létre.
            Használata: #define név behelyettesítendő-szöveg-vagy-szám
       </para>
       <para>
       <command>változóérvényességi tartomány:</command>
       A változók deklarálása általában lokális módon történik,ezek a függvényen kívül nem látszanak, a másik függvény/osztály nem fér hozzájuk.
       Ha azt szeretnénk, hogy a változónk látható legyen a függvényen kívül is, szükségünk lesz a változó elé beírni egy <command>extern</command>
       szót, ezzel globális változóvá téve az eredetileg lokális változót.
       </para>
       <para>
       <command>Változók deklarálása:</command>
       A változók deklarálása 3 féle képpen történhet, lista szerint,szétválasztva, vagy értékadással.
       </para>
       <para>Lista például:<![CDATA[char c,t[5];
       int i,g,k;]]> 
       </para>
        <para>
        szétválasztva: char c; char t[5];int i; int g; int k;
        </para>
        <para>értékadással: char c = 'a'; int i=0;</para>
        <para>Minden változó elé kitehetünk egy const minsősítőt, ha azt szeretnénk, hogy 
        a változó értékét ne lehessen megváltoztatni.</para>
        <para>
        <command>Típuskonverzió:</command>
        atoi függvény, a char típusú változók értékét integerré konvertálja.
        ASCII karakterkészlet esetén használható a lower() függvény, ami a nagybetűket kisbetűkké alakítja.
        </para><para><command>Bitenkénti operátorok:</command>
        A C nyelvben 6 olyan operátor található, amelyet bitenkénti műveletekre használhatunk.
        Ezek az operátorok csak char,short,int,long, és ezek előjeles/előjel nélküli formájára használhatóak.

        </para>
        <programlisting language="c"><![CDATA[&     bitenkénti ÉS-kapcsolat
|     bitenkénti megengedő (inkluzív) VAGY-kapcsolat
^     bitenkénti kizáró (exkluzív) VAGY-kapcsolat
<<    balra léptetés
>>    jobbra léptetés
~     egyes komplemens képzés (unáris)]]></programlisting>
        <para><command>Regiszter változó:</command>
        Ezen fajta deklaráció a fordítóprogrammal közli, hogy az adott változóra gyakran lesz szükségünk, ezért
        regiszterbe helyeztessük, ezzel meggyorsítva a működést, és kissebb méretet kapunk.
        A fordítóprogram nem köteles ezt a kérést teljesíteni, figyelmen kívül is hagyhatja.
        deklarációs forma: register int c; register char g;
        </para>
        <para>
        <command>Rekurzivitás:</command>
        A függvények rekurzívan hívhatják önmagukat, ilyenkor az automatikus változók értékei újramásolódnak az új híváshoz.
        Ezek az értékek egymástól függetlenül léteznek, nincs hatásuk egymásra.

        </para>
        <para>
        <command>Makrók: </command>A #define paranccsal nem csak Szimbolikus állandók hozhatók létre.
        Segítségükkel makrókat is inicializálhatunk, tehát akár egy egész függvényt is egy szóval behelyettesíthetünk.
        Amikor ez a szó idézőjel nélkül, egymagában megjelenik a kódban, akkor a helyettesítési értéke illesztődik be a kódba.

        </para>
        <para>
        <command>Pointerek:</command>
        Ezek olyan változók, amelyek más változók memóriacímét tárolják.
        C-ben gyakran használják a mutatókat, mivel hatékonyság és tömörség növelő hatása van.
        Ha van két változónk, <![CDATA[char c és char* p, és p = &c; a &-jel (egyoperandusú operátor) hozzárendeli a p-hez a c címét.
        Ezt úgy szoktuk mondani, hogy a p c-re mutat.]]> Ez az operátor csak változókra és tömbelemekre használható. 
        
        </para>
        <para>
        <command>Parancssori argumentumok:</command> 
        Lehetőségünk van argumentumok átadására a programunknak a terminálról, ezek az argumentumok 
        a main() függvény *argc* és *argv[]* tagjai.
        az argc egy számot tartalmaz, ez a szám az argumentumok száma.
        Az argv[] tömb pedig az összes argumentumot tartalmazza, argv[0] a program neve.

        </para>
    </section>        
    <section>
        <title>Programozás</title>
        <para>                
            <citation>BMECPP</citation>
            A C++ nyelv a C nyelv továbbfejlesztése, annak kényelmesebb használatára hivatott.
        Alapértelmezett függvényargumentumok és függvénynevek túlterhelése segíti a programozók dolgát.

        </para>
        <para>
        C-ben egy üres paraméterlistával rendelkező függvénynek bármennyi paramétere lehet, ez C++-ban viszont egy paraméter nélküli függvény.
        Amíg C-ben megadhatunk típus nélküli függvényeket, (melyek <command>int</command> típusúak lesznek)
        addig C++-ban nincs Alapértelmezett típus, tehát ez hibát eredményez.
        </para>
        <para>
        C++-ban a <command>main()</command> függvény Alapértelmezetten renelkezik két paraméterrel, az argc és argv[] paraméterekkel, előbbi az argumentumok számát, utóbbi az argumentumokat tárolja.
        C++-ban megjelenik a bool típus, amely logikai értékeket vehet fel.
        Előnye az olvashatóság,valamint operátor túlterhelhetőség.
        </para>
        <para>
        C-ben a több-bájtos stringek eléréséhez meg kellett hívni a fejlécben az <![CDATA[<stddef.h>,<stdlib.h> vagy <wchar.h> fájlokat]]>.
        Ez C++-ban már beépített típus lett, így meghívását egyszerűen megtehetjük: <command>wchar_t text=L"sss";</command>
        </para>
        <para>
        <command>objektumok és osztályok</command>
        </para>
        <para>
        Az objektumorientáltság az 1960-as években kezdődött, és 1990-től terjedt el nagy mértékben.
        Egy egységbe záró adattstruktúra neve az osztály.
        Ezen osztálynak az egyedpéldányai az objektumok.
        Ha azt szeretnénk, hogy a programban más férhessen hozzá egy bizonyos objektumhoz, akkor azt a valahogy meg kell oldanunk.
        Ez a védelmi mechanizmus lesz az "adatrejtés".
        Ezt megtehetjük azzal, hogy az objektum elé egy "private:" kulccsszót írunk.
        Így csak az osztályon belüli tagok férhetnek hozzá az adathoz.
        A dinamikus memóriakezelést C-ben a <command>malloc és free </command> függvénypárossal végeztük.
        A paraméterek átadása miatt C++-ban már nem is függvény felelős a memóriakazelésért, hanem operátor.
        Ez az operátor a <command>new</command>
        </para>
        <programlisting language="c++">
        <![CDATA[int* p;
        p=new int;
        *p=10;
        delete p;//a változó használata után felszabadítjuk a helyét a memóriában
        ]]>
        </programlisting>
        <para>Ha szeretnénk, hogy a private:-ban található objektumainkat az osztályon kívül is el tudjuk érni, szükségünk lesz
        egy <command>Friend</command> függvény vagy osztály megadására az osztályunkban.
         </para><para><command>Konstansok és inline függvények</command></para>
         <para>A konstansokat a "közönséges" változókhoz hasonlóan használhatjuk, viszont ezek értékei nem változhatnak a program futása során.
         Bármiféle változtatás az értékével programhibához vezet. </para>
        <para>Léteznek konstans pointerek is, ezeket kétfélé módon adhatjuk meg, ha a típus elé írjuk, akkor a mutatott érték válik megváltoztathatatlanná.
        </para>
        <para><link xlink:href="elmelet/testprog.c++"/></para>
        <programlisting language="c++"><![CDATA[
        char tomb[5];
        const char* pointer=tomb;
        *pointer="g";//ez fordítási hibához vezet, hiszen ez a mutatott érték
        pointer++; //hiba nélkül lefut]]></programlisting>
        <para>A másik változat, amikor a const-ot a pointer neve elé írjuk, ekkor a mutató lesz megváltoztathatatlan.
        </para>
        <programlisting language="c++"><![CDATA[
        char tomb[5];
        char* const pointer =tomb;
        *pointer="g";//lefut
        pointer++;//fordítási hibát jelez]]></programlisting>
        <para>Ezek kombinálása is lehetséges.</para>
        <para><command>Inline függvények</command></para>
        <para>
        Ezen függvények esetében a fordító behelyettesíti a 
        hívás helyére az inline-ban megadott kódrészt,ezzel
        gyorsítva az általános függvényhívás menetét.</para>
        <para><command>I/O alapok</command></para>
        <para>
        <command>operátor túlterhelés</command></para>
        <para>A c++ nyelvben néhány új operátor lett bevezetve a C-hez képest.
        Ilyen például a hatókör operátor(::), a pointer-tag ooperátor(.* és -&gt;*).
        </para>
        <para/>
    </section>        
</chapter>

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Schwarzenegger!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Szoftmax Py MNIST</title>
        <para>aa
            Python
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <programlisting language="python">
        <![CDATA[# Copyright 2015 The TensorFlow Authors. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================

"""Builds the MNIST network.

Implements the inference/loss/training pattern for model building.

1. inference() - Builds the model as far as is required for running the network
forward to make predictions.
2. loss() - Adds to the inference model the layers required to generate loss.
3. training() - Adds to the loss model the Ops required to generate and
apply gradients.

This file is used by the various "fully_connected_*.py" files and not meant to
be run.
"""
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import math

import tensorflow as tf

# The MNIST dataset has 10 classes, representing the digits 0 through 9.
NUM_CLASSES = 10

# The MNIST images are always 28x28 pixels.
IMAGE_SIZE = 28
IMAGE_PIXELS = IMAGE_SIZE * IMAGE_SIZE


def inference(images, hidden1_units, hidden2_units):
  """Build the MNIST model up to where it may be used for inference.

  Args:
    images: Images placeholder, from inputs().
    hidden1_units: Size of the first hidden layer.
    hidden2_units: Size of the second hidden layer.

  Returns:
    softmax_linear: Output tensor with the computed logits.
  """
  # Hidden 1
  with tf.name_scope('hidden1'):
    weights = tf.Variable(
        tf.truncated_normal([IMAGE_PIXELS, hidden1_units],
                            stddev=1.0 / math.sqrt(float(IMAGE_PIXELS))),
        name='weights')
    biases = tf.Variable(tf.zeros([hidden1_units]),
                         name='biases')
    hidden1 = tf.nn.relu(tf.matmul(images, weights) + biases)
  # Hidden 2
  with tf.name_scope('hidden2'):
    weights = tf.Variable(
        tf.truncated_normal([hidden1_units, hidden2_units],
                            stddev=1.0 / math.sqrt(float(hidden1_units))),
        name='weights')
    biases = tf.Variable(tf.zeros([hidden2_units]),
                         name='biases')
    hidden2 = tf.nn.relu(tf.matmul(hidden1, weights) + biases)
  # Linear
  with tf.name_scope('softmax_linear'):
    weights = tf.Variable(
        tf.truncated_normal([hidden2_units, NUM_CLASSES],
                            stddev=1.0 / math.sqrt(float(hidden2_units))),
        name='weights')
    biases = tf.Variable(tf.zeros([NUM_CLASSES]),
                         name='biases')
    logits = tf.matmul(hidden2, weights) + biases
  return logits


def loss(logits, labels):
  """Calculates the loss from the logits and the labels.

  Args:
    logits: Logits tensor, float - [batch_size, NUM_CLASSES].
    labels: Labels tensor, int32 - [batch_size].

  Returns:
    loss: Loss tensor of type float.
  """
  labels = tf.to_int64(labels)
  cross_entropy = tf.nn.sparse_softmax_cross_entropy_with_logits(
      logits, labels, name='xentropy')
  loss = tf.reduce_mean(cross_entropy, name='xentropy_mean')
  return loss


def training(loss, learning_rate):
  """Sets up the training Ops.

  Creates a summarizer to track the loss over time in TensorBoard.

  Creates an optimizer and applies the gradients to all trainable variables.

  The Op returned by this function is what must be passed to the
  `sess.run()` call to cause the model to train.

  Args:
    loss: Loss tensor, from loss().
    learning_rate: The learning rate to use for gradient descent.

  Returns:
    train_op: The Op for training.
  """
  # Add a scalar summary for the snapshot loss.
  tf.scalar_summary(loss.op.name, loss)
  # Create the gradient descent optimizer with the given learning rate.
  optimizer = tf.train.GradientDescentOptimizer(learning_rate)
  # Create a variable to track the global step.
  global_step = tf.Variable(0, name='global_step', trainable=False)
  # Use the optimizer to apply the gradients that minimize the loss
  # (and also increment the global step counter) as a single training step.
  train_op = optimizer.minimize(loss, global_step=global_step)
  return train_op


def evaluation(logits, labels):
  """Evaluate the quality of the logits at predicting the label.

  Args:
    logits: Logits tensor, float - [batch_size, NUM_CLASSES].
    labels: Labels tensor, int32 - [batch_size], with values in the
      range [0, NUM_CLASSES).

  Returns:
    A scalar int32 tensor with the number of examples (out of batch_size)
    that were predicted correctly.
  """
  # For a classifier model, we can use the in_top_k Op.
  # It returns a bool tensor with shape [batch_size] that is true for
  # the examples where the label is in the top k (here k=1)
  # of all logits for that example.
  correct = tf.nn.in_top_k(logits, labels, 1)
  # Return the number of true entries.
  return tf.reduce_sum(tf.cast(correct, tf.int32))]]>
        </programlisting>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
            Ez a program egy számítógépet betanító program, futtatásához a TensorFlow szükséges.
        Alacsony felbontású képeket analízáltat a számítógéppel, majd ezen képek alapján megpróbál egy másik képről hasonlóságot találni, és kitaláni, hogy mi látható a képen.
Itt konkrétan kézzel írt számokról dönti el, hogy a képen melyik szám látható.
A betanítási folyamat hossza függ a program bonyolultságától, de ez a program egyszerűnek számít, tehát elég könnyen 90% fölé mehet a pontossága, és a betanítási idő is rövid.
a <command>def</command> kulcsszóval definiálhatunk függvényeket.
Az első ilyen függvény az "inference", amely három argumentumot vár:
az <command>images</command>, <command>hidden1_units</command> és <command>hidden2_units</command> argumentumokat.  
Az első a képek helyét jelenti az input() függvényből, a második és a harmadik pedig a rejtett layerek méretét jelenti.
A függvényünk visszatérési értéke a softmax_linear, ez a kiszámolt "logit"-eket tárolja.
        </para>
        <para>A második függvény a loss(logits,labels), ez a logitekből és cimkékből kiszámítja a veszteséget.
        A harmadik függvény felel a betanításért, ez a training(loss,learning_rate).
        Az utolsó függvény az evaluation, amely visszaadja, hogy milyen sikerességgel találta el a program a helyes számot.
        </para>
    </section>        

   <!-- <section>
        <title>Szoftmax R MNIST</title>
        <para>
            R            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
-->
    <section>
        <title>Mély MNIST</title>
        <para>
            Python            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
              <programlisting language="python">
        <![CDATA[
# Copyright 2015 The TensorFlow Authors. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================

"""A deep MNIST classifier using convolutional layers.
See extensive documentation at
https://www.tensorflow.org/get_started/mnist/pros
"""
# Disable linter warnings to maintain consistency with tutorial.
# pylint: disable=invalid-name
# pylint: disable=g-bad-import-order

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import argparse
import sys
import tempfile

from tensorflow.examples.tutorials.mnist import input_data

import tensorflow as tf

FLAGS = None


def deepnn(x):
  """deepnn builds the graph for a deep net for classifying digits.
  Args:
    x: an input tensor with the dimensions (N_examples, 784), where 784 is the
    number of pixels in a standard MNIST image.
  Returns:
    A tuple (y, keep_prob). y is a tensor of shape (N_examples, 10), with values
    equal to the logits of classifying the digit into one of 10 classes (the
    digits 0-9). keep_prob is a scalar placeholder for the probability of
    dropout.
  """
  # Reshape to use within a convolutional neural net.
  # Last dimension is for "features" - there is only one here, since images are
  # grayscale -- it would be 3 for an RGB image, 4 for RGBA, etc.
  with tf.name_scope('reshape'):
    x_image = tf.reshape(x, [-1, 28, 28, 1])

  # First convolutional layer - maps one grayscale image to 32 feature maps.
  with tf.name_scope('conv1'):
    W_conv1 = weight_variable([5, 5, 1, 32])
    b_conv1 = bias_variable([32])
    h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1)

  # Pooling layer - downsamples by 2X.
  with tf.name_scope('pool1'):
    h_pool1 = max_pool_2x2(h_conv1)

  # Second convolutional layer -- maps 32 feature maps to 64.
  with tf.name_scope('conv2'):
    W_conv2 = weight_variable([5, 5, 32, 64])
    b_conv2 = bias_variable([64])
    h_conv2 = tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2)

  # Second pooling layer.
  with tf.name_scope('pool2'):
    h_pool2 = max_pool_2x2(h_conv2)

  # Fully connected layer 1 -- after 2 round of downsampling, our 28x28 image
  # is down to 7x7x64 feature maps -- maps this to 1024 features.
  with tf.name_scope('fc1'):
    W_fc1 = weight_variable([7 * 7 * 64, 1024])
    b_fc1 = bias_variable([1024])

    h_pool2_flat = tf.reshape(h_pool2, [-1, 7*7*64])
    h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)

  # Dropout - controls the complexity of the model, prevents co-adaptation of
  # features.
  with tf.name_scope('dropout'):
    keep_prob = tf.placeholder(tf.float32)
    h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob)

  # Map the 1024 features to 10 classes, one for each digit
  with tf.name_scope('fc2'):
    W_fc2 = weight_variable([1024, 10])
    b_fc2 = bias_variable([10])

    y_conv = tf.matmul(h_fc1_drop, W_fc2) + b_fc2
  return y_conv, keep_prob


def conv2d(x, W):
  """conv2d returns a 2d convolution layer with full stride."""
  return tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding='SAME')


def max_pool_2x2(x):
  """max_pool_2x2 downsamples a feature map by 2X."""
  return tf.nn.max_pool(x, ksize=[1, 2, 2, 1],
                        strides=[1, 2, 2, 1], padding='SAME')


def weight_variable(shape):
  """weight_variable generates a weight variable of a given shape."""
  initial = tf.truncated_normal(shape, stddev=0.1)
  return tf.Variable(initial)


def bias_variable(shape):
  """bias_variable generates a bias variable of a given shape."""
  initial = tf.constant(0.1, shape=shape)
  return tf.Variable(initial)


def main(_):
  # Import data
  mnist = input_data.read_data_sets(FLAGS.data_dir, one_hot=True)

  # Create the model
  x = tf.placeholder(tf.float32, [None, 784])

  # Define loss and optimizer
  y_ = tf.placeholder(tf.float32, [None, 10])

  # Build the graph for the deep net
  y_conv, keep_prob = deepnn(x)

  with tf.name_scope('loss'):
    cross_entropy = tf.nn.softmax_cross_entropy_with_logits(labels=y_,
                                                            logits=y_conv)
  cross_entropy = tf.reduce_mean(cross_entropy)

  with tf.name_scope('adam_optimizer'):
    train_step = tf.train.AdamOptimizer(1e-4).minimize(cross_entropy)

  with tf.name_scope('accuracy'):
    correct_prediction = tf.equal(tf.argmax(y_conv, 1), tf.argmax(y_, 1))
    correct_prediction = tf.cast(correct_prediction, tf.float32)
  accuracy = tf.reduce_mean(correct_prediction)

  graph_location = tempfile.mkdtemp()
  print('Saving graph to: %s' % graph_location)
  train_writer = tf.summary.FileWriter(graph_location)
  train_writer.add_graph(tf.get_default_graph())

  with tf.Session() as sess:
    sess.run(tf.global_variables_initializer())
    for i in range(20000):
      batch = mnist.train.next_batch(50)
      if i % 100 == 0:
        train_accuracy = accuracy.eval(feed_dict={
            x: batch[0], y_: batch[1], keep_prob: 1.0})
        print('step %d, training accuracy %g' % (i, train_accuracy))
      train_step.run(feed_dict={x: batch[0], y_: batch[1], keep_prob: 0.5})

    print('test accuracy %g' % accuracy.eval(feed_dict={
        x: mnist.test.images, y_: mnist.test.labels, keep_prob: 1.0}))

if __name__ == '__main__':
  parser = argparse.ArgumentParser()
  parser.add_argument('--data_dir', type=str,
                      default='/tmp/tensorflow/mnist/input_data',
                      help='Directory for storing input data')
  FLAGS, unparsed = parser.parse_known_args()
tf.app.run(main=main, argv=[sys.argv[0]] + unparsed)]]>
        </programlisting>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
            32 bites képeket használ a betanulási fázisban, ezek egyfajta "neurális hálón" haladnak keresztül, és a gép a csomópontokban megadott feltételek szerint dönt a kép azonosításáról.
            A végén százalékos formában kiírja a pontosságot.
            Ez kissebb erőforrásigényű programoknál 90+% fölé mehet, amely az embernél jobb hatékonyságot jelent.
        </para>
        <para>A legelső függvényünk a deepnn(x), ez a függvény egy gráfot épít ki a mély hálónknak,amely a számokat osztályozza.
        az X argumentum a dimenziók száma.
        Visszatérési értékként az y_conv ls a keep_prob térnek vissza.
        Az y változó a szám alakját adja vissza, 0 és 9 között változhat ez az érték.
        </para>
        <para>
        Következő funkció a conv2d(x,W).
        Ez egy 2d konvulációs réteget ad vissza.
        </para>
        <para>az ez alatt található funkció a max_pool_2x2, ez a függvény csökkenti a mintákat 2x.
        Ezután jön a weight_variable(shape) függvény, amely a nevéből is kideríthetően súlyozást ad a képhez, egy shape alapján.
        Végül a bias_variable, amely ugyancsak a shape alapján állít be bias-t. </para>
        <para>A legvégén található egy main() függvény, amely először importálja az adatokat,majd elkészíti a modellt, a veszteséget kiszámítja és végül felépíti a gráfot.
        </para>
    </section>        

    <section>
        <title>Minecraft-MALMÖ</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/bAPSu3Rndi8">https://youtu.be/bAPSu3Rndi8</link>      
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
            Sajnos nem volt alkalmam beszerezni a játékot.
        </para>
    </section>       
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chaitin!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Iteratív és rekurzív faktoriális Lisp-ben</title>
        <para>
               <command>Az SMNIST-el kiváltva</command> 
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
    </section>        
        
    <!--<section>
        <title>Weizenbaum Eliza programja</title>
        <para>
            Éleszd fel Weizenbaum Eliza programját!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
    </section>        
-->
    <section>
        <title>Gimp Scheme Script-fu: króm effekt</title>
        <para>
            Írj olyan script-fu kiterjesztést a GIMP programhoz, amely megvalósítja a króm effektet egy 
            bemenő szövegre!
		 <command>Az SMNIST-el kiváltva</command>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/OKdAkI_c7Sc">https://youtu.be/OKdAkI_c7Sc</link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Chrome">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Chrome</link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>    
    </section>        

    <section>
        <title>Gimp Scheme Script-fu: név mandala</title>
        <para>
            Írj olyan script-fu kiterjesztést a GIMP programhoz, amely név-mandalát készít a
            bemenő szövegből!               
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2019/01/10/a_gimp_lisp_hackelese_a_scheme_programozasi_nyelv">https://bhaxor.blog.hu/2019/01/10/a_gimp_lisp_hackelese_a_scheme_programozasi_nyelv</link>      
        </para>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Mandala">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Mandala</link>               
        </para>
        <programlisting language="c++">
        <![CDATA[; bhax_mandala9.scm
;
; BHAX-Mandala creates a mandala from a text box.
; Copyright (C) 2019  Norbert Bátfai, batfai.norbert@inf.unideb.hu
;
;    This program is free software: you can redistribute it and/or modify
;    it under the terms of the GNU General Public License as published by
;    the Free Software Foundation, either version 3 of the License, or
;    (at your option) any later version.
;
;    This program is distributed in the hope that it will be useful,
;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;    GNU General Public License for more details.
;
;    You should have received a copy of the GNU General Public License
;    along with this program.  If not, see <https://www.gnu.org/licenses/>.
;
; Version history
;
;  This Scheme code is partially based on the Python code 
;  Pat625_Mandala_With_Your_Name.py by Tin Tran, which is released under the GNU GPL v3, see 
;  https://gimplearn.net/viewtopic.php/Pat625-Mandala-With-Your-Name-Script-for-GIMP?t=269&p=976
;
;  https://bhaxor.blog.hu/2019/01/10/a_gimp_lisp_hackelese_a_scheme_programozasi_nyelv
; 

(define (elem x lista)

    (if (= x 1) (car lista) (elem (- x 1) ( cdr lista ) ) )

)

(define (text-width text font fontsize)
(let*
    (
        (text-width 1)
    )
    (set! text-width (car (gimp-text-get-extents-fontname text fontsize PIXELS font)))    

    text-width
    )
)

(define (text-wh text font fontsize)
(let*
    (
        (text-width 1)
        (text-height 1)
    )
    ;;;
    (set! text-width (car (gimp-text-get-extents-fontname text fontsize PIXELS font)))    
    ;;; ved ki a lista 2. elemét
    (set! text-height (elem 2  (gimp-text-get-extents-fontname text fontsize PIXELS font)))    
    ;;;    
    
    (list text-width text-height)
    )
)


;(text-width "alma" "Sans" 100)

(define (script-fu-bhax-mandala text text2 font fontsize width height color gradient)
(let*
    (
        (image (car (gimp-image-new width height 0)))
        (layer (car (gimp-layer-new image width height RGB-IMAGE "bg" 100 LAYER-MODE-NORMAL-LEGACY)))
        (textfs)
        (text-layer)
        (text-width (text-width text font fontsize))
        ;;;
        (text2-width (car (text-wh text2 font fontsize)))
        (text2-height (elem 2 (text-wh text2 font fontsize)))
        ;;;
        (textfs-width)
        (textfs-height)
        (gradient-layer)
    )

    (gimp-image-insert-layer image layer 0 0)

    (gimp-context-set-foreground '(0 255 0))
    (gimp-drawable-fill layer FILL-FOREGROUND)
    (gimp-image-undo-disable image) 

    (gimp-context-set-foreground color)

    (set! textfs (car (gimp-text-layer-new image text font fontsize PIXELS)))
    (gimp-image-insert-layer image textfs 0 -1)
    (gimp-layer-set-offsets textfs (- (/ width 2) (/ text-width 2))  (/ height 2))
    (gimp-layer-resize-to-image-size textfs)

    (set! text-layer (car (gimp-layer-new-from-drawable textfs image)))
    (gimp-image-insert-layer image text-layer 0 -1)
    (gimp-item-transform-rotate-simple text-layer ROTATE-180 TRUE 0 0)
    (set! textfs (car(gimp-image-merge-down image text-layer CLIP-TO-BOTTOM-LAYER)))

    (set! text-layer (car (gimp-layer-new-from-drawable textfs image)))
    (gimp-image-insert-layer image text-layer 0 -1)
    (gimp-item-transform-rotate text-layer (/ *pi* 2) TRUE 0 0)
    (set! textfs (car(gimp-image-merge-down image text-layer CLIP-TO-BOTTOM-LAYER)))

    (set! text-layer (car (gimp-layer-new-from-drawable textfs image)))
    (gimp-image-insert-layer image text-layer 0 -1)
    (gimp-item-transform-rotate text-layer (/ *pi* 4) TRUE 0 0)
    (set! textfs (car(gimp-image-merge-down image text-layer CLIP-TO-BOTTOM-LAYER)))
    
    (set! text-layer (car (gimp-layer-new-from-drawable textfs image)))
    (gimp-image-insert-layer image text-layer 0 -1)
    (gimp-item-transform-rotate text-layer (/ *pi* 6) TRUE 0 0)
    (set! textfs (car(gimp-image-merge-down image text-layer CLIP-TO-BOTTOM-LAYER)))    
    
    (plug-in-autocrop-layer RUN-NONINTERACTIVE image textfs)
    (set! textfs-width (+ (car(gimp-drawable-width textfs)) 100))
    (set! textfs-height (+ (car(gimp-drawable-height textfs)) 100))
        
	(gimp-layer-resize-to-image-size textfs)
    
    (gimp-image-select-ellipse image CHANNEL-OP-REPLACE (- (- (/ width 2) (/ textfs-width 2)) 18) 
        (- (- (/ height 2) (/ textfs-height 2)) 18) (+ textfs-width 36) (+ textfs-height 36))
	(plug-in-sel2path RUN-NONINTERACTIVE image textfs)
        
    (gimp-context-set-brush-size 22)
    (gimp-edit-stroke textfs)
    
    (set! textfs-width (- textfs-width 70))
    (set! textfs-height (- textfs-height 70))
    
    (gimp-image-select-ellipse image CHANNEL-OP-REPLACE (- (- (/ width 2) (/ textfs-width 2)) 18) 
        (- (- (/ height 2) (/ textfs-height 2)) 18) (+ textfs-width 36) (+ textfs-height 36))
	(plug-in-sel2path RUN-NONINTERACTIVE image textfs)
        
    (gimp-context-set-brush-size 8)
    (gimp-edit-stroke textfs)
        
    (set! gradient-layer (car (gimp-layer-new image width height RGB-IMAGE "gradient" 100 LAYER-MODE-NORMAL-LEGACY)))
    
    (gimp-image-insert-layer image gradient-layer 0 -1)
	(gimp-image-select-item image CHANNEL-OP-REPLACE textfs)
	(gimp-context-set-gradient gradient) 
	(gimp-edit-blend gradient-layer BLEND-CUSTOM LAYER-MODE-NORMAL-LEGACY GRADIENT-RADIAL 100 0 
	REPEAT-TRIANGULAR FALSE TRUE 5 .1 TRUE (/ width 2) (/ height 2) (+ (+ (/ width 2) (/ textfs-width 2)) 8) (/ height 2))
	
	(plug-in-sel2path RUN-NONINTERACTIVE image textfs)

    (set! textfs (car (gimp-text-layer-new image text2 font fontsize PIXELS)))
    (gimp-image-insert-layer image textfs 0 -1)
    (gimp-message (number->string text2-height))
    (gimp-layer-set-offsets textfs (- (/ width 2) (/ text2-width 2)) (- (/ height 2) (/ text2-height 2)))
		
    ;(gimp-selection-none image)
    ;(gimp-image-flatten image)
    
    (gimp-display-new image)
    (gimp-image-clean-all image)
    )
)

;(script-fu-bhax-mandala "Bátfai Norbert" "BHAX" "Ruge Boogie" 120 1920 1080 '(255 0 0) "Shadows 3")

(script-fu-register "script-fu-bhax-mandala"
    "Mandala9"
    "Creates a mandala from a text box."
    "Norbert Bátfai"
    "Copyright 2019, Norbert Bátfai"
    "January 9, 2019"
    ""
    SF-STRING       "Text"      "Bátf41 Haxor"
    SF-STRING       "Text2"     "BHAX"
    SF-FONT         "Font"      "Sans"
    SF-ADJUSTMENT   "Font size" '(100 1 1000 1 10 0 1)
    SF-VALUE        "Width"     "1000"
    SF-VALUE        "Height"    "1000"
    SF-COLOR        "Color"     '(255 0 0)
    SF-GRADIENT     "Gradient"  "Deep Sea"
)
(script-fu-menu-register "script-fu-bhax-mandala" 
    "<Image>/File/Create/BHAX"
)
]]>
        </programlisting>
        <para>
            
            Tanulságok, tapasztalatok, magyarázat...
            A megszokott-tól eltérően a nyelvben nem infix alakban adjuk meg a műveleteket, hanem prefix alakban.

        </para> 
        <programlisting><![CDATA[(define (elem x lista)

    (if (= x 1) (car lista) (elem (- x 1) ( cdr lista ) ) )

)]]></programlisting> 
<para>Mint láthatjuk, itt a define kulcsszóval lehet függvényeket inicializálni.
Ez a függvény az "elem" névre hallgat, és 2 paramétert kér be, az "x"-et és a "lista"-át.
Ha az x=1, akkor a (car lista) parancs hajtódik végre, ha nem, akkor pedig az (elem (x-1) (cdr lista)) parancs.
Ez miatt a sor miatt a függvény rekurzív lesz, hiszen addig hajta végre az "else" ágat, amíg az x!=1.

</para>
<programlisting><![CDATA[(define (text-width text font fontsize)
(let*
    (
        (text-width 1)
    )
    (set! text-width (car (gimp-text-get-extents-fontname text fontsize PIXELS font)))    

    text-width
    )
)]]></programlisting>  
<para>
Ez a függvény a szöveg szélességét kezeli.
paraméterként bekéri a szöveget, a betűtípust és a betűméretet.
A függvény törzsében a megadott paraméterekkel a gimp beállítja a szöveg kinézetét.
</para>  
<programlisting><![CDATA[(define (script-fu-bhax-mandala text text2 font fontsize width height color gradient)
(let*
    (]]></programlisting>
    <para>Ezen kezdetű függvény tekinthető a main fügvénynek, hiszen itt alkalmazzuk az előbb megadott függvényeket, itt 
    írjuk a program érdemi részét.
     </para>      
     <programlisting><![CDATA[(gimp-image-insert-layer image layer 0 0)

    (gimp-context-set-foreground '(0 255 0))
    (gimp-drawable-fill layer FILL-FOREGROUND)
    (gimp-image-undo-disable image) ]]></programlisting>
    <para>
    Az első sor beilleszt egy layert, a második sor beállítja annak háttérszínét zöldre, a harmadik sor kitölti a hátteret, az utolsó
    sor pedig újra aktiválja a képet.
    </para>
    </section>        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
  <!--  <section>
        <title>Lambda</title>
        <para>
            Hasonlítsd össze a következő programokat!
        </para>
        <para>
            Megoldás videó: <link xlink:href=""></link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""></link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        

    <section>
        <title>Omega</title>
        <para>
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
    </section>        
         -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
</chapter>     
    
            
</part>                                                              

    <part xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Második felvonás</title>
    <partintro>
        <para> 
        </para>
<tip>
              <title>Bátf41 Haxor Stream</title>
              <para>
                  A feladatokkal kapcsolatos élő adásokat sugároz
                  a <link xlink:href="https://www.twitch.tv/nbatfai">https://www.twitch.tv/nbatfai</link> csatorna,
                  melynek permanens archívuma a <link xlink:href="https://www.youtube.com/c/nbatfai">https://www.youtube.com/c/nbatfai</link> 
                  csatornán található.
              </para>            
            </tip>    
        
    </partintro>

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Berners-Lee!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Olvasónaplók</title>
        <para>
C++:Benedek Zoltán,Levendovszky Tihamér Szoftverfejlesztés C++ nyelven
Java: Nyékyné Dr. Gaizler Judit et al. Java 2 útikalauz programozóknak 5.0
ebből a kettőből egy pár oldalas összehasonlító esszé.
Python:Forstner Bertalan,Ekler Péter,Kelényi Imre:Bevezetés a mobilprogramozásba
Gyors prototípus-fejlesztés Python és Java nyelven(35-51 oldal)
-ebből 1-oldalas élmény-napló
	    </para>

        <para>
            <command>C++ és Java összehasonlítás</command>           
        </para>

        <para>
            java-ban minden metódusnak kell visszatérési érték típust adni.
C++-ban viszont nem muszáj, hiszen alapértelmezetten int típust feltételez a program, ha nem adunk neki típust.
A cpp-tól eltérően Java-ban String[]tömb tárolja az argumentumokat
ezzel szemben a C ill. C++-ban argv és argc változó együttes tárolja azokat
argv az argumentumokat tároló vektor, az argc pedig az argumentumok számát tároló változó.
        </para>

        <para>
        logikai típus C++-ban bool, Java-ban boolean.
        </para><para>
basic io művelet java-ban System.out.Println(),  C++-ban std::cout parancs használatával történik.
ezek listázása is eltérő, java-ban a pascal-hoz hasonlóan + jellel fűzünk össze változókat ill. szöveget, Cpp-ban pedig &gt;&gt; jel váltja fel a + szerepét
Továbbá Java-ban nincs operátor túlterhelés!
        </para>

        <para>
        Java-ban a karakterkészlet defaultban utf-8, c++-ban include-olni kell egy library-t, hogy utf-8-as karaktereket használhassunk, anélkül nehézkes a használatuk.
        a konstansok megadása Java-ban a "final" kulcsszó használatával lehetséges, c++-ban ezt a const-al tehetjük meg
        Példák:
        </para>

        
        <programlisting language="java"><![CDATA[final static double pi=3.14;]]></programlisting>
        
        <programlisting language="C++"><![CDATA[const double pi=3.14;]]>
        </programlisting>
        <para>
        Az objektumok elemeire hivatkozhatunk, az <command>"objektum neve"."elem neve"</command> módon.
Ha az elem-nek egy elemére szertnénk hivatkozni, azt hasonló modon kell megtenni.
A java-ban nincs explicit mód a memóriahely felszabadítására, a pointerek NULL-ra állítását tehetjük meg, amit a "garbage collector" később eltűntet.
nincs dekonstruktor, ezzel szemben C-ben és C++-ban van dekonstruktor, amit az objektum elején elhelyezett "~" jellel "állítunk elő".

        </para>
        <programlisting language="C++"><![CDATA[~LZWBinFa ()
    {
        
    }]]></programlisting>
    <para>
    Továbbá C++-ban lehetőségünk van(és kell is) a pointerek által lefoglalt memóriahelyek felszabadítására 3 módszerrel.
    </para>
    <programlisting language="C++"><![CDATA[delete ptr;
ptr=NULL;
//vagy pedig
free(ptr);]]></programlisting>
<para>
C-ben nincs lehetőség a <command>"delete ptr;"</command> módszerre.
A pointer NULL-ra állítása viszont nem szabadítja fel a helyet, csak ún. "árvát" hoz létre, mivel a C++ nem "garbage collector" nyelv.
A lefoglalt terület még fennáll, de nem lehet elérni, és egy memory leak képződik.
Ezek a memória leak-ek csak akkor okoznak nagyobb gondot, ha elfogy a memória, ekkor a program preemptív kilép, "crash-el".
</para>
<para>
Ha egy objektumot a <command>new()</command> metódussal hoztunk létre, akkor a <command>delete</command> paranccsal szabadítsuk fel a helyet, ha a <command>malloc()-ot</command> használtuk memória lefoglaláshoz, akkor a <command>free()</command>-vel szabadítjuk fel a memóriában foglalt helyet.
Fontos tudni, hogy a <command>free()</command> nem hívja a destructor-t, azt csak a <command>delete</command> teszi meg!
</para>
<para>
Mindkét programnyelvben megtalálható az automatikus/implicit típus konverzió.
Ha a fordító program a vártnál eltérő típusú adatot kap, azt automatikusan megpróbálja átkonvertálni a várt típusra.
Ez nem mindíg lehetséges!
Például az egyénileg létrehozott típusokat nem tudja átkonvertálni.
</para>
<para>
A try-catch hibakezelő metódus mindkét nyelvben elérhető.
Ezekről egy-egy példakód itt:</para><para><link xlink:href="https://github.com/ghjbku/prog2/tree/master/elm%C3%A9let/Osztas.java">Java</link> 
</para>
<para>
<link xlink:href="https://github.com/ghjbku/prog2/tree/master/elm%C3%A9let/try_Catch.cpp">C++</link> 
</para>
<para>A  java nyelvben a tömb típus egy igazi típus, amíg c++-ban csak egy mutató típus. mindkét nyelvben 0-val kezdődik az indexelés a tömbben, Továbbá az enum típus is jelen van.
Java-ban a pont minden esetben a tagok elérésére szolgál, és a C++-tól eltérően itt nincs megkülönböztető jelölés osztálytagok elérésénél(C++-ban :: operátor)
</para>
<para>A C és C++-tól eltérően a Java-ban nics GOTO utasítás, azzal a címszóval lett elhagyva, hogy ezáltal biztonságosabb és megbízhatóbb programokat kapunk.
a korábbi goto-val megoldott problémákra új megoldások vannak:
ciklus elhagyása a <command>break</command> utasítással történik, a ciklus folytatása a <command>continue</command> utasítással.
Java-ban a legkissebb önálló egységek az osztályok.</para>
  <para/>



        <para>
            <command>Python könyv élmény-napló </command>           
        </para>
        <para>
        A Python <command>magasszintű, általános célú nyelv</command>, szkriptnyelvként szokták emlegetni.
A kódokat egy futtatókörnyezeten keresztül futtatják általában, viszont vannak már kísérleti stádiumban natív kódot generáló fordítóprogramok is.
Mind a procedurális, és az objektumorientált programozást támogatja
Könyvátárnak mérete a nyelv egyik erősségének mondható, melyben még http támogatás is megtalálható.
C, cpp nyelven készült modulok is egyszerűen adhatók hozzá a környezethez.
Népszerűségét az egyszerűségnek köszönheti, <command>szinte bármilyen feladatot meg lehet oldani a nyelvben</command>, viszont elsősorban kliensszoftverek készítésére alkalmazzák.
A mobileszközökön is futtatható, írható python kód, viszont ez nem újdonság, hiszen java ill. C++ kódokat is futtathatunk manapság.
        </para>

        <para>
	A <command>Symbian OS</command> mobiltelefon operációs rendszer egyike a napjainkban legtöbbet alkalmazott operációs rendszereknek.
	Mind C++-ban, Python-ban és Java-ban is írhatónk rá kódokat, viszont a rendszer felett még ott van egy GUI(Grafikus felhasználói felület), ezekből manapság 2 típus ismert:
	<command>S60(korábban Series60)</command> és az <command>UIQ</command>.
	Hasonló funkcionalitás lelhető fel mindkét rendszerben, viszont ennek ellenére a kettő nem kompatibilitis egymással, az egyikre írt programok nem fognak a másikon elfutni.
	Az operációs rendszer alapfunkcióiban azonban megegyezik, tehát csak az UI-hez kötődő részeket kell külön megírnunk kétféleképpen.
       </para>

        <para>
	A <command>Windows Mobile</command> pedig a Microsoft mobiltelefonokhoz fejlesztett operációsrendszer,amely a Windows CE rendszeren alapul.
	A Symbian-hoz képest több lehetőségünk van a programnyelvek használatát illetően.
	A C++, Python és Java-n kívül natív alkalmazásokat készíthetünk C nyelven is, és persze az ugyancsak Microsoft által fejlesztett .NET compact framework technológiával egyaránt.
	Ez utóbbi a Microsoft .NET telefonokra kifejlesztett változata. 
        </para>

	<para>
	A Harmadik operációsrendszer mobiltelefonokra a nyílt forráskódú, Linux-ra épülő <command>Maemo</command>, ez a rendszer a Nokia fejlesztése alatt áll.
	A rendszer nagyrészben az internetes elérésekre,megoldásokra fókuszál, viszont az alapvető funkciókat ezen a rendszeren is el tudjuk végezni.
Jelenleg a Bluetooth és WLAN funkciókat támogatja, de már a Wimax támogatását is híresztelik.
	</para>
    </section>       
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>  

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Arroway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>OO szemlélet</title>
        <para>A módosított polártranszformációs normális generátor beprogramozása Java nyelven.
Mutassunk rá, hogy a mi természetes saját megoldásunk és az OpenJDK, Oracle JDK-ban a Sun által adott OO szervezés ua.!
<link xlink:href="https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog1_5.pdf">Prog1_5.pdf</link>               
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/ghjbku/prog2/tree/master/OO_szemlelet">github link</link> </para>
        <para>
            </para>
            <figure>
            <title>A <type> JDK</type> kód</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="OO_szemlelet/gauss.png" scale="200"/>
                </imageobject>
                <textobject>
                    <phrase>A <type> JDK</type> kód</phrase>
                </textobject>
            </mediaobject>
        </figure> 
        <para>Amint láthatjuk, a változók elnevezésén kívül és <command>StrictMath,nextDouble</command> metódusokon kívül az általunk írt kód megegyezik.
        Mi ugyanis StrictMath helyett a Math metódust használtuk a gyökvonás és logaritmus képzésnél.</para>
        <programlisting language="java"><![CDATA[double r=Math.sqrt((-2*Math.log(c))/c);]]></programlisting>   
    <para>A fő eltérés a két metódus között(azon kívül, hogy a StrictMath-ban hiperbolikus és egyéb függvények is elérhetőek) az, hogy a <command>StrictMath</command>-nál ha meghívunk egy függvényt, annak ugyan azt az értéket kell visszaadnia például x86-os lebegőpontos változónál, mint SPARC lebegőpontos-nál.
    Ezzel szemben a Math megengedi, hogy a pontosságért cserébe gyorsabban leforduljon a programunk.(na persze a pontossági eltérés nem számottevő a jelen programunk megírásánál)</para>
    <programlisting language="java"><![CDATA[public class polargenerator
{]]></programlisting><para>Amint láthatjuk, az egész programkód egy osztályba van elhelyezve, ez a Java-nak egy sajátossága.</para>
   <programlisting language="java"><![CDATA[ boolean nincstar=true;
 double tarolt;]]></programlisting><para>A forráskód elején inicializálunk két változót, a <command>nincstar</command> változó egy logikai változó, amely megmondja, hogy van-e eltárolva adat.
 Ezzel szemben a <command>tarolt</command> változó hordozza majd a tárolni kívánt értéket.</para>
<programlisting language="java"><![CDATA[ public double kovetkezo()
	{
	if(nincstar)
		{
		double a1,a2,b1,b2,c; ]]></programlisting><para>Itt pedig egy kovetkezo nevű metódust hozunk létre, ha a nincstar értéke igaz, akkor végrehajtódik az if-ben leírt változók deklarálása.
        </para>
        <programlisting language="java"><![CDATA[do{
		  a1=Math.random();
		  a2=Math.random();
		  b1=2*a1-1;
		  b2=2*a2-1;
		  c=b1 * b1 + b2 * b2;
		          }while(c>1);]]></programlisting><para>Ez a következő pár sor egy hátultesztelős ciklus.
                         Először az a1,a2 változók értékét randomizáljuk, majd a b1,b2 változókban az előbbi két értéket
                         megduplázzuk és csökkentjük az értéket 1-el.
                         a c változó értékét a b1 és b2 változók négyzetével tesszük egyenlővé. Ez addig fut, amíg a c értéke nagyobb lesz, mint 1.
                          </para>
        <programlisting language="java"><![CDATA[double r=Math.sqrt((-2*Math.log(c))/c);
		tarolt=r*b2;
		nincstar=!nincstar;
		return r*b1;
        ]]></programlisting><para>ezekben a sorokban létrehozunk egy r változót, és annak az értékéül a <![CDATA[Math.sqrt((-2*Math.log(c))/c)]]> függvény eredményét adjuk.
        a tárolandó érték az r változó és a b2 változó szorzata lesz, az értékadás után pedig a nincstar értékét negáljuk.
        végül visszatérési értékként a r és a b1 szorzatát adjuk meg.
        </para>
        <programlisting language="java"><![CDATA[else
		{
		nincstar=!nincstar;
		return tarolt;		
		}
	]]></programlisting><para>Az else ágban csak annyi a dolgunk, hogy a nincstar értékét negáljuk, és a tárolt értéket adjuk meg visszatérési értékként.
    Végezetül pedig kiíratjuk a main-ben.</para>
     <programlisting language="java"><![CDATA[public static void main(String[] args)
	{polargenerator g = new polargenerator();
	for(int i=0; i<10;++i)
		{
		System.out.println(g.kovetkezo());
		}
	}]]></programlisting>
    </section>        

<section>
        <title>"Gagyi"</title>
        <para>
Az ismert formális <command><![CDATA[while(x <=t && x>=t && t!=x);]]></command> tesztkérdéstípusra adj a szokásosnál "mélyebb" választ, írj Java példaprogramot mely egyszer végtelen ciklus, más x és t értékekkel pedig nem!
A példát építsd a JDK Integer.java forrására, hogy a 128-nál inkluzív objektum példányokat poolozza! 
<link xlink:href="https://www.facebook.com/groups/udprog/permalink/437825193072042/">facebook post</link>
	</para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/ghjbku/prog2/tree/master/gagyi">github link</link>
                       
        </para>
    
        <para>
    <![CDATA[while (x <= t && x >= t && t != x);]]>        
        </para>
        <para>Amint láthatjuk, az első két tagja a ciklus feltételeknek a két változó értékét hasonlítja össze
        . A harmadik viszont (<command>t!=x</command>) a változók referenciáját, ami az integer-cache miatt -128 és 127 között ugyanaz lesz.
        A gagyi.java fájl ezért végtelenciklust képez, hiszen a -129 már nincs benne a cache-ben, ezért 
        a t!=x mindíg igaz lesz.
        a gagyi2.java viszont a -128 értékkel dolgozik, ami benne van a cache-ben, tehát a ciklus nem jön létre.
        </para>
        <para>Érdekesség még, hogy a Java6 óta bevezették a felső érték bindelését, amely a 
        </para><para><command>java.lang.Integer.IntegerCache.high</command>
         segítségével a programozó által is állítható lett.
         Fontos tudni viszont, hogy a maximális érték legalább 127 kell, hogy legyen.
         Ha az érték kevesebb, akkor egy AssertionError hibakódot kapunk.</para>
         <figure>
            <title>A <type> gagyi</type> futás</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="gagyi/gagyirun.png" scale="200"/>
                </imageobject>
                <textobject>
                    <phrase>A <type> gagyi</type> futás</phrase>
                </textobject>
            </mediaobject>
        </figure> 
    </section>   

    <section>
        <title>Yoda</title>
        <para>
Írjunk olyan Java programot, ami java.lang.NullPointerEx-el leáll, ha nem követjük a Yoda conditions-t!           
<link xlink:href="https://en.wikipedia.org/wiki/Yoda_conditions">yoda wiki</link>
	</para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/ghjbku/prog2/tree/master/yoda">github link</link>              
        </para>
        <programlisting language="java"><![CDATA[public class yoda
{
	String i;
   public yoda()
   {
   i=null;
		
   }
   public static void main(String[] args)
	{
	yoda f=new yoda();
	
	if("5".equals(f.i))//if(f.i.equals("5"))
	{
	System.out.println("t");
	}
	else
	{
	System.out.println("f");
	}
   }
}]]></programlisting>
        <figure>
            <title>A <type> yoda</type> futás</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="yoda/unknown.png" scale="200"/>
                </imageobject>
                <textobject>
                    <phrase>A <type> yoda</type> futás</phrase>
                </textobject>
            </mediaobject>
        </figure> 
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>

    </section>        
    
<section>
        <title>Kódolás from scratch</title>
        <para>
Induljunk ki ebből a tudományos közleményből:<link xlink:href="http://crd-legacy.lbl.gov/~dhbailey/dhbpapers/bbp-alg.pdf">http://crd-legacy.lbl.gov/~dhbailey/dhbpapers/bbp-alg.pdf</link>
és csak ezt tanulmányozva írjuk meg Java nyelven a BBP algoritmus megvalósítását!
Ha megakadsz, de csak végső esetben:<link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apbs02.html#pi_jegyei">https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apbs02.html#pi_jegyei</link>

	</para>
        <para>
            Megoldás forrása:               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>       
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     
    
 <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Liskov!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
	
	<section>
<title>Liskov helyettesítés sértése</title>
        <para>Írjunk olyan OO, leforduló Java és C++ kódcsipetet, amely megsérti a Liskov elvet! Mutassunk rá a
megoldásra: jobb OO tervezés.
https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_1.pdf (93-99 fólia)
(számos példa szerepel az elv megsértésére az UDPROG repóban, lásd pl. source/binom/Batfai-
Barki/madarak/)</para>
	</section>
	
	<section>
<title>Szülő-gyerek</title>
        <para>Írjunk Szülő-gyerek Java és C++ osztálydefiníciót, amelyben demonstrálni tudjuk, hogy az ősön
keresztül csak az ős üzenetei küldhetőek!
https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_1.pdf (98. fólia)</para>
	</section>

	<section>
<title>Anti OO</title>
        <para>A BBP algoritmussal 4 a Pi hexadecimális kifejtésének a 0. pozíciótól számított 10 6, 107, 108 darab
jegyét határozzuk meg C, C++, Java és C# nyelveken és vessük össze a futási időket!
https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apas03.html#id561066</para>
	</section>

	<section>
<title>Hello, Android!</title>
        <para>Élesszük fel az SMNIST for Humans projektet!
https://gitlab.com/nbatfai/smnist/tree/master/forHumans/SMNISTforHumansExp3/app/src/main
Apró módosításokat eszközölj benne, pl. színvilág.</para>
	</section>

	<section>
<title>Ciklomatikus komplexitás</title>
        <para>Számoljuk ki valamelyik programunk függvényeinek ciklomatikus komplexitását! Lásd a fogalom
tekintetében a https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_2.pdf (77-79
fóliát)!</para>
	</section>

	<section>
<title>deprecated - Hello, Android!</title>
	<para>Élesszük fel a https://github.com/nbatfai/SamuEntropy/tree/master/cs projektjeit és vessünk össze
néhány egymásra következőt, hogy hogyan változtak a források!</para>
	</section>
	
	<section>
	<title>Hello, SMNIST for Humans!</title>
	<para>Fejleszd tovább az SMNIST for Humans projektet SMNIST for Anyone emberre szánt appá! Lásd
az smnist2_kutatasi_jegyzokonyv.pdf-ben a részletesebb hátteret!</para>
	</section>
</chapter>     
    
            
</part>                                                              


    <bibliography xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Irodalomjegyzék</title>
    <bibliodiv>
        <title>Általános</title>
        <biblioentry xml:lang="hu">
            <abbrev>MARX</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>György</firstname>
                        <surname>Marx</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>Gyorsuló idő</title>
            <publisher>
                <publishername>
                    Typotex
                </publishername>
            </publisher>
            <pubdate>2005</pubdate>
        </biblioentry>  
    </bibliodiv> 
    <bibliodiv>
        <title>C</title>
        <biblioentry>
            <abbrev>KERNIGHANRITCHIE</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Brian W.</firstname>
                        <surname>Kernighan</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>Dennis M.</firstname>
                        <surname>Ritchie</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>A C programozási nyelv</title>
            <publisher>
                <publishername>Bp., Műszaki</publishername>
            </publisher>
            <pubdate>1993</pubdate>
        </biblioentry>            
    </bibliodiv>
    <bibliodiv>
        <title>C++</title>
        <biblioentry>
            <abbrev>BMECPP</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Zoltán</firstname>
                        <surname>Benedek</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>Tihamér</firstname>
                        <surname>Levendovszky</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>Szoftverfejlesztés C++ nyelven</title>
            <publisher>
                <publishername>Bp., Szak Kiadó</publishername>
            </publisher>
            <pubdate>2013</pubdate>
        </biblioentry>            
    </bibliodiv>
    <bibliodiv>
        <title>Lisp</title>
        <biblioentry>
            <abbrev>METAMATH</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Gregory</firstname>
                        <surname>Chaitin</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>META MATH! The Quest for Omega</title>
            <publisher>
                <publishername>
                    <link xlink:href="http://arxiv.org/PS_cache/math/pdf/0404/0404335v7.pdf">http://arxiv.org/PS_cache/math/pdf/0404/0404335v7.pdf</link>
                </publishername>
            </publisher>
            <pubdate>2004</pubdate>
        </biblioentry> 
    </bibliodiv>    
</bibliography>     
          
            <acknowledgements xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <para>
        Köszönet illeti a
        NEMESPOR, <link xlink:href="https://groups.google.com/forum/#!forum/nemespor">https://groups.google.com/forum/#!forum/nemespor</link>, 
        az UDPROG tanulószoba, <link xlink:href="https://www.facebook.com/groups/udprog">https://www.facebook.com/groups/udprog</link>, 
        a DEAC-Hackers előszoba, <link xlink:href="https://www.facebook.com/groups/DEACHackers">https://www.facebook.com/groups/DEACHackers</link> 
        (illetve egyéb alkalmi szerveződésű szakmai csoportok) 
        tagjait inspiráló érdeklődésükért és hasznos észrevételeikért.         
    </para>                 
    <para>
        Ezen túl kiemelt köszönet illeti az említett UDPROG közösséget, mely a Debreceni Egyetem reguláris 
        programozás oktatása tartalmi szervezését támogatja. Sok példa eleve ebben a közösségben született, vagy itt került
        említésre és adott esetekben szerepet kapott, mint oktatási példa.         
    </para>                 
</acknowledgements>     

</book>
