<?xml version="1.0" encoding="UTF-8"?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">    
    
    <info xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">

    <title xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">Programozás könnyüszerrel</title>               

    <subtitle xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">veszélyes könyv, még megtanulhatsz programozni, ha nem vigyázol!</subtitle>               

    <titleabbrev xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">WPE</titleabbrev>               

    <authorgroup xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <author>
        <personname>
            <surname>Tóth</surname>
            <firstname>Balázs</firstname>        
        </personname>    
        <affiliation>
            <shortaffil>Hallgató</shortaffil>
            <jobtitle>Hallgató</jobtitle>
            <orgname>Debreceni Egyetem</orgname>
            <orgdiv>PTI</orgdiv>
            <address>
                <email>windsake@mailbox.unideb.hu</email>
                <email>gawnoris@gmail.com</email>
            </address>
        </affiliation>
        <address>
            <street>-</street>
            <city>Debrecen</city>
            <postcode>4028</postcode>
            <country>Magyarország</country>
                <email>windsake@mailbox.unideb.hu</email>
            <otheraddr>
                <link xlink:href="https://web.unideb.hu/~windsake">http://web.unideb.hu/~windsake</link>
            </otheraddr>
        </address>
    </author>    
</authorgroup>               

    <edition xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">BHAX, DEBRECEN, 2019. február 19, v. 0.0.4</edition>               

    <pubdate>2019</pubdate>
    <copyright>
        <year>2019</year>
        <holder>Dr. Bátfai Norbert</holder>
    </copyright>
    <legalnotice>           
        <para>                
            Copyright (C) 2019, Norbert Bátfai Ph.D., batfai.norbert@inf.unideb.hu, nbatfai@gmail.com, 
        </para>
        <para>
            Permission is granted to copy, distribute and/or modify this document
            under the terms of the GNU Free Documentation License, Version 1.3
            or any later version published by the Free Software Foundation;
            with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
            A copy of the license is included in the section entitled "GNU
            Free Documentation License".                
        </para>
        <para>
            <link xlink:href="https://www.gnu.org/licenses/fdl.html">https://www.gnu.org/licenses/fdl.html</link>                
        </para>
            
        <para>
            Engedélyt adunk Önnek a jelen dokumentum sokszorosítására, terjesztésére és/vagy módosítására 
            a Free Software Foundation által kiadott GNU FDL 1.3-as, vagy bármely azt követő verziójának 
            feltételei alapján. Nincs Nem Változtatható szakasz, nincs Címlapszöveg, nincs Hátlapszöveg.                
        </para>
        <para>
            <link xlink:href="http://gnu.hu/fdl.html">http://gnu.hu/fdl.html</link>                
        </para>
    </legalnotice>   
    
    <revhistory xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <revision>
        <revnumber>0.0.1</revnumber>
        <date>2019-02-12</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            Az iniciális dokumentum szerkezetének kialakítása.
        </revremark>
    </revision>
    <revision>
        <revnumber>0.0.2</revnumber>
        <date>2019-02-14</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            Inciális feladatlisták összeállítása.
        </revremark>
    </revision>    
    <revision>
        <revnumber>0.0.3</revnumber>
        <date>2019-02-16</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            Feladatlisták folytatása.
            Feltöltés a BHAX csatorna 
            <link xlink:href="https://gitlab.com/nbatfai/bhax">https://gitlab.com/nbatfai/bhax</link>
            repójába.
        </revremark>
    </revision>
    <revision>
        <revnumber>0.0.4</revnumber>
        <date>2019-02-19</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            Aktualizálás, javítások.
        </revremark>
    </revision>
    <revision>
        <revnumber>0.1.0</revnumber>
        <date>2019-02-26</date>
        <authorinitials>Balázs Tóth</authorinitials>
        <revremark>
            Feladatok elkezdése, chapter 1
        </revremark>
    </revision>
    <revision>
        <revnumber>0.1.1</revnumber>
        <date>2019-03-03</date>
        <authorinitials>Balázs Tóth</authorinitials>
        <revremark>
            Feladatok elkezdése, chapter 2
        </revremark>
    </revision>
    <revision>
        <revnumber>0.1.2</revnumber>
        <date>2019-03-11</date>
        <authorinitials>Balázs Tóth</authorinitials>
        <revremark>
            Feladatok elkezdése, chapter 3
        </revremark>
    </revision>
    <revision>
        <revnumber>0.1.3</revnumber>
        <date>2019-03-18</date>
        <authorinitials>Balázs Tóth</authorinitials>
        <revremark>
            Feladatok elkezdése, chapter 4
        </revremark>
    </revision>
    <revision>
        <revnumber>0.1.4</revnumber>
        <date>2019-03-27</date>
        <authorinitials>Balázs Tóth</authorinitials>
        <revremark>
            Feladatok elkezdése, chapter 5
        </revremark>
    </revision>
    <revision>
        <revnumber>0.1.5</revnumber>
        <date>2019-04-05</date>
        <authorinitials>Balázs Tóth</authorinitials>
        <revremark>
            Feladatok elkezdése, chapter 6
        </revremark>
    </revision>
    <revision>
        <revnumber>0.1.6</revnumber>
        <date>2019-04-12</date>
        <authorinitials>Balázs Tóth</authorinitials>
        <revremark>
            Feladatok elkezdése, chapter 7
        </revremark>
    </revision>
    <revision>
        <revnumber>0.1.7</revnumber>
        <date>2019-04-19</date>
        <authorinitials>Balázs Tóth</authorinitials>
        <revremark>
            Feladatok elkezdése, chapter 8 és olvasónapló
        </revremark>
    </revision>
    <revision>
        <revnumber>0.1.8</revnumber>
        <date>2019-04-26</date>
        <authorinitials>Balázs Tóth</authorinitials>
        <revremark>
            Feladatok elkezdése, chapter 9
        </revremark>
    </revision>
    <revision>
        <revnumber>0.1.9</revnumber>
        <date>2019-04-30</date>
        <authorinitials>Balázs Tóth</authorinitials>
        <revremark>
            Feladatok elkezdése, chapter 10
        </revremark>
    </revision>
    <revision>
        <revnumber>0.2.0</revnumber>
        <date>2019-05-05</date>
        <authorinitials>Balázs Tóth</authorinitials>
        <revremark>
            Feladatok finomítása, bejezezés
        </revremark>
    </revision>
    <revision>
        <revnumber>1.0.1</revnumber>
        <date>2019-09-09</date>
        <authorinitials>Balázs Tóth</authorinitials>
        <revremark>
            Második felvonás elkezdése
        </revremark>
    </revision>
    <revision>
        <revnumber>1.0.2</revnumber>
        <date>2019-09-11</date>
        <authorinitials>Balázs Tóth</authorinitials>
        <revremark>
            Hello Berners beillesztése, arroway inicializálása
        </revremark>
    </revision>
    <revision>
        <revnumber>1.0.3</revnumber>
        <date>2019-09-14</date>
        <authorinitials>Balázs Tóth</authorinitials>

        <revremark>
            Java és C++ könyvek összehasonlításának elkezdése/első oldal megírása</revremark>
    </revision>
	 <revision>
        <revnumber>1.0.4</revnumber>
        <date>2019-09-16</date>
        <authorinitials>Balázs Tóth</authorinitials>
<revremark>összehasonlítás folytatása, python napló elkezdése</revremark>
    </revision>

	<revision>
        <revnumber>1.0.5</revnumber>
        <date>2019-09-24</date>
        <authorinitials>Balázs Tóth</authorinitials>
<revremark>Arroway chapter befejezése</revremark>
    </revision>

	<revision>
        <revnumber>1.0.6</revnumber>
        <date>2019-09-25</date>
        <authorinitials>Balázs Tóth</authorinitials>
<revremark>Liskov chapter elkezdése</revremark>
    </revision>

<revision>
        <revnumber>1.0.7</revnumber>
        <date>2019-10-2</date>
        <authorinitials>Balázs Tóth</authorinitials>
<revremark>Liskov chapter befejezése</revremark>
    </revision>

<revision>
        <revnumber>1.0.8</revnumber>
        <date>2019-10-5</date>
        <authorinitials>Balázs Tóth</authorinitials>
<revremark>Mandelbrot chapter elkezdése</revremark>
    </revision>
    <revision>
        <revnumber>1.0.9</revnumber>
        <date>2019-10-8</date>
        <authorinitials>Balázs Tóth</authorinitials>
<revremark>Mandelbrot chapter befejezése</revremark>
    </revision>
  <revision>
        <revnumber>1.1.0</revnumber>
        <date>2019-10-13</date>
        <authorinitials>Balázs Tóth</authorinitials>
<revremark>chomsky chapter elkezdése</revremark>
    </revision>
 <revision>
        <revnumber>1.1.1</revnumber>
        <date>2019-10-15</date>
        <authorinitials>Balázs Tóth</authorinitials>
<revremark>chomsky chapter befejezése</revremark>
    </revision>

<revision>
        <revnumber>1.1.2</revnumber>
        <date>2019-10-16</date>
        <authorinitials>Balázs Tóth</authorinitials>
<revremark>Gödel és Stroustrup chapterek elkezdése</revremark>
    </revision>
    <revision>
        <revnumber>1.1.3</revnumber>
        <date>2019-10-26</date>
        <authorinitials>Balázs Tóth</authorinitials>
<revremark>Gödel és Stroustrup chapterek befejezése</revremark>
    </revision>
<revision>
        <revnumber>1.1.4</revnumber>
        <date>2019-11-1</date>
        <authorinitials>Balázs Tóth</authorinitials>
<revremark>név nélküli chapter inicializálása</revremark>
    </revision>

<revision>
        <revnumber>1.1.5</revnumber>
        <date>2019-11-3</date>
        <authorinitials>Balázs Tóth</authorinitials>
<revremark>név nélküli chapter kész</revremark>
    </revision>

<revision>
        <revnumber>1.1.6</revnumber>
        <date>2019-11-6</date>
        <authorinitials>Balázs Tóth</authorinitials>
<revremark>Schwarz és Calvin chapterek inicializálása</revremark>
    </revision>

<revision>
        <revnumber>1.1.7</revnumber>
        <date>2019-11-1</date>
        <authorinitials>Balázs Tóth</authorinitials>
<revremark>schwarz chapter elkezdése</revremark>
    </revision>

</revhistory>               
                               
</info>     
        
    <dedication xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <para>

    </para>
<blockquote>
    <attribution>Gregory Chaitin, <citetitle>META MATH! The Quest for Omega</citetitle>, <citation>METAMATH</citation></attribution>
    <para>
        „To me, you understand something only if you can program it.  
        (You, not someone else!)  Otherwise you don’t really understand it, 
        you only think you understand it.”
    </para>
</blockquote>
</dedication>     
    
    <preface xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Előszó</title>
    <para xml:id="bhax-textbook-pre.Eloszo">
        Amikor programozónak terveztem állni, ellenezték a környezetemben, mondván, hogy kell  
        szövegszerkesztő meg táblázatkezelő, de az már van... nem lesz programozói munka.
    </para>                 
    <para>
        Tévedtek. Hogy egy generáció múlva kell-e még tömegesen hús-vér programozó vagy
        olcsóbb lesz allokálni igény szerint pár robot programozót a felhőből?
        A programozók dolgozók lesznek vagy papok?
        Ki tudhatná ma. 
    </para>
    <para>
        Mindenesetre a programozás a teoretikus kultúra csúcsa. A GNU mozgalomban látom annak 
        garanciáját, hogy ebben a szellemi kalandban a gyerekeim is részt vehessenek majd. Ezért programozunk.
    </para>          
    <section>
        <title>Hogyan forgasd</title>
        <para>
            A könyv célja egy stabil programozási szemlélet kialakítása az olvasóban. Módszere, hogy hetekre 
            bontva ad egy tematikus feladatcsokrot. Minden feladathoz megadja a megoldás forráskódját és forrásokat
            feldolgozó videókat.
            Az olvasó feladata, hogy ezek tanulmányozása után maga adja meg a feladat megoldásának lényegi
            magyarázatát, avagy írja meg a könyvet.
        </para>
        <para>
            Miért univerzális? Mert az olvasótól (kvázi az írótól) függ, hogy kinek szól a könyv. 
            Alapértelmezésben gyerekeknek, mert velük készítem az iniciális változatot. 
            Ám tervezem felhasználását az egyetemi programozás oktatásban is. Ahogy szélesedni tudna a 
            felhasználók köre, akkor lehetne kiadása különböző korosztályú gyerekeknek, családoknak, 
            szakköröknek, programozás kurzusoknak, felnőtt és továbbképzési műhelyeknek és sorolhatnánk... 
        </para>
        <section>
            <title>Milyen nyelven nyomjuk?</title>
            <para>
                C (mutatók), C++ (másoló és mozgató szemantika) és Java (lebutított C++) nyelvekből kell egy jó alap, 
                ezt kell kiegészíteni pár R (vektoros szemlélet), Python (gépi tanulás bevezető), Lisp és Prolog (hogy lássuk
                mást is) példával.
            </para>
        </section>
        <section>
            <title>Hogyan nyomjuk?</title>
            <para>
                Rántsd le a <link xlink:href="https://gitlab.com/nbatfai/bhax">https://gitlab.com/nbatfai/bhax</link>
                git repót, vagy méginkább forkolj belőle magadnak egy sajátot a GitLabon, ha már saját könyvön dolgozol!
            
                <screen><![CDATA[]]></screen> 
            
            </para>
            <para>
                Ha megvannak a könyv DocBook XML forrásai, 
                akkor az alább látható <command>make</command> parancs ellenőrzi, hogy „jól formázottak” és 
                „érvényesek-e” ezek az XML források, majd 
                elkészíti a <application>dblatex</application> programmal a könyved pdf változatát, íme:
                <screen><![CDATA[batfai@entropy:~$ cd glrepos/bhax/thematic_tutorials/bhax_textbook/
batfai@entropy:~/glrepos/bhax/thematic_tutorials/bhax_textbook$ make
rm -f bhax-textbook-fdl.pdf
xmllint --xinclude bhax-textbook-fdl.xml --output output.xml
xmllint --relaxng http://docbook.org/xml/5.0/rng/docbookxi.rng output.xml --noout
output.xml validates
rm -f output.xml	
dblatex bhax-textbook-fdl.xml -p bhax-textbook.xls
Build the book set list...
Build the listings...
XSLT stylesheets DocBook - LaTeX 2e (0.3.10)
===================================================
Stripping NS from DocBook 5/NG document.
Processing stripped document.
Image 'dblatex' not found
Build bhax-textbook-fdl.pdf
'bhax-textbook-fdl.pdf' successfully built]]></screen>             

            Ha minden igaz, akkor most éppen ezt a legenerált <filename>bhax-textbook-fdl.pdf</filename> fájlt olvasod.
            </para>
<tip>
              <title>A DocBook XML 5.1 új neked?</title>
              <para>
                  Ez esetben forgasd a <link xlink:href="https://tdg.docbook.org/tdg/5.1/">https://tdg.docbook.org/tdg/5.1/</link>
                  könyvet, a végén találod az informatikai szövegek jelölésére használható gazdag „API” elemenkénti
                  bemutatását.                  
              </para>            
            </tip>            
        </section>
        
    </section>            

</preface> 

    <!-- 
        <xi:include href="bhax-textbook-glossary.xml">
            <xi:fallback>
                <para>
                    <emphasis>XInclude: bhax-textbook-glossary.xml file not found</emphasis>
                </para>
            </xi:fallback>
        </xi:include> 
    -->

    <part xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Bevezetés</title>
    <partintro>
        <para> 
        </para>
    </partintro>
    <chapter>
        <info>
            <title>Vízió</title>
            <keywordset>
                <keyword/>
            </keywordset>
        </info>
        <section>
            <title>Mi a programozás?</title>
            <para>                  
                          
            </para>
        </section>
        <section>
            <title>Milyen doksikat olvassak el?</title>
            <itemizedlist>
                <listitem>
                    <para>Olvasgasd a kézikönyv lapjait, kezd a <command>man man</command> parancs kiadásával. A C programozásban
                    a 3-as szintű lapokat fogod nézegetni, például az első feladat kapcsán ezt a 
                    <command>man 3 sleep</command> lapot</para>                        
                </listitem>
                <listitem>
                    <para><citation>KERNIGHANRITCHIE</citation></para>                        
                </listitem>
                <listitem>
                    <para><citation>BMECPP</citation></para>                        
                </listitem>
                <listitem>
                    <para>Az igazi kockák persze csemegéznek a C nyelvi szabvány 
                        <link xlink:href="https://web.archive.org/web/20181230041359if_/http://www.open-std.org/jtc1/sc22/wg14/www/abq/c17_updated_proposed_fdis.pdf">ISO/IEC 9899:2017</link> kódcsipeteiből is.
                    </para>                        
                </listitem>
            </itemizedlist>            
        </section>
        <section>
            <title>Milyen filmeket nézzek meg?</title>
            <itemizedlist>
                <listitem>
                    <para>21 - Las Vegas ostroma, 
                        <link xlink:href="https://www.imdb.com/title/tt0478087/">https://www.imdb.com/title/tt0478087/</link>,
                        benne a <link xlink:href="#bhax-textbook-feladatok-turing.MontyHall">Monty Hall probléma</link> bemutatása.
                    </para>                        
                </listitem>
            </itemizedlist> 
        </section>
    </chapter>                
</part> 

    <part xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Tematikus feladatok</title>
    <partintro>
        <para> 
        </para>
<tip>
              <title>Bátf41 Haxor Stream</title>
              <para>
                  A feladatokkal kapcsolatos élő adásokat sugároz
                  a <link xlink:href="https://www.twitch.tv/nbatfai">https://www.twitch.tv/nbatfai</link> csatorna,
                  melynek permanens archívuma a <link xlink:href="https://www.youtube.com/c/nbatfai">https://www.youtube.com/c/nbatfai</link> 
                  csatornán található.
              </para>            
            </tip>    
        
    </partintro>
    
    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Turing!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Végtelen ciklus</title>
        <para>
            Írj olyan C végtelen ciklusokat, amelyek 0 illetve 100 százalékban dolgoztatnak egy magot és egy olyat, amely  
            100 százalékban minden magot!
        </para>
        <para>
            Megoldás videó: <link xlink:href=" https://github.com/ghjbku/DE/blob/master/video.flv"> https://github.com/ghjbku/DE/blob/master/video.flv</link>
        </para>
        <para>
          Megoldás forrása:
			</para>
			<para>
Elsőként a 100%-os végtelen ciklust készítettem el, hiszen ezt volt a legegyszerűbb megírni.
Amint láthatjuk elég egyszerűen meg lehet oldani, hogy a cpu 100%-ban dolgozzon a program futása alatt. 
Itt én a WHILE ciklus-t választottam, de FOR-ral is hasonlóképpen lehet megvalósítani a végtelenítést.
Az egész program lényege egyetlen értéken alapszik, amit az *asd* változó hordoz.
Mivel ez a változó semmiképp sem kap 1-et értékül, a program soha sem fog kilépni a ciklusból.
<programlisting language="c"><![CDATA[
//100%-ban megdolgoztat egy magot
//lefordítás: gcc forrásnév -o késznév
#include <stdio.h>
int main()
{
int asd =0;
while (asd=1){}
return 0;
}]]>
</programlisting>A következő program a 0%-os végtelen ciklus volt. Ha ismerjük az API-t, vagy tapraesettek vagyunk a google-n való keresést illetően, akkor itt is egyszerű dolgunk volt.
Amint azt észrevehettük, a programkód nagyon hasonlít az előző kódra, csupán annyi változás történt, hogy a ciklus belsejében megjelent egy függvény, a *sleep()*.
Ez a függvény annyi milisecond-ig állítja meg a programot, amely számot a két zárójel közé írtunk. Jelen esetben ez *1*, de mivel egy végtelen ciklusban vagyunk, ezért végtelen sokszor vár majd 1 milisec-ot a program, így tehát nem használ erőforrást.<programlisting language="c">
<![CDATA[
//0%-os cpu használat
//lefordítás: gcc forrásnév -o késznév
#include <stdio.h>
int main()
{
int asd =0;
while (asd=1)
{
sleep(1);
}
return 0;
}     
]]> 
</programlisting>Utolsóként pedig jön a "legnehezebb", minden magot 100%-on futtatni.
Az igazat megvallva, ez sem valami nagy ördöngősség, itt is csak egy pár dolog változott a legelső programhoz képest.
A legfontosabb dolog ez a sor *#include "omp.h"*, ez a header fájl előfeltétele annak, hogy a *#pragma omp parallel* kódot értelmezni tudja a fordítóprogram.
A *#pragma...* sor veszi rá a programunkat, hogy párhuzamos módon, az összes magon futtassa a programot a számítógép.<programlisting language="c">
<![CDATA[//minden mag 100%-on fut
//lefordítás: gcc -fopenmp forrásnév -o késznév
#include <stdio.h>
#include <unistd.h>
#include "omp.h"
int main () {
int asd=0;

#pragma omp parallel
	while(asd=1)
	{
	}
   return 0;
}  
]]> 
</programlisting>
         
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...			
			</para><para>
			Amint láthattuk, elég egyszerű dolgunk volt ezen programok megírását illetően, viszont ez nem azt jelenti, hogy félválról vehetjük a programozást,
			hiszen kevés olyan program létezik, aminek valamilyen hétköznapi haszna van, és mégis ilyen egyszerű lenne megírni.
			Ezen programkódok csak az egyszerűbb megértést segítik elő, gyakorlati hasznuk sajnos nincs.
        </para>            
    </section>        
        
    <section>
        <title>Lefagyott, nem fagyott, akkor most mi van?</title>
        <para>
            Mutasd meg, hogy nem lehet olyan programot írni, amely bármely más programról eldönti, hogy le fog-e fagyni vagy sem!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása:  tegyük fel, hogy akkora haxorok vagyunk, hogy meg tudjuk írni a <function>Lefagy</function>
            függvényt, amely tetszőleges programról el tudja dönteni, hogy van-e benne vlgtelen ciklus:              
        </para>
        <programlisting language="c"><![CDATA[Program T100
{

	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}

	main(Input Q)
	{
		Lefagy(Q)
	}
}]]></programlisting>            
        <para>
            A program futtatása, például akár az előző <filename>v.c</filename> ilyen pszeudókódjára:
            <screen><![CDATA[T100(t.c.pseudo)
true]]></screen>            
            akár önmagára
            <screen><![CDATA[T100(T100)
false]]></screen>  
            ezt a kimenetet adja.          
        </para>
        <para>
            A T100-as programot felhasználva készítsük most el az alábbi T1000-set, amelyben a
            Lefagy-ra épőlő Lefagy2 már nem tartalmaz feltételezett, csak csak konkrét kódot:
        </para>
        <programlisting language="c"><![CDATA[Program T1000
{

	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}

	boolean Lefagy2(Program P)
	{
		 if(Lefagy(P))
			return true;
		 else
			for(;;); 
	}

	main(Input Q)
	{
		Lefagy2(Q)
	}

}]]></programlisting>            
        <programlisting><![CDATA[]]></programlisting>            
        <para>
            Mit for kiírni erre a <computeroutput>T1000(T1000)</computeroutput> futtatásra?
                                
            <itemizedlist>
                <listitem>
                    <para>Ha T1000 lefagyó, akkor nem fog lefagyni, kiírja, hogy true</para>                        
                </listitem>
                <listitem>
                    <para>Ha T1000 nem fagyó, akkor pedig le fog fagyni...</para>                        
                </listitem>
            </itemizedlist>
            akkor most hogy fog működni? Sehogy, mert ilyen <function>Lefagy</function>
            függvényt, azaz a T100 program nem is létezik.                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>
        Amint láthatjuk, lehetetlen olyan programot írni, amely egy másik programról eldöntené, hogy az le fog-e fagyni, vagy sem.
        </para>
    </section>        
                
    <section>
        <title>Változók értékének felcserélése</title>
        <para>
            Írj olyan C programot, amely felcseréli két változó értékét, bármiféle logikai utasítás vagy kifejezés
            nasználata nélkül!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk">https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk</link>
        </para>
        <para>
            Megoldás forrása:</para><para> 
		Ezen feladat megoldása igencsak egyszerűnek bizonyult.Na persze nem annyira egyszerű, mint egy végtelen ciklus megírása, de közel azonos szinten mozognak.
		A lentebb lévő forráskód elég egyszerűen értelmezhető, ezért hát nem megyek bele részletesen, csak a nagyon fontos dolgokat mondom el.
		A *C* nyelvben a változók értékét egy paranccsal tudjuk hozzáfűzni egy printf függvényhez, attól függően, hogy milyen típusú adatot hordoz a változó.
		Esetünkben mindkét változó *szám/Digit* típust hordoz, ezért a kód, amivel meghívjuk a behelyettesítő paramétert, ez lesz: * %d *, majd ha végeztünk a kiírni kívánt szöveggel, egy vesszővel jelezzük a fordítóprogramnak, hogy most a behelyettesítendő változók következnek.
		A kódban megjelenik egy másik kód is, ami ismeretlen lehet az olvasó számára, ez a * \n * , amely annyit tesz, hogy új sorba kezdi az *n* után beírt szöveget, és a szóközt is értelmezi!
			<programlisting language="c"><![CDATA[#include <stdio.h>
int main()
{
int a=5,b=3;
printf("A value = %d\n",a);
printf("B value = %d\n",b);
b=b-a;
a=a+b;
b=a-b;
printf("A value = %d\n",a);
printf("B value = %d\n",b);
return 0;
}]]></programlisting>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
		<para>Ne tévesszen meg bennünket a feladat komplexitása, ha nem gondolunk bele, hogy pontosan hogyan is kellene segédváltozó nélkül elérni céljainkat, elég sokáig el tudunk időzni ezen az egyszerű feladaton.
		Tehát próbáljunk meg minden feladatot úgy kezdeni, hogy elgondolkozunk azon, hogyan tudnánk megvalósítani a feladatban megírtakat.</para>
    </section>                     

    <section>
        <title>Labdapattogás</title>
        <para>
        <command>Tutoráltam:Nagy Krisztinánt</command>
            Először if-ekkel, majd bármiféle logikai utasítás vagy kifejezés
            nasználata nélkül írj egy olyan programot, ami egy labdát pattogtat a karakteres konzolon! (Hogy mit értek
            pattogtatás alatt, alább láthatod a videókon.)
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/08/28/labdapattogas">https://bhaxor.blog.hu/2018/08/28/labdapattogas</link>
        </para>
        <para>
            Megoldás forrása:  </para>
			<para>A feladat nehézségi szintjét tekintve már egy magassabb szinten van, vagyis inkább, gondolkodást igényel.
			Ebben a forráskódban már megjelenik egy pár új parancs, melyeket eddig még nem láttunk.
			Kezdve az új Header fájllal, a <![CDATA[<math.h>]]> fájllal, amely a matematikai függvényekért felel és minden értéket double típussal kezel(double típust kér, és azt ad vissza), ilyen függvény például az *abs*, amely az abszolút értéket jelöli,
			de ebben a header fájlban található a *pow* és az *sqrt* is, az előbbi a hatványozást, míg utóbbi a négyzetgyököt kezeli.
			Aztán ott van az a furcsa sor két sorral alább, az a bizonyos *#define*... ezeket a sorokat úgynevezett "Nevesített konstansok" definiálásánál használjuk.
			Ezek a konstansok értéket nem változtatnak a program futása során, és bármilyen értéket adhatunk nekik.
			<programlisting language="c"><![CDATA[
//Labdapattogás if nélkül (mentorálva Gila Attila által)
#include<stdio.h>
#include<math.h>

#define szel 80  
#define mag 24

int putX(x,y)
{
int ix,iy;

for(ix=0;ix<x;ix++)
printf("\n");

for(iy=0;iy<y;iy++)
printf(" ");

printf("O\n");

return 0;
}

int main()
{
long int x=0,y=0;

while(1)
{
system("clear");
putX(abs(mag-(x++%(mag*2))),abs(szel-(y++%(szel*2))));
usleep(15000);
}

return 0;
} 
]]></programlisting>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para><para>A labda "pattogása" egyszerű módon van megoldva, miszerint minden egyes "tick" után, amit a program a végtelen ciklusban tölt, a *system("clear")* parancs miatt a terminál jelenlegi tartalma törlődik, de mivel az túl gyorsan történik, mi csak úgy érezzük, hogy a labda szépen mozog az ablakban.
		a "tick" periódust az *usleep()* függvény zárójelében megadott szám határozza meg, a mértékegység microsecond.
		Viszont ha fontos a pontosság, akkor számolnunk kell a számítógép kalkulációs képességeivel, plusz az is időbe telik, hogy a program eljut az *usleep* függvényhez, ezután az egész program "alvó" állapotba kerül, kilép a processor ütemezési sorából, és a delay attól is függhet, hogy a processor maga mikor válassza újra a programot, miután a *usleep* függvény lefutott.
		Tehát ne lepődjünk meg, ha néhány ezer microsec-ot téved a program.</para>
    </section>                     

    <section>
        <title>Szóhossz és a Linus Torvalds féle BogoMIPS</title>
        <para>
            Írj egy programot, ami megnézi, hogy hány bites a szó a gépeden, azaz mekkora az <type>int</type> mérete.
            Használd ugyanazt a while ciklus fejet, amit Linus Torvalds a BogoMIPS rutinjában! 
        </para>
        <para>
            Megoldás videó: <link xlink:href=""/>
        </para>
        <para>
        <command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása: <link xlink:href="https://github.com/ghjbku/DE/blob/cpp/bitshift.cpp"/>
        </para>
		<para>A feladat megoldása C++ nyelven történt, viszont C-ben is hasonló módon kell megoldani a problémát.
		<programlisting language="c"><![CDATA[//a bitshift C nyelvben
#include <stdio.h>

int main(){

	unsigned int the_Bit = 1;
	int length = 0;

	do
		length++;
	while((the_Bit <<= 1));

	printf("A szóhossz mérete: %u\n", length);

	return 0;
}]]></programlisting>
A C megoldás BogoMIPS-el: <link xlink:href="https://github.com/ghjbku/DE/blob/master/c%20cuccok/szohossz.c">itt található</link>
		</para>
        <para>
            Tanulságok, tapasztalatok, magyarázat... 
        </para>
        <para>
        A bit méretét a <command>length</command> változó tárolja, amit úgy töltünk fel, hogy amíg a bit el nem éri a kezdési értéket, addig a ciklusban mingíg növeljük a változó értékét 1-el.
        Majd ezen értéket a végén kiírjuk.
        Az unsigned típus 2<superscript>n</superscript> különböző értéket vehet fel 0 és n között.
        </para>
    </section>                     

    <section>
        <title>Helló, Google!</title>
        <para>
            Írj olyan C programot, amely egy 4 honlapból álló hálózatra kiszámolja a négy lap Page-Rank 
            értékét!
        </para>
        <para>
            Megoldás videó: <link xlink:href=""/>
        </para>
        <para>
        <command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása C++-ban: <link xlink:href="https://github.com/ghjbku/DE/blob/cpp/bearazas.cpp"/>
            és C-ben: <link xlink:href="https://github.com/ghjbku/DE/blob/master/c%20cuccok/bearaz.c"/>
        </para>
        <para>
        <programlisting language="c"><![CDATA[
#include <stdio.h>
#include <math.h>

void
kiir (double tomb[], int db)
{
int i;
for (i=0; i<db; i++)
printf("PageRank [%d]: %lf\n", i, tomb[i]);
}

double tavolsag(double pagerank[],double pagerank_temp[],int db)
{
double tav = 0.0;
int i;
for(i=0;i<db;i++)
tav +=abs(pagerank[i] - pagerank_temp[i]);
return tav;
}

int main(void)
{
double L[4][4] = {
{0.0, 0.0, 1.0 / 3.0, 0.0},
{1.0, 1.0 / 2.0, 1.0 / 3.0, 1.0},
{0.0, 1.0 / 2.0, 0.0, 0.0},
{0.0, 0.0, 1.0 / 3.0, 0.0}
};

double PR[4] = {0.0, 0.0, 0.0, 0.0};
double PRv[4] = {1.0 / 4.0, 1.0 / 4.0, 1.0 / 4.0, 1.0 / 4.0};

long int i,j,h;
i=0; j=0; h=5;

for (;;)
{
for(i=0;i<4;i++)
PR[i] = PRv[i];
for (i=0;i<4;i++)
{
double temp=0;
for (j=0;j<4;j++)
temp+=L[i][j]*PR[j];
PRv[i]=temp;
}

if ( tavolsag(PR,PRv, 4) < 0.00001)
break;
}
kiir (PR,4);
return 0;

} 
]]></programlisting>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...

        </para>
        <para>A pagerank algoritmust a google fejlesztette ki azzal a céllal, hogy a weboldalak minőségét rangsorolja.</para>
   <para>A feladat komplexitása miatt a soronkénti értelemzést választottam.Kezdjük is el.</para>
   <programlisting language="c"><![CDATA[void
kiir (double tomb[], int db)
{
int i;
for (i=0; i<db; i++)
printf("PageRank [%d]: %lf\n", i, tomb[i]);
}]]>
   </programlisting>
    <para>Ez a függvény a minsősítés végeredményét fogja kiírni.
    Egy egyszerű for ciklusból áll, amely a függvényparaméterként megadott <command>db</command>-szor fog lefutni és kiírja az ugyancsak függvényparaméterből származó <command>tomb[]</command> tömb elemeit.</para>
    <programlisting language="c"><![CDATA[
double tavolsag(double pagerank[],double pagerank_temp[],int db)
{
double tav = 0.0;
int i;
for(i=0;i<db;i++)
tav +=abs(pagerank[i] - pagerank_temp[i]);
return tav;
}
]]></programlisting>
     <para>Ez a következő függvény már bonyolultabb.A függvényünk két double típusú tömböt és egy számot kér paraméterül.
     A távolság kiszámítására itt is egy for-ciklus lesz segítségünkre, azon belűl pedig egy abszolútérték függvény, amelyben a <command>pagerank</command> tömbből kivonjuk a <command>pagerank_temp</command> tömböt.</para>
     <programlisting language="c"><![CDATA[int main(void)
{
double L[4][4] = {
{0.0, 0.0, 1.0 / 3.0, 0.0},
{1.0, 1.0 / 2.0, 1.0 / 3.0, 1.0},
{0.0, 1.0 / 2.0, 0.0, 0.0},
{0.0, 0.0, 1.0 / 3.0, 0.0}
};

double PR[4] = {0.0, 0.0, 0.0, 0.0};
double PRv[4] = {1.0 / 4.0, 1.0 / 4.0, 1.0 / 4.0, 1.0 / 4.0};

long int i,j,h;
i=0; j=0; h=5;
]]></programlisting>
      <para>Amint láthatjuk, a main függvényen belül elkezdjük definiálni a változókat, melyeket az előbbi két függvényre majd ráeresztünk.
      </para>
      <programlisting language="c"><![CDATA[
for (;;)
{
 for(i=0;i<4;i++)
 PR[i] = PRv[i];
  for (i=0;i<4;i++)
  {
  double temp=0;
    for (j=0;j<4;j++)
    temp+=L[i][j]*PR[j];
    PRv[i]=temp;
  }

if ( tavolsag(PR,PRv, 4) < 0.00001)
break;
}
kiir (PR,4);
return 0;
]]></programlisting>
    <para>Továbbra is a main függvényben vagyunk. Már megtörtént a változó deklarálás, tehát elkezdődhet a rangsorolás.
    Belépünk egy for-ciklusba, majd azon belűl rétegezve létrehozunk még 3 másik for-ciklust.
    Az első réteg a <command>PR</command> tömböt azonosítja a <command>PRv</command> tömbbel.
    A második réteg egy <command>temp</command> változóban összeszorozza az <command>L[][]</command> kétdimenziós tömböt és az újonan kapott <command>PR</command> tömböt.
    Majd minden ciklus végén hozzáadja az új értékeket az előző értékhez.
    Ezután a <command>PRv</command> tömb értékéül adjuk a temp változót.
    ezután visszatérünk az első for-ciklusba, ahol pedig egy if elágazással megnézzük, hogy a <command>tavolsag()</command> függvény visszatérési értéke kissebb-e, mint 0.00001
    . Ha igen, akkor kilép a ciklusból.
    A program a végén kiírja a <command>PR</command> tömb tartalmát a <command>kiir()</command> függvény segítségével.</para>
    </section>

    <section xml:id="Brun">
        <title>100 éves a Brun tétel</title>
        <para>
            Írj R szimulációt a Brun tétel demonstrálására!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/xbYhp9G6VqQ">https://youtu.be/xbYhp9G6VqQ</link>
        </para>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R">https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R</link>
        </para>
        <programlisting language="r"><![CDATA[library(matlab)

stp <- function(x){

    primes = primes(x)
    diff = primes[2:length(primes)]-primes[1:length(primes)-1]
    idx = which(diff==2)
    t1primes = primes[idx]
    t2primes = primes[idx]+2
    rt1plust2 = 1/t1primes+1/t2primes
    return(sum(rt1plust2))
}

x=seq(13, 1000000, by=10000)
y=sapply(x, FUN = stp)
plot(x,y,type="b")
]]></programlisting>
       <para>A Brun tétel az ikerprímekkel foglalkozik, és kimondja, hogy ezen prímek reciprokösszege egy véges értékhez konvergál, ún. Brun-konstans felé.
       jelölése: <command>B<subscript>2</subscript></command></para>
       <para>Mivel az R nyelvben még gyakorlatlanok vagyunk, így megint soronként fogok magyarázatot adni a forráskódra.
       </para>
       <programlisting language="r"><![CDATA[library(matlab)

stp <- function(x){

    primes = primes(x)
    diff = primes[2:length(primes)]-primes[1:length(primes)-1]
    idx = which(diff==2)
    t1primes = primes[idx]
    t2primes = primes[idx]+2
    rt1plust2 = 1/t1primes+1/t2primes
    return(sum(rt1plust2))
}
]]></programlisting>
 <para>A library(matlab) paranncsal meghívjuk a matlab külső fájlt, amelyben egyéb függvények mellett megtalálható a <command>primes()</command> függvény.
Ez a függvény a paraméterként megadott számig kiszámolja a prímszámokat. 
R-ben a függvény létrehozása így történik:</para>
<para><![CDATA[függvénynév <- function(paraméter lista){függvény törzs
return(visszatérési érték)} ]]></para>
<para>az első sorban feltöltjük a primes változót a <command>primes(x)</command> függvény értékeivel.
majd a második sorban a diff változóba belerakjuk nd&gt; és a <command>primes[1:length(primes)-1]</command> vektorok különbségét.
</para>
<para>a <command>primes[2:length(primes)]</command> vektor a primes 2. elemétől a változó hosszáig tartalmazza a számokat.
Ezzel szemben a <command>primes[1:length(primes)-1]</command> rész a primes 1. elemétől az utolsó előtti elemig tartalmazza a számokat.
Ezeket kivonva megkapjuk a prímszámok különbségét.
Ha ez a külnbség 2, akkor beszélünk ikerprímekről.
Azt, hogy a különbség 2-e, az idx változó nézi meg, majd az indexüket eltárolja.</para>
<para>a t1primes változó tartalmazza azokat a prímeket, amelyeknek a helyét már meghatároztuk az idx változóban.
Tehát az ikerprímek első fele.
A t2primes viszont nem szimplán a primes[idx]-et adja vissza, hiszen az az ikrek első fele lenne, de tudjuk, hogy a különbség a kettő prím között 2, tehát a másik felét úgy kapjuk meg, ha hozzáadunk az [idx] helyen álló számhoz 2-őt.
</para>
<para>Az rt1plust2 változóban összeadjuk a t1 és a t2 reciprokait.
majd végezetül visszaadjuk a return()-ben a reciprokértékek összegét.</para>   
 </section>
    
    <section xml:id="bhax-textbook-feladatok-turing.MontyHall">
        <title>A Monty Hall probléma</title>
        <para>
            Írj R szimulációt a Monty Hall problémára!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan">https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan</link>
        </para>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/MontyHall_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/MontyHall_R</link>
        </para>
        <para><programlisting language="r">
        <![CDATA[kiserletek_szama=10000000
kiserlet = sample(1:3, kiserletek_szama, replace=T)
jatekos = sample(1:3, kiserletek_szama, replace=T)
musorvezeto=vector(length = kiserletek_szama)

for (i in 1:kiserletek_szama) {

    if(kiserlet[i]==jatekos[i]){
    
        mibol=setdiff(c(1,2,3), kiserlet[i])
    
    }else{
    
        mibol=setdiff(c(1,2,3), c(kiserlet[i], jatekos[i]))
    
    }

    musorvezeto[i] = mibol[sample(1:length(mibol),1)]

}

nemvaltoztatesnyer= which(kiserlet==jatekos)
valtoztat=vector(length = kiserletek_szama)

for (i in 1:kiserletek_szama) {

    holvalt = setdiff(c(1,2,3), c(musorvezeto[i], jatekos[i]))
    valtoztat[i] = holvalt[sample(1:length(holvalt),1)]
    
}

valtoztatesnyer = which(kiserlet==valtoztat)


sprintf("Kiserletek szama: %i", kiserletek_szama)
length(nemvaltoztatesnyer)
length(valtoztatesnyer)
length(nemvaltoztatesnyer)/length(valtoztatesnyer)
length(nemvaltoztatesnyer)+length(valtoztatesnyer)
]]>
        </programlisting></para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
            </para><para>a kísérlet változóban található a nyeremény helye,
            a játékos változóban található a játékos által választott ajtó.
            Az első for ciklusban megnézzük, hogy a játékos eltalálta-e a helyes ajtó számát, és a műsorvezető ezen feltételtől függően választ ajtót magának.
            Ha eltalálta, akkor a műsorvezető véŁetlenszerűen választ a két üres ajtó közül.
            Viszont ha nem találta el a játékos, akkor a vezető csak 1 ajtót választhat, hiszen nem nyithatja ki a nyereményt, se a játékos által választott ajtót.
        </para>
        <para/>
    </section>

</chapter>     
    
    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chomsky!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Decimálisból unárisba átváltó Turing gép</title>
        <para>
            Állapotátmenet gráfjával megadva írd meg ezt a gépet!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <figure>
            <title>Az <type> átváltó</type> Turing gép</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="elmélet/unar_dec.png" scale="70"/>
                </imageobject>
                <textobject>
                    <phrase>Az <type> átváltó</type> Turing gép</phrase>
                </textobject>
            </mediaobject>
        </figure>    
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>Az átváltó bekér egy Decimális számot, legyen ez egy tetszőleges szám, és nevezzük el N-nek.
        Ezután egy képlettel átváltja azt Unáris számrendszerbe.
        Ez a képlet a következő: <command>unar=egysegelem*N</command>
        majd "kirajzolja" az eredményt.</para>
    </section>        
        
    <section>
        <title>Az a<superscript>n</superscript>b<superscript>n</superscript>c<superscript>n</superscript> nyelv nem környezetfüggetlen</title>
        <para>
            Mutass be legalább két környezetfüggő generatív grammatikát, amely ezt a nyelvet generálja!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:    <link xlink:href="https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog1_1.pdf?fbclid=IwAR2APDrK-Cky5lqHy_fCBzTZ_9fEhFCRuHHHExeK3WUQuOfzcUSfeVbNfqI">A lentebb látható képek itt megtalálhatóak a 30. oldalon</link>   
        </para>
        <figure>
            <title>A <type> környezetfüggő</type> grammatikák</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="elmélet/nyelvosztaly.png" scale="40"/>
                </imageobject>
                <textobject>
                    <phrase>Környezetfüggés két példában</phrase>
                </textobject>
            </mediaobject>
        </figure>  
        <para>
            Tanulságok, tapasztalatok, magyarázat...
       </para>
       <para>A konstansok és változók alatt helyezkednek el a helyettesítési szabályok.
       Ezeket a szabályokat alkalmazva addig változtatjuk a megadott szót, amíg a szó maga már csak konstansokból áll.
       Mivel nincs olyan lehetőség, hogy a szó csak változókból áll, ezért a nyelvezet nem lehet környezetfüggetlen.</para>
       <para>Környezetfüggő(hossznemcsökkentő)</para><para>P1XP2 → P1QP2, P1, P2 eleme (VN U VT)*, X VN beli, Q (VN U VT)+ beli, kivéve S → üres, de akkor S nem lehet jobb oldali egyetlen szabályban sem, tehát Az a<superscript>n</superscript>b<superscript>n</superscript>c<superscript>n</superscript> nyelv nem környezetfüggetlen
        </para>
        <para/>
    </section>        
                
    <section>
        <title>Hivatkozási nyelv</title>
        <para>
            A <citation>KERNIGHANRITCHIE</citation> könyv C referencia-kézikönyv/Utasítások melléklete alapján definiáld 
            BNF-ben a C utasítás fogalmát!
            Majd mutass be olyan kódcsipeteket, amelyek adott szabvánnyal nem fordulnak (például C89), mással (például C99) igen.
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása:  
        </para>
        <para>
        <programlisting language="c"><![CDATA[#include <stdio.h>

int main()
{
	int inline asdfunc(int a)
	{
	int b = a*a;
	a=b*a;
	return a;
	}

asdfunc(5);
return 0;
}]]></programlisting>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>
        <link xlink:href="https://github.com/ghjbku/DE/blob/master/c%20cuccok/Bildschirmfoto%20von%202019-03-12%2011-35-07.png"/>
        Amint láthatjuk, a funkcíó minden gond nélkül lefordul C99-ben, míg C89-ben hibát észlel.
        A hiba az *inline* parancs miatt van.
        ez a cmd a C99-el jött be, amely általában *extern inline* -al párban jelenik meg egy programkódban.
        Segítségével egy program nagyobb sebességre képes, viszont ezért cserébe nagyobb a helyigénye.
        Az inline függvények a sorba illesztődnek be, ha arra szükség van, így jön létre a nagyobb sebesség.
        </para>
    </section>                     

    <section>
        <title>Saját lexikális elemző</title>
        <para>
            Írj olyan programot, ami számolja a bemenetén megjelenő valós számokat! 
            Nem elfogadható olyan megoldás, amely maga olvassa betűnként a bemenetet, 
            a feladat lényege, hogy lexert használjunk, azaz óriások vállán álljunk és ne kispályázzunk!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/9KnMqrkj_kU">https://youtu.be/9KnMqrkj_kU</link> (15:01-től).
        </para>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása: <link xlink:href="Chomsky/realnumber.l">
                <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Chomsky/realnumber.l</filename>
            </link> 
       
        <programlisting language="c"><![CDATA[
        //lex fájl
        //fordítás c-re : lex -o output.c lexfajl.l (szükséges hozzá a flex)
        //jelen esetben: lex -o realnumbers.c realnumbers.l
%{
#include <stdio.h>
int realnumbers = 0;
%}
digit	[0-9]
%%
{digit}*(\.{digit}+)?	{++realnumbers; 
    printf("[realnum=%s %f]", yytext, atof(yytext));}
%%
int
main ()
{
 yylex ();
 printf("The number of real numbers is %d\n", realnumbers);
 return 0;
}
]]></programlisting>
<link xlink:href="https://github.com/ghjbku/DE/blob/master/c%20cuccok/realnumber.c">a C-re fordított program</link>
 ha készen van a fordítás, akkor mondhatjuk a gcc-nek, hogy csináljon nekünk futtatható programot a c forrásból.
 Ezt a következő sor beírásával tehetjük meg: 
 * gcc realnumber.c -o realnumber -lfl *     
         </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>Ebben a feladatban kicsit eltértünk a megszokott dolgoktól, ugyanis nem mi írtuk meg a C forráskódot, hanem a lexer.
        Ez nagyban megkönnyíti a dolgunkat, hiszen ha megnézzük a C forrást, amit a lex elkészített helyettünk, láthatjuk, hogy nem éppen egy rövid kis kódsorozatról van szó
        A lexer segítségével nekünk már csak annyi a dolgunk,hogy megmondjuk neki, milyen típust keressen az inputban"digit[0-9]", és hogyan ismerje azt fel " {digit}*(\.{digit}+)? "</para>
    </section>                     

    <section>
        <title>Leetspeak</title>
        <para>
            Lexelj össze egy l33t ciphert!
        </para>
        <para><command>Tutoráltam: Zsolt Schachinger-t</command>
            Megoldás videó: <link xlink:href="https://youtu.be/06C_PqDpD_k">https://youtu.be/06C_PqDpD_k</link>
        </para>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása: <link xlink:href="Chomsky/l337d1c7.l">
                <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Chomsky/l337d1c7.l</filename>
            </link>  
        </para>
        <programlisting language="c"><![CDATA[%{
//a fordítás megegyezik az előző feladatéval: lex -o output.c lexfájl.l
//majd gcc output.c -o output
  #include <stdio.h>
  #include <stdlib.h>
  #include <time.h>
  #include <ctype.h>

  #define L337SIZE (sizeof l337d1c7 / sizeof (struct cipher))
    
  struct cipher {
    char c;
    char *leet[4];
  } l337d1c7 [] = {

  {'a', {"4", "4", "@", "/-\\"}},
  {'b', {"b", "8", "|3", "|}"}},
  {'c', {"c", "(", "<", "{"}},
  {'d', {"d", "|)", "|]", "|}"}},
  {'e', {"3", "3", "3", "3"}},
  {'f', {"f", "|=", "ph", "|#"}},
  {'g', {"g", "6", "[", "[+"}},
  {'h', {"h", "4", "|-|", "[-]"}},
  {'i', {"1", "1", "|", "!"}},
  {'j', {"j", "7", "_|", "_/"}},
  {'k', {"k", "|<", "1<", "|{"}},
  {'l', {"l", "1", "|", "|_"}},
  {'m', {"m", "44", "(V)", "|\\/|"}},
  {'n', {"n", "|\\|", "/\\/", "/V"}},
  {'o', {"0", "0", "()", "[]"}},
  {'p', {"p", "/o", "|D", "|o"}},
  {'q', {"q", "9", "O_", "(,)"}},
  {'r', {"r", "12", "12", "|2"}},
  {'s', {"s", "5", "$", "$"}},
  {'t', {"t", "7", "7", "'|'"}},
  {'u', {"u", "|_|", "(_)", "[_]"}},
  {'v', {"v", "\\/", "\\/", "\\/"}},
  {'w', {"w", "VV", "\\/\\/", "(/\\)"}},
  {'x', {"x", "%", ")(", ")("}},
  {'y', {"y", "", "", ""}},
  {'z', {"z", "2", "7_", ">_"}},
  
  {'0', {"D", "0", "D", "0"}},
  {'1', {"I", "I", "L", "L"}},
  {'2', {"Z", "Z", "Z", "e"}},
  {'3', {"E", "E", "E", "E"}},
  {'4', {"h", "h", "A", "A"}},
  {'5', {"S", "S", "S", "S"}},
  {'6', {"b", "b", "G", "G"}},
  {'7', {"T", "T", "j", "j"}},
  {'8', {"X", "X", "X", "X"}},
  {'9', {"g", "g", "j", "j"}}
  
// https://simple.wikipedia.org/wiki/Leet
  };
  
%}
%%
.	{
	  
	  int found = 0;
	  for(int i=0; i<L337SIZE; ++i)
	  {
	  
	    if(l337d1c7[i].c == tolower(*yytext))
	    {
	    
	      int r = 1+(int) (100.0*rand()/(RAND_MAX+1.0));
	    
          if(r<91)
	        printf("%s", l337d1c7[i].leet[0]);
          else if(r<95)
	        printf("%s", l337d1c7[i].leet[1]);
	      else if(r<98)
	        printf("%s", l337d1c7[i].leet[2]);
	      else 
	        printf("%s", l337d1c7[i].leet[3]);

	      found = 1;
	      break;
	    }
	    
	  }
	  
	  if(!found)
	     printf("%c", *yytext);	  
	  
	}
%%
int 
main()
{
  srand(time(NULL)+getpid());
  yylex();
  return 0;
}
]]></programlisting>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>Ez a program a terminálról beolvassa a karaktereket, és randomizálva 4 különböző karaktert rak az eredeti helyére.
        Ha számára ismeretlen karaktert írunk be, akkor visszaadja ugyan azt.
        A program magja egy l337d1c7 tömb, amely tárolja a helyettesítési értékeket minden karakterhez.
        Ha nem talál egyetlen karaktert sem az inputban, akkor nem ír ki semmit.</para>
    </section>                     


    <section>
        <title>A források olvasása</title>
        <para>
            Hogyan olvasod, hogyan értelmezed természetes nyelven az alábbi kódcsipeteket? Például
            <programlisting><![CDATA[if(signal(SIGINT, jelkezelo)==SIG_IGN)
    signal(SIGINT, SIG_IGN);]]></programlisting>
            Ha a SIGINT jel kezelése figyelmen kívül volt hagyva, akkor ezen túl is legyen
            figyelmen kívül hagyva, ha nem volt figyelmen kívül hagyva, akkor a jelkezelo függvény
            kezelje. (Miután a <command>man 7 signal</command> lapon megismertem a SIGINT jelet, a
            <command>man 2 signal</command> lapon pedig a használt rendszerhívást.)
        </para>

        <caution>
            <title>Bugok</title>
            <para>
                Vigyázz, sok csipet kerülendő, mert bugokat visz a kódba! Melyek ezek és miért? 
                Ha nem megy ránézésre, elkapja valamelyiket esetleg a splint vagy a frama?
            </para>
        </caution>
            
        <orderedlist numeration="lowerroman">
            <listitem>                                    
                <programlisting><![CDATA[if(signal(SIGINT, SIG_IGN)!=SIG_IGN)
    signal(SIGINT, jelkezelo);]]></programlisting>
            <para>Ha a <command>SIGINT</command> jelzés nem volt ignorálva, akkor ignorálja.</para>
            </listitem>
            <listitem>                                    
                <programlisting><![CDATA[for(i=0; i<5; ++i)]]></programlisting>
                <para>egy for ciklus, amely 0-tól 5-ig tart, tehát 5x fut le, és minden lefutás után inkrementálja az i értékét 1-el, majd az inkrementálási értéket adja vissza.</para>          
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[for(i=0; i<5; i++)]]></programlisting>
                <para>ez is egy for ciklus, viszont ebben az esetben az i inkrementálása után az eredeti, növelés előtti értéket adja vissza.</para>
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[for(i=0; i<5; tomb[i] = i++)]]></programlisting>
                <para>Ebben a for ciklusban nem csak, hogy növeljük az i értékét minden kör után, de ezen értéket behelyezzük egy tömbbe is.</para>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[for(i=0; i<n && (*d++ = *s++); ++i)]]></programlisting>            
             <para>a ciklus 0tól indul, és addig megy, amíg i kissebb mint n, továbbá a <command>d</command> pointer növelt értéke megegysezik az <command>s</command> pointer növelt értékével.</para>
            
            </listitem>
           <listitem>                                    

                <programlisting><![CDATA[printf("%d %d", f(a, ++a), f(++a, a));]]></programlisting>            
            <para>kiír két függvényt, melyek számokat adnak vissza, viszont a visszatérési érték precedenciát sugall.</para>
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[printf("%d %d", f(a), a);]]></programlisting>            
               <para>visszaad kettő számot, melyekből az egyik egy függvény visszatérési értéke</para>
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[printf("%d %d", f(&a), a);]]></programlisting>            
            <para>ugyanúgy két számot ad vissza, de az f függvényben az <command>a</command> változó memóriacíme helyezkedik el.</para>
            </listitem>
        </orderedlist>
    
    </section>                     

    <section>
        <title>Logikus</title>
        <para>
            Hogyan olvasod természetes nyelven az alábbi Ar nyelvű formulákat?
        </para>
        <programlisting language="tex"><![CDATA[$(\forall x \exists y ((x<y)\wedge(y \text{ prím})))$ 

$(\forall x \exists y ((x<y)\wedge(y \text{ prím})\wedge(SSy \text{ prím})))$ 

$(\exists y \forall x (x \text{ prím}) \supset (x<y)) $ 

$(\exists y \forall x (y<x) \supset \neg (x \text{ prím}))$
]]></programlisting>        
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/MatLog_LaTeX">https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/MatLog_LaTeX</link>
        </para>

        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/ZexiPy3ZxsA">https://youtu.be/ZexiPy3ZxsA</link>, <link xlink:href="https://youtu.be/AJSXOQFF_wk">https://youtu.be/AJSXOQFF_wk</link>
        </para>

        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>az első formula természetes nyelvi értelmezése:
        <command> minden x számra létezik egy olyan y szám, amely nagyobb, mint x és y prím</command> </para>
        <para>a második formula természetes nyelvi értelmezése:
        <command> minden x számra létezik egy olyan y szám, amely nagyobb, mint x és y prím.Továbbá y rákövetkezőjének a rákövetkezője is prím.</command> </para>
        <para>a harmadik formula természetes nyelvi értelmezése:
        <command> minden y számra létezik egy olyan x szám, hogy x prím és x kisebb, mint y</command> </para>
        <para>a negyedik formula természetes nyelvi értelmezése:
        <command> minden y számra létezik egy olyan x szám, hogy y kisebb, mint x, és x nem prím.</command> </para>
    
    </section>                                                                                                                                                                            
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
    <section>
        <title>Deklaráció</title>
            
        <para>
           <command>Tutorálva Nagy Krisztián által.</command>
            Vezesd be egy programba (forduljon le) a következőket: 
        </para>

        <itemizedlist>
            <listitem>
                <para>egész</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutató</para>                        
            </listitem>
            <listitem>
                <para>egész referenciája</para>                        
            </listitem>
            <listitem>
                <para>egészek tömbje</para>                        
            </listitem>
            <listitem>
                <para>egészek tömbjének referenciája (nem az első elemé)</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatók tömbje</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatót visszaadó függvény</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatót visszaadó függvényre mutató mutató</para>                        
            </listitem>
            <listitem>
                <para>egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvény</para>                        
            </listitem>            
            <listitem>
                <para>függvénymutató egy egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvényre</para>                        
            </listitem>            
        </itemizedlist>            

        <para>
            Mit vezetnek be a programba a következő nevek?
        </para>

        <itemizedlist>
            <listitem>
                <programlisting><![CDATA[int a;]]></programlisting>  
                <para>egy szám típusú <command>a</command> változót</para>          
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *b = &a;]]></programlisting>   
                 <para>egy szám typusú <command>b pointert</command>, aminek az értéke <command>a memóriában foglalt helye</command></para>             
            </listitem>
            <listitem>
                <programlisting><![CDATA[int &r = a;]]></programlisting>
                 <para>integer típusú <command>r értéke</command> <command>a</command> lesz</para>                
            </listitem>
            <listitem>
                <programlisting><![CDATA[int c[5];]]></programlisting>   
                 <para>létrehoz egy 5 számnak helyet adó <command>c</command> tömböt</para>             
            </listitem>
            <listitem>
                <programlisting><![CDATA[int (&tr)[5] = c;]]></programlisting>  
                 <para>létrehoz egy <command>tr tömb referenciát</command>, melynek az értéke c</para>              
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *d[5];]]></programlisting>   
                 <para>egy egészekre mutató <command>d tömb pointer</command></para>             
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *h ();]]></programlisting>   
                 <para><command>h funkcíóra mutató pointer</command></para>             
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *(*l) ();]]></programlisting> 
                 <para>egy pointer, ami az <command>l függvényre mutató pointerre mutat</command></para>               
            </listitem>
            <listitem>
                <programlisting><![CDATA[int (*v (int c)) (int a, int b)]]></programlisting> 
                  <para>egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvény</para>                        
                        
            </listitem>            
            <listitem>
                <programlisting><![CDATA[int (*(*z) (int)) (int, int);]]></programlisting> 
                 <para>függvénymutató egy egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvényre</para>                                      
            </listitem>            
        </itemizedlist>       


        <para>
            Megoldás videó: 
        </para>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása:  
        </para>
        <para>
            Az utolsó két deklarációs példa demonstrálására két olyan kódot
            írtunk, amelyek összahasonlítása azt mutatja meg, hogy miért 
            érdemes a <command>typedef</command> használata: <link xlink:href="Chomsky/fptr.c">
                <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Chomsky/fptr.c</filename>
            </link>,
            <link xlink:href="Chomsky/fptr2.c">
                <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Chomsky/fptr2.c</filename>.
            </link>  
            
        </para>
        <programlisting><![CDATA[#include <stdio.h>

int
sum (int a, int b)
{
    return a + b;
}

int
mul (int a, int b)
{
    return a * b;
}

int (*sumormul (int c)) (int a, int b)
{
    if (c)
        return mul;
    else
        return sum;

}

int
main ()
{

    int (*f) (int, int);

    f = sum;

    printf ("%d\n", f (2, 3));

    int (*(*g) (int)) (int, int);

    g = sumormul;

    f = *g (42);

    printf ("%d\n", f (2, 3));

    return 0;
}]]></programlisting>            
        <programlisting><![CDATA[#include <stdio.h>

typedef int (*F) (int, int);
typedef int (*(*G) (int)) (int, int);

int
sum (int a, int b)
{
    return a + b;
}

int
mul (int a, int b)
{
    return a * b;
}

F sumormul (int c)
{
    if (c)
        return mul;
    else
        return sum;
}

int
main ()
{

    F f = sum;

    printf ("%d\n", f (2, 3));

    G g = sumormul;

    f = *g (42);

    printf ("%d\n", f (2, 3));

    return 0;
}
]]></programlisting>            

    </section>                     

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Caesar!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title><type>double **</type> háromszögmátrix</title>
        <para>
            Írj egy olyan <function>malloc</function> és <function>free</function>
            párost használó C programot, amely helyet foglal
            egy alsó háromszög mátrixnak a szabad tárban!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/1MRTuKwRsB0">https://youtu.be/1MRTuKwRsB0</link>,
            <link xlink:href="https://youtu.be/RKbX5-EWpzA">https://youtu.be/RKbX5-EWpzA</link>.

        </para>
        <para>
            Megoldás forrása: <link xlink:href="Caesar/tm.c">
                <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Caesar/tm.c</filename>
            </link> 
        </para>
        <para>
        <programlisting language="c"><![CDATA[
#include <stdio.h>
#include <stdlib.h>

int
main ()
{
    int nr = 5;
    double **tm;
    
    printf("%p\n", &tm);
    
    if ((tm = (double **) malloc (nr * sizeof (double *))) == NULL)
    {
        return -1;
    }

    printf("%p\n", tm);
    
    for (int i = 0; i < nr; ++i)
    {
        if ((tm[i] = (double *) malloc ((i + 1) * sizeof (double))) == NULL)
        {
            return -1;
        }

    }

    printf("%p\n", tm[0]);    
    
    for (int i = 0; i < nr; ++i)
        for (int j = 0; j < i + 1; ++j)
            tm[i][j] = i * (i + 1) / 2 + j;

    for (int i = 0; i < nr; ++i)
    {
        for (int j = 0; j < i + 1; ++j)
            printf ("%f, ", tm[i][j]);
        printf ("\n");
    }

    tm[3][0] = 42.0;
    (*(tm + 3))[1] = 43.0;	// mi van, ha itt hiányzik a külső ()
    *(tm[3] + 2) = 44.0;
    *(*(tm + 3) + 3) = 45.0;

    for (int i = 0; i < nr; ++i)
    {
        for (int j = 0; j < i + 1; ++j)
            printf ("%f, ", tm[i][j]);
        printf ("\n");
    }

    for (int i = 0; i < nr; ++i)
        free (tm[i]);

    free (tm);

    return 0;
}
]]></programlisting>
        <figure>
            <title>A <type>double **</type> háromszögmátrix a memóriában</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/doublecscs.png" scale="50"/>
                </imageobject>
                <textobject>
                    <phrase>A <type>double **</type> háromszögmátrix a memóriában</phrase>
                </textobject>
            </mediaobject>
        </figure>                             
</para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
        <para>
    Az<programlisting language="c"><![CDATA[int nr = 5;]]></programlisting>sorral létrehozunk egy integer változót, amelynek az értéke 5, ez a változó lesz a háromszög sorainak száma.
    A<programlisting language="c"><![CDATA[double **tm;]]></programlisting>sor pedig létrehoz egy double típusú változót, ez lesz később a programunk magja.
    </para><para>Ezek a sorok:<programlisting language="c"><![CDATA[if ((tm = (double **) malloc (nr * sizeof (double *))) == NULL)
    {
        return -1;
    }]]></programlisting>pedig megnézik, hogy a programunk le tud e foglalni <command>nr*8</command> bájtot, ha nem, akkor kilép a programból a <command>-1</command> visszatérési értékkel.
        </para><para><programlisting language="c"><![CDATA[for (int i = 0; i < nr; ++i)
    {
        if ((tm[i] = (double *) malloc ((i + 1) * sizeof (double))) == NULL)
        {
            return -1;
        }
    }]]></programlisting>Itt azt láthatjuk, hogy a program a tm változót tömbként kezelve bejárja azt, és mindíg <command>(i+1)*8</command>bájtot allokál/foglal le az aktuális tömb pozíciójához.
    Ha ez nem sikerül, akkor megint csak kilép <command>-1</command>es visszatérési értékkel.
        </para><para><programlisting language="c"><![CDATA[
        for (int i = 0; i < nr; ++i)
        for (int j = 0; j < i + 1; ++j)
            tm[i][j] = i * (i + 1) / 2 + j; 0 1 

    for (int i = 0; i < nr; ++i)
    {
        for (int j = 0; j < i + 1; ++j)
            printf ("%f, ", tm[i][j]);
        printf ("\n");
    }]]></programlisting>Ezek a ciklusok a kiíratásért felelnek. <command>az első egybeágyazott for ciklus pár</command> a tm változót tölti fe1 számokkal 0-tól 15-ig, majd <command>a második cikluspár</command> kiíratja azokat</para>
    <para><programlisting language="c"><![CDATA[for (int i = 0; i < nr; ++i)
        free (tm[i]);

    free (tm);]]></programlisting>Ezek a sorok a program végén felszabadítják a lefoglalt memóriahelyeket, először a változó tömbelemeitől kezdve, majd végül a most már üres változót is letörli.</para></section>        
    <section>
        <title>C EXOR titkosító</title>
        <para>
            Írj egy EXOR titkosítót C-ben!
        </para>
        <para><command>Tutoráltam: Schachinger Zsoltot</command>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása :          
        </para>
        <para><programlisting language="c"><![CDATA[
#include <stdio.h>
#include <unistd.h>
#include <string.h>

#define MAX_KULCS 100
#define BUFFER_MERET 256

int
main(int argc, char **argv)
{

char kulcs[MAX_KULCS];
char buffer[BUFFER_MERET];
int kulcs_index=0;
int olvasott_bajtok=0;
int kulcs_meret=strlen (argv[1]);
strncpy (kulcs,argv[1], MAX_KULCS);

while ((olvasott_bajtok=read(0,(void *) buffer, BUFFER_MERET)))
 {
	for (int i=0; i<olvasott_bajtok;++i)
	{
	buffer[i]=buffer[i]^ kulcs[kulcs_index];
	kulcs_index=(kulcs_index+1)% kulcs_meret;
	}
write (1, buffer,olvasott_bajtok);
 }
}]]></programlisting></para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>   
        <para>Amint láthatjuk, a main() függvényben megjelent két ismeretlen paraméter.
        ezek a program futtatásánál játszanak szerepet:<command> az argc</command> jelöli az argumentumok számát, beleértve a <command>./programnév</command> sort is.
        ezzel szemben a <command>**argv</command> egy vektor, amely az argumentumokat tárolja. Itt például, ha a terminálba ezt a sort írjuk:<command> ./fájlnév 1234 -o output.txt</command>, akkor az argc értéke 4 lesz, míg a **argv vektor így néz ki:<![CDATA[ <./fájlnév; 1234; -o; output.txt>]]></para>         
    <para>
<programlisting language="c"><![CDATA[int kulcs_meret=strlen (argv[1]);
strncpy (kulcs,argv[1], MAX_KULCS);]]></programlisting>
Ez a két sor is ismeretlen lehet számunkra, de nem kell tőlük megijedni, elég egyszerű a kezelésük.
az első sor az argumentum_vektor 1. elemét(ami az előző példában az 1234 volt) lekéri, és megszámolja annak hosszát(<command>ez az strlen() függvény dolga</command>), majd a kulcs_meret nevű változónak ezt a hosszt értékül adja.
a második sor pedig egy string másoló függvény, ennek szintaktikája a következő: <command>strncpy(char cél_változó,char másolni_kívánt_érték,a_másolni_kívánt_érték_hossza)</command> (ha a másolt érték kisebb, mint az utolsó paraméterben megadott szám, akkor a maradékot <command>NULL</command> bájtokkal fogja kipótolni a program)</para>
    </section>        
    <section>
        <title>Java EXOR titkosító</title>
        <para>
            Írj egy EXOR titkosítót Java-ban!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/ch01.html#exor_titkosito">https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/ch01.html#exor_titkosito</link>                               
        <programlisting language="java"><![CDATA[public class ExorTitkosító {
    
    public ExorTitkosító(String kulcsSzöveg,
            java.io.InputStream bejövőCsatorna,
            java.io.OutputStream kimenőCsatorna)
            throws java.io.IOException 
    {
        
        byte [] kulcs = kulcsSzöveg.getBytes();
        byte [] buffer = new byte[256];
        int kulcsIndex = 0;
        int olvasottBájtok = 0;

        while((olvasottBájtok =
        bejövőCsatorna.read(buffer)) != -1)
        {
            
            for(int i=0; i<olvasottBájtok; ++i) 
            {
                
                buffer[i] = (byte)(buffer[i] ^ kulcs[kulcsIndex]);
                kulcsIndex = (kulcsIndex+1) % kulcs.length;
                
            }
            
            kimenőCsatorna.write(buffer, 0, olvasottBájtok);
            
        }
        
    }
    
    public static void main(String[] args) {
        
        try {
            
            new ExorTitkosító(args[0], System.in, System.out);
            
        } catch(java.io.IOException e) {
            
            e.printStackTrace();
            
        }
        
    }
    
}]]></programlisting>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>     
        <para>A Java verzió is hasonlóképpen működik, mint a C verzió, csak a nyelvi sajátosságoknak köszönhetően találhatóak különbségek a két kód között.
        Mivel a Java is magasszintű programozási nyelv, ezért a forráskód értelmezése könnyebb, mint egy assembly nyelvé.
        </para><para>A main függvényben található egy try-catch blokk, ez egyfajta hibakeresés.
        A try részbe kerülnek a kódok, amik nagy eséllyel hibát dobhatnak, és a catch részben ezeket a hibákat elkapja a program, és a programozó által megadott üzenetet dobja ki.
        Itt például Ha valami nem stimmel a megadott argumentumokkal, a program kiad egy exception-t.
        Ez a C programban nincs jelen, de ha szeretnénk, akár oda is beleírthatjuk.
        </para> 
        </section>        
    <section>
        <title>C EXOR törő</title>
        <para>
            Írj egy olyan C programot, amely megtöri az első feladatban előállított titkos szövegeket!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para><programlisting language="c"><![CDATA[
#define MAX_TITKOS 4096
#define OLVASAS_BUFFER 256
#define KULCS_MERET 8
#define _GNU_SOURCE

#include <stdio.h>
#include <unistd.h>
#include <string.h>

double
atlagos_szohossz (const char *titkos, int titkos_meret)
{
    int sz = 0;
    for (int i = 0; i < titkos_meret; ++i)
        if (titkos[i] == ' ')
            ++sz;

    return (double) titkos_meret / sz;
}

int
tiszta_lehet (const char *titkos, int titkos_meret)
{
    // a tiszta szoveg valszeg tartalmazza a gyakori magyar szavakat
    // illetve az átlagos szóhossz vizsgálatával csökkentjük a
    // potenciális töréseket

    double szohossz = atlagos_szohossz (titkos, titkos_meret);

    return szohossz > 6.0 && szohossz < 9.0
           && strcasestr (titkos, "hogy") && strcasestr (titkos, "nem")
           && strcasestr (titkos, "az") && strcasestr (titkos, "ha");

}

void
exor (const char kulcs[], int kulcs_meret, char titkos[], int titkos_meret)
{

    int kulcs_index = 0;

    for (int i = 0; i < titkos_meret; ++i)
    {

        titkos[i] = titkos[i] ^ kulcs[kulcs_index];
        kulcs_index = (kulcs_index + 1) % kulcs_meret;

    }

}

int
exor_tores (const char kulcs[], int kulcs_meret, char titkos[],
            int titkos_meret)
{

    exor (kulcs, kulcs_meret, titkos, titkos_meret);

    return tiszta_lehet (titkos, titkos_meret);

}

int
main (void)
{

    char kulcs[KULCS_MERET];
    char titkos[MAX_TITKOS];
    char *p = titkos;
    int olvasott_bajtok;

    // titkos fajt berantasa
    while ((olvasott_bajtok =
                read (0, (void *) p,
                      (p - titkos + OLVASAS_BUFFER <
                       MAX_TITKOS) ? OLVASAS_BUFFER : titkos + MAX_TITKOS - p)))
        p += olvasott_bajtok;

    // maradek hely nullazasa a titkos bufferben
    for (int i = 0; i < MAX_TITKOS - (p - titkos); ++i)
        titkos[p - titkos + i] = '\0';

    // osszes kulcs eloallitasa
    for (int ii = '0'; ii <= '9'; ++ii)
        for (int ji = '0'; ji <= '9'; ++ji)
            for (int ki = '0'; ki <= '9'; ++ki)
                for (int li = '0'; li <= '9'; ++li)
                    for (int mi = '0'; mi <= '9'; ++mi)
                        for (int ni = '0'; ni <= '9'; ++ni)
                            for (int oi = '0'; oi <= '9'; ++oi)
                                for (int pi = '0'; pi <= '9'; ++pi)
                                {
                                    kulcs[0] = ii;
                                    kulcs[1] = ji;
                                    kulcs[2] = ki;
                                    kulcs[3] = li;
                                    kulcs[4] = mi;
                                    kulcs[5] = ni;
                                    kulcs[6] = oi;
                                    kulcs[7] = pi;

                                    if (exor_tores (kulcs, KULCS_MERET, titkos, p - titkos))
                                        printf
                                        ("Kulcs: [%c%c%c%c%c%c%c%c]\nTiszta szoveg: [%s]\n",
                                         ii, ji, ki, li, mi, ni, oi, pi, titkos);

                                    // ujra EXOR-ozunk, igy nem kell egy masodik buffer
                                    exor (kulcs, KULCS_MERET, titkos, p - titkos);
                                }

    return 0;
}]]></programlisting></para>
    <para>és a több magos változat:</para>
        <para><programlisting language="c"><![CDATA[
#define MAX_TITKOS 4096
#define OLVASAS_BUFFER 256
#define KULCS_MERET 8
#define _GNU_SOURCE

#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>

double
atlagos_szohossz (const char *titkos, int titkos_meret)
{
    int sz = 0;
    for (int i = 0; i < titkos_meret; ++i)
        if (titkos[i] == ' ')
            ++sz;

    return (double) titkos_meret / sz;
}

int
tiszta_lehet (const char *titkos, int titkos_meret)
{
    // a tiszta szoveg valszeg tartalmazza a gyakori magyar szavakat
    // illetve az átlagos szóhossz vizsgálatával csökkentjük a
    // potenciális töréseket

    double szohossz = atlagos_szohossz (titkos, titkos_meret);

    return szohossz > 6.0 && szohossz < 9.0
           && strcasestr (titkos, "hogy") && strcasestr (titkos, "nem")
           && strcasestr (titkos, "az") && strcasestr (titkos, "ha");

}

void
exor (const char kulcs[], int kulcs_meret, char titkos[], int titkos_meret, char *buffer)
{

    int kulcs_index = 0;

    for (int i = 0; i < titkos_meret; ++i)
    {

        buffer[i] = titkos[i] ^ kulcs[kulcs_index];
        kulcs_index = (kulcs_index + 1) % kulcs_meret;

    }

}

void
exor_tores (const char kulcs[], int kulcs_meret, char titkos[],
            int titkos_meret)
{

    char *buffer;

    if ((buffer = (char *)malloc(sizeof(char)*titkos_meret)) == NULL)
    {
        printf("Memoria (buffer) faliora\n");
        exit(-1);
    }

    exor (kulcs, kulcs_meret, titkos, titkos_meret, buffer);

    if (tiszta_lehet (buffer, titkos_meret))
    {
        printf("Kulcs: [%c%c%c%c%c%c%c%c]\nTiszta szoveg: [%s]\n",
               kulcs[0],kulcs[1],kulcs[2],kulcs[3],kulcs[4],kulcs[5],kulcs[6],kulcs[7], buffer);
    }

    free(buffer);

}

int
main (void)
{

    char kulcs[KULCS_MERET];
    char titkos[MAX_TITKOS];
    char *p = titkos;
    int olvasott_bajtok;

    // titkos fajt berantasa
    while ((olvasott_bajtok =
                read (0, (void *) p,
                      (p - titkos + OLVASAS_BUFFER <
                       MAX_TITKOS) ? OLVASAS_BUFFER : titkos + MAX_TITKOS - p)))
        p += olvasott_bajtok;

    // maradek hely nullazasa a titkos bufferben
    for (int i = 0; i < MAX_TITKOS - (p - titkos); ++i)
        titkos[p - titkos + i] = '\0';

    // osszes kulcs eloallitasa
#pragma omp parallel for private(kulcs)
    for (int ii = '0'; ii <= '9'; ++ii)
        for (int ji = '0'; ji <= '9'; ++ji)
            for (int ki = '0'; ki <= '9'; ++ki)
                for (int li = '0'; li <= '9'; ++li)
                    for (int mi = '0'; mi <= '9'; ++mi)
                        for (int ni = '0'; ni <= '9'; ++ni)
                            for (int oi = '0'; oi <= '9'; ++oi)
                                for (int pi = '0'; pi <= '9'; ++pi)
                                {
                                    kulcs[0] = ii;
                                    kulcs[1] = ji;
                                    kulcs[2] = ki;
                                    kulcs[3] = li;
                                    kulcs[4] = mi;
                                    kulcs[5] = ni;
                                    kulcs[6] = oi;
                                    kulcs[7] = pi;

                                    exor_tores (kulcs, KULCS_MERET, titkos, p - titkos);

                                }

    return 0;
}]]></programlisting></para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>   
        <para>az atlagos_szohossz függvény bekéri a titkos szöveget és méretét, majd egy 'sz' változóban megszámolja, hogy hány szóköz található a szövegben.
        Ezután a szöveg teljes méretét elosztja az 'sz' változó értékével, így megkapva az átlagos szóhosszt.
        </para>
        <para>az strcasestr függvény azt keresi, hogy a titkos-ban megtalálható-e a <command>2. paraméterben megadott szöveg</command> eg.:"hogy" és "nem"</para>         
        <para>A többmagos változatban a különbség ott mutatkozik meg, hogy az <command>összes kulcs előállítása</command> résznél a #pragma sor megjelenik.
        Ez a processzor magok között szétosztja a tennivalót, és "párhuzamosan" számolja majd írja ki az összes lehetséges kulcsot.</para>
    </section>        
    <section>
        <title>Neurális OR, AND és EXOR kapu</title>
        <para>
            R
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/Koyw6IH5ScQ">https://youtu.be/Koyw6IH5ScQ</link>
        </para>
        <para>
           Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R</link>               
        </para>
        <para><programlisting language="r"><![CDATA[
#   Copyright (C) 2019  Dr. Norbert Bátfai, nbatfai@gmail.com
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>
#
# https://youtu.be/Koyw6IH5ScQ

library(neuralnet)

a1    <- c(0,1,0,1)
a2    <- c(0,0,1,1)
OR    <- c(0,1,1,1)

or.data <- data.frame(a1, a2, OR)

nn.or <- neuralnet(OR~a1+a2, or.data, hidden=0, linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)

plot(nn.or)

compute(nn.or, or.data[,1:2])


a1    <- c(0,1,0,1)
a2    <- c(0,0,1,1)
OR    <- c(0,1,1,1)
AND   <- c(0,0,0,1)

orand.data <- data.frame(a1, a2, OR, AND)

nn.orand <- neuralnet(OR+AND~a1+a2, orand.data, hidden=0, linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)

plot(nn.orand)

compute(nn.orand, orand.data[,1:2])



a1      <- c(0,1,0,1)
a2      <- c(0,0,1,1)
EXOR    <- c(0,1,1,0)

exor.data <- data.frame(a1, a2, EXOR)

nn.exor <- neuralnet(EXOR~a1+a2, exor.data, hidden=0, linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)

plot(nn.exor)

compute(nn.exor, exor.data[,1:2])



a1      <- c(0,1,0,1)
a2      <- c(0,0,1,1)
EXOR    <- c(0,1,1,0)

exor.data <- data.frame(a1, a2, EXOR)

nn.exor <- neuralnet(EXOR~a1+a2, exor.data, hidden=c(6, 4, 6), linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)

plot(nn.exor)

compute(nn.exor, exor.data[,1:2])

]]></programlisting></para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>Ez a program a neurális hálóra alapszik.
        <command>A neurális hálózat biológiai neuronok összekapcsolt csoportja. Modern használatban a szó alatt a mesterséges neurális hálót értjük, amelyek mesterséges neuronokból állnak.</command>
        forrás: <link xlink:href="https://hu.wikipedia.org/wiki/Neur%C3%A1lis_h%C3%A1l%C3%B3zat">https://hu.wikipedia.org/wiki/Neur%C3%A1lis_h%C3%A1l%C3%B3zat</link></para><para>
        Itt a library(neuralnet) sor hasonlóképpen működik, mint a #include parancs a C nyelvekben.
        A számításokért ez a könyvtár felel.
        Ezek a neurális hálók egyfajta ai-ként tekinthetőek, azaz megtanítjuk a számítógépnek, hogy az egyes kapukat felismerje.
        Ez a három kapu az OR,AND,ORAND és az EXOR.
        </para>
        <para>Az OR kapu és annak "plotolása" itt található</para>
        <programlisting><![CDATA[or.data <- data.frame(a1, a2, OR)

nn.or <- neuralnet(OR~a1+a2, or.data, hidden=0, linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)

plot(nn.or)]]></programlisting> 
          <para>Az ORAND pedig itt:</para>    
        <programlisting><![CDATA[a1    <- c(0,1,0,1)
a2    <- c(0,0,1,1)
OR    <- c(0,1,1,1)
AND   <- c(0,0,0,1)

orand.data <- data.frame(a1, a2, OR, AND)

nn.orand <- neuralnet(OR+AND~a1+a2, orand.data, hidden=0, linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)

plot(nn.orand)

compute(nn.orand, orand.data[,1:2])]]></programlisting>  
          <para>Végül pedig az EXOR kapu:</para>
        <programlisting><![CDATA[a1      <- c(0,1,0,1)
a2      <- c(0,0,1,1)
EXOR    <- c(0,1,1,0)

exor.data <- data.frame(a1, a2, EXOR)

nn.exor <- neuralnet(EXOR~a1+a2, exor.data, hidden=c(6, 4, 6), linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)

plot(nn.exor)

compute(nn.exor, exor.data[,1:2])]]></programlisting>       
    </section>        
    <section>
        <title>Hiba-visszaterjesztéses perceptron</title>
        <para>
            C++
        </para>
        <para>
             Megoldás videó: <link xlink:href="https://youtu.be/XpBnR31BRJY">https://youtu.be/XpBnR31BRJY</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/nbatfai/nahshon/blob/master/ql.hpp#L64">https://github.com/nbatfai/nahshon/blob/master/ql.hpp#L64</link>               
        </para>
        <para>
        <!--<programlisting language="c++"><![CDATA[]]></programlisting>-->
        A forráskódot a hossza miatt nem tenném bele a könyvbe, de kódsnippet-eket fogok használni.
        </para>
        <para><programlisting language="c++">
        <![CDATA[//main.cpp fájl tartalma
        #include <iostream>
        #include "mlp.cpp"
        #include <png++/png.hpp>

        int main (int argc, char **argv)
        {
        png::image <png::rgb_pixel> png_image (argv[1]);

        int size = png_image.get_width()*png_image.get_height();

        Perceptron* p = new Perceptron (3, size, 256,1);
        double* image = new double(size);

            for(int i {0};i<png_image.get_width();++i)
                for(int j{0};j<png_image.get_height();++j)
                    image[i*png_image.get_Width()+j]= png_image[i][j].red;
        double value = (*p) (image);
        std::cout <<value<<std:endl;

        delete p;
        delete [] image;
        }
        ]]>
        </programlisting></para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>   
        <para>A program lényegében annyit csinál, hogy végigfut a bemeneten, és megszámolja a piros pixeleket.
        Ezt a két egymásba épített forciklusban láthatjuk.
        az első ciklus <command><![CDATA[for(int i {0};i<png_image.get_width();++i)]]></command> 0-tól a kép szélességéig fut, míg a második ciklus
        <command><![CDATA[for(int j{0};j<png_image.get_height();++j)]]></command> a kép magasságáig fut,
        a ciklus belsejében található maga a számolási művelet.
        <command><![CDATA[image[i*png_image.get_Width()+j]= png_image[i][j].red;]]></command>
        A kép szélességét szorozza i-vel és hozzáad j-t, és ez lesz az <command>image</command> változónk indexe.
        ezen változót egyenlővé tesszük a png_image[i][j] kép piros(red) tagjával.
        ezután egy value változóban eltároljuk az image változó értékét, amely perceptronra mutat.
        Végül kiírjuk a <command>value</command> értékét.
        a lefordításhoz ezt kell beírni:<command>g++ mpl.hpp main.cpp -o perceptron -lpng -std=c++11</command></para>         
    </section>        
        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Mandelbrot!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section xml:id="bhax-textbook-feladatok-mandelbrot.Mandelbrot">
        <title>A Mandelbrot halmaz</title>
        <para>
            Írj olyan C programot, amely kiszámolja a Mandelbrot halmazt!     
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/gvaqijHlRUs">https://youtu.be/gvaqijHlRUs</link>
        </para>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása:                
 <link xlink:href="../mandelpngt.c++">
                <filename>/mandelpngt.c++</filename>
            </link> nevű állománya.            
        </para>
                <figure>
            <title>A Mandelbrot halmaz a komplex síkon</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandel.png" scale="50"/>
                </imageobject>
                <textobject>
                    <phrase>A Mandelbrot halmaz a komplex síkon</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <para>
            A Mandelbrot halmazt 1980-ban találta meg Benoit Mandelbrot a 
            komplex számsíkon. Komplex számok azok a számok, amelyek körében 
            válaszolni lehet az olyan egyébként értelmezhetetlen kérdésekre, 
            hogy melyik az a két szám, amelyet összeszorozva -9-et kapunk, 
            mert ez a szám például a 3i komplex szám.
        </para>
        <para>             
            A Mandelbrot halmazt úgy láthatjuk meg, hogy a sík origója középpontú 4 
            oldalhosszúságú négyzetbe lefektetünk egy, mondjuk 800x800-as 
            rácsot és kiszámoljuk, hogy a rács pontjai mely komplex számoknak 
            felelnek meg. A rács minden pontját megvizsgáljuk a 
            z<subscript>n+1</subscript>=z<subscript>n</subscript>
            <superscript>2</superscript>+c, 
            (0&lt;=n) képlet alapján úgy, hogy a c az éppen vizsgált rácspont. 
            A z0 az origó. Alkalmazva a képletet a 
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    z<subscript>0</subscript> = 0
                </para>
            </listitem>
            <listitem>
                <para>
                    z<subscript>1</subscript> = 0<superscript>2</superscript>+c = c
                </para>
            </listitem>
            <listitem>
                <para>
                    z<subscript>2</subscript> = c<superscript>2</superscript>+c
                </para>
            </listitem>
            <listitem>
                <para>
                    z<subscript>3</subscript> = (c<superscript>2</superscript>+c)<superscript>2</superscript>+c
                </para>
            </listitem>
            <listitem>
                <para>
                    z<subscript>4</subscript> = ((c<superscript>2</superscript>+c)<superscript>2</superscript>+c)<superscript>2</superscript>+c
                </para>
            </listitem>
            <listitem>
                <para>
                    ... s így tovább.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            Azaz kiindulunk az origóból (z<subscript>0</subscript>) 
            és elugrunk a rács első pontjába a z<subscript>1</subscript> = c-be, 
            aztán a c-től függően a további z-kbe. Ha ez az utazás kivezet a 
            2 sugarú körből, akkor azt mondjuk, hogy az a vizsgált rácspont 
            nem a Mandelbrot halmaz eleme. Nyilván nem tudunk végtelen sok 
            z-t megvizsgálni, ezért csak véges sok z elemet nézünk meg minden 
            rácsponthoz. Ha eközben nem lép ki a körből, akkor feketére 
            színezzük, hogy az a c rácspont a halmaz része. (Színes meg úgy 
            lesz a kép, hogy változatosan színezzük, például minél későbbi 
            z-nél lép ki a körből, annál sötétebbre). 
        </para>       
        <para>   
             
        </para>

    </section>        
        
    <section>
        <title>A Mandelbrot halmaz a <filename>std::complex</filename> osztállyal</title>
        <para>
            Írj olyan C++ programot, amely kiszámolja a Mandelbrot halmazt!                     
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/gvaqijHlRUs">https://youtu.be/gvaqijHlRUs</link>
        </para>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása:                
        </para>
        <para>        
A <link xlink:href="#bhax-textbook-feladatok-mandelbrot.Mandelbrot">Mandelbrot halmaz</link> pontban vázolt
ismert algoritmust valósítja meg a repó <link xlink:href="../../../bhax/attention_raising/Mandelbrot/3.1.2.cpp">
                <filename>bhax/attention_raising/Mandelbrot/3.1.2.cpp</filename>
            </link> nevű állománya.
        </para>
        
        <programlisting language="c++">
<![CDATA[// Verzio: 3.1.2.cpp
// Forditas:
// g++ 3.1.2.cpp -lpng -O3 -o 3.1.2
// Futtatas:
// ./3.1.2 mandel.png 1920 1080 2040 -0.01947381057309366392260585598705802112818 -0.0194738105725413418456426484226540196687 0.7985057569338268601555341774655971676111 0.798505756934379196110285192844457924366
// ./3.1.2 mandel.png 1920 1080 1020 0.4127655418209589255340574709407519549131 0.4127655418245818053080142817634623497725 0.2135387051768746491386963270997512154281 0.2135387051804975289126531379224616102874
// Nyomtatas:
// a2ps 3.1.2.cpp -o 3.1.2.cpp.pdf -1 --line-numbers=1  --left-footer="BATF41 HAXOR STR34M" --right-footer="https://bhaxor.blog.hu/" --pro=color
// ps2pdf 3.1.2.cpp.pdf 3.1.2.cpp.pdf.pdf
//
//
// Copyright (C) 2019
// Norbert Bátfai, batfai.norbert@inf.unideb.hu
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.


#include <iostream>
#include "png++/png.hpp"
#include <complex>

int
main ( int argc, char *argv[] )
{

  int szelesseg = 1920;
  int magassag = 1080;
  int iteraciosHatar = 255;
  double a = -1.9;
  double b = 0.7;
  double c = -1.3;
  double d = 1.3;

  if ( argc == 9 )
    {
      szelesseg = atoi ( argv[2] );
      magassag =  atoi ( argv[3] );
      iteraciosHatar =  atoi ( argv[4] );
      a = atof ( argv[5] );
      b = atof ( argv[6] );
      c = atof ( argv[7] );
      d = atof ( argv[8] );
    }
  else
    {
      std::cout << "Hasznalat: ./3.1.2 fajlnev szelesseg magassag n a b c d" << std::endl;
      return -1;
    }

  png::image < png::rgb_pixel > kep ( szelesseg, magassag );

  double dx = ( b - a ) / szelesseg;
  double dy = ( d - c ) / magassag;
  double reC, imC, reZ, imZ;
  int iteracio = 0;

  std::cout << "Szamitas\n";

  // j megy a sorokon
  for ( int j = 0; j < magassag; ++j )
    {
      // k megy az oszlopokon

      for ( int k = 0; k < szelesseg; ++k )
        {

          // c = (reC, imC) a halo racspontjainak
          // megfelelo komplex szam

          reC = a + k * dx;
          imC = d - j * dy;
          std::complex<double> c ( reC, imC );

          std::complex<double> z_n ( 0, 0 );
          iteracio = 0;

          while ( std::abs ( z_n ) < 4 && iteracio < iteraciosHatar )
            {
              z_n = z_n * z_n + c;

              ++iteracio;
            }

          kep.set_pixel ( k, j,
                          png::rgb_pixel ( iteracio%255, (iteracio*iteracio)%255, 0 ) );
        }

      int szazalek = ( double ) j / ( double ) magassag * 100.0;
      std::cout << "\r" << szazalek << "%" << std::flush;
    }

  kep.write ( argv[1] );
  std::cout << "\r" << argv[1] << " mentve." << std::endl;

}
]]>
        </programlisting>   
        <para>A program megírásához szükségünk lesz az STD::complex könyvtárra, és a png++/png.cpp könyvtárra.
        Ez utóbbi felel az adatok képként való megjelenítéséért.
        A kep.set_pixel függvény felel a kép elkészítéséért, míg a benne lévő rgb_pixel a színének módosításáért.</para>     
     
     <programlisting language="c++"><![CDATA[int
main ( int argc, char *argv[] )
{

  int szelesseg = 1920;
  int magassag = 1080;
  int iteraciosHatar = 255;
  double a = -1.9;
  double b = 0.7;
  double c = -1.3;
  double d = 1.3;

  if ( argc == 9 )
    {
      szelesseg = atoi ( argv[2] );
      magassag =  atoi ( argv[3] );
      iteraciosHatar =  atoi ( argv[4] );
      a = atof ( argv[5] );
      b = atof ( argv[6] );
      c = atof ( argv[7] );
      d = atof ( argv[8] );
    }
  else
    {
      std::cout << "Hasznalat: ./3.1.2 fajlnev szelesseg magassag n a b c d" << std::endl;
      return -1;
    }
]]></programlisting>
<para>
Ebben a kódsnippetben láthatjuk, ahogy a main-ben megadunk egy kezdő értéket a létrehozandó képnek.
Az alatta lévő elágazásban megnézzük, hogy az argumentumok száma 9-e, ha igen, akkor
a szelesseg változó értékét megváltoztatja a második argumentummal, a magassag változóét a harmadik argumentummal, az iteraciosHatar változóét
a negyedik argumentummal, és ezeket mind az atoi funkcióval.
Az atoi funkció stringet int-té alakít át.
az a,b,c,d változók értékeit pedit az 5-dik, 6-dik,7-dik és 8-dik argumentummal cseréli ki.
Ezeket mind az atof függvény segytségével érik el, amely stringből double-t csinál.
Ha a feltétel nem teljesül, akkor pedig kiírja a standard kimenetre a használatot, majd <command>-1</command>-el tér vissza. 

</para>
<programlisting language="c++"><![CDATA[png::image < png::rgb_pixel > kep ( szelesseg, magassag );
double dx = ( b - a ) / szelesseg; double dy = ( d - c ) / magassag; double reC, imC, reZ, imZ; int iteracio = 0;
std::cout << "Szamitas\n";
// j megy a sorokon for ( int j = 0; j < magassag; ++j )
{
// k megy az oszlopokon
for ( int k = 0; k < szelesseg; ++k ) {
// c = (reC, imC) a halo racspontjainak // megfelelo komplex szam
reC = a + k * dx; imC = d - j * dy;
std::complex<double> c ( reC, imC );
std::complex<double> z_n ( 0, 0 );
iteracio = 0;
while ( std::abs ( z_n ) < 4 && iteracio < iteraciosHatar ) { z_n = z_n * z_n + c;
++iteracio;
}
kep.set_pixel ( k, j,
                          png::rgb_pixel ( iteracio%255, (iteracio*iteracio)%255, 0 ) );
        }

      int szazalek = ( double ) j / ( double ) magassag * 100.0;
      std::cout << "\r" << szazalek << "%" << std::flush;
    }

  kep.write ( argv[1] );
  std::cout << "\r" << argv[1] << " mentve." << std::endl;

}
]]></programlisting>
<para>
    Ebben a kódrészben történik a halmaz előállítása, 
    a reC és imC változók értékmegadása,a c és z_n inicializálása.
    egy while ciklusban iteráljuka z_n változót, megszorozzuk önmagával és hozzáadjuk a c-t.
    Amíg a z_n abszolutértéke kissebb mint 4, és az iteráció kissebb, mint az iterációs határ.
    Alatta láthatjuk a kép elkészítését a set_pixel funkcióval.
    Ezalatt található egy visszajelzés, majd végül a kep.write funkció segítségével az 1. argumentumba megadott 
    fájlnévként kimenti a program a képet.
    Végül pedig kiírja annak nevét a konzolra.
    </para>     
    </section>        
                
    <section>
        <title>Biomorfok</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/IJMbgRzY76E">https://youtu.be/IJMbgRzY76E</link>
        </para>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/Biomorf">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/Biomorf</link>
        </para>
        <para>
            A biomorfokra (a Julia halmazokat rajzoló bug-os programjával) 
            rátaláló Clifford Pickover azt hitte természeti törvényre 
            bukkant: <link xlink:href="https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf">https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf</link> (lásd a 2307. oldal aljától).
        </para>       
        <para>
            A különbség a <link xlink:href="#bhax-textbook-feladatok-mandelbrot.Mandelbrot">Mandelbrot halmaz</link>
            és a Julia halmazok között az, hogy a komplex iterációban az előbbiben a c változó, utóbbiban pedig állandó. 
            A következő Mandelbrot csipet azt mutatja, hogy a c befutja a vizsgált összes rácspontot.
        </para>       
        <programlisting language="c++">
<![CDATA[  // j megy a sorokon
  for ( int j = 0; j < magassag; ++j )
    {
      for ( int k = 0; k < szelesseg; ++k )
        {

          // c = (reC, imC) a halo racspontjainak
          // megfelelo komplex szam

          reC = a + k * dx;
          imC = d - j * dy;
          std::complex<double> c ( reC, imC );

          std::complex<double> z_n ( 0, 0 );
          iteracio = 0;

          while ( std::abs ( z_n ) < 4 && iteracio < iteraciosHatar )
            {
              z_n = z_n * z_n + c;

              ++iteracio;
            }
]]>
        </programlisting>        
        <para>
            Ezzel szemben a Julia halmazos csipetben a cc nem változik, hanem minden vizsgált
            z rácspontra ugyanaz.
        </para>
        <programlisting language="c++">
<![CDATA[    // j megy a sorokon
    for ( int j = 0; j < magassag; ++j )
    {
        // k megy az oszlopokon
        for ( int k = 0; k < szelesseg; ++k )
        {
            double reZ = a + k * dx;
            double imZ = d - j * dy;
            std::complex<double> z_n ( reZ, imZ );

            int iteracio = 0;
            for (int i=0; i < iteraciosHatar; ++i)
            {
                z_n = std::pow(z_n, 3) + cc;
                if(std::real ( z_n ) > R || std::imag ( z_n ) > R)
                {
                    iteracio = i;
                    break;
                }
            }
]]>
        </programlisting>                         
        
        <para>
            A bimorfos algoritmus pontos megismeréséhez ezt a cikket javasoljuk: 
            <link xlink:href="https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf">https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf</link>.
            Az is jó gyakorlat, ha magából ebből a cikkből from scratch kódoljuk be a sajátunkat, de mi a királyi úton járva a 
            korábbi <link xlink:href="#bhax-textbook-feladatok-mandelbrot.Mandelbrot">Mandelbrot halmazt</link> kiszámoló 
            forrásunkat módosítjuk. Viszont a program változóinak elnevezését összhangba hozzuk a közlemény jelöléseivel:
        </para>       
        <programlisting language="c++">
<![CDATA[// Verzio: 3.1.3.cpp
// Forditas:
// g++ 3.1.3.cpp -lpng -O3 -o 3.1.3
// Futtatas:
// ./3.1.3 bmorf.png 800 800 10 -2 2 -2 2 .285 0 10
// Nyomtatas:
// a2ps 3.1.3.cpp -o 3.1.3.cpp.pdf -1 --line-numbers=1  --left-footer="BATF41 HAXOR STR34M" --right-footer="https://bhaxor.blog.hu/" --pro=color
// 
// BHAX Biomorphs
// Copyright (C) 2019
// Norbert Batfai, batfai.norbert@inf.unideb.hu
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.
//
// Version history
//
// https://youtu.be/IJMbgRzY76E
// See also https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf
//

#include <iostream>
#include "png++/png.hpp"
#include <complex>

int
main ( int argc, char *argv[] )
{

    int szelesseg = 1920;
    int magassag = 1080;
    int iteraciosHatar = 255;
    double xmin = -1.9;
    double xmax = 0.7;
    double ymin = -1.3;
    double ymax = 1.3;
    double reC = .285, imC = 0;
    double R = 10.0;

    if ( argc == 12 )
    {
        szelesseg = atoi ( argv[2] );
        magassag =  atoi ( argv[3] );
        iteraciosHatar =  atoi ( argv[4] );
        xmin = atof ( argv[5] );
        xmax = atof ( argv[6] );
        ymin = atof ( argv[7] );
        ymax = atof ( argv[8] );
        reC = atof ( argv[9] );
        imC = atof ( argv[10] );
        R = atof ( argv[11] );

    }
    else
    {
        std::cout << "Hasznalat: ./3.1.2 fajlnev szelesseg magassag n a b c d reC imC R" << std::endl;
        return -1;
    }

    png::image < png::rgb_pixel > kep ( szelesseg, magassag );

    double dx = ( xmax - xmin ) / szelesseg;
    double dy = ( ymax - ymin ) / magassag;

    std::complex<double> cc ( reC, imC );

    std::cout << "Szamitas\n";

    // j megy a sorokon
    for ( int y = 0; y < magassag; ++y )
    {
        // k megy az oszlopokon

        for ( int x = 0; x < szelesseg; ++x )
        {

            double reZ = xmin + x * dx;
            double imZ = ymax - y * dy;
            std::complex<double> z_n ( reZ, imZ );

            int iteracio = 0;
            for (int i=0; i < iteraciosHatar; ++i)
            {

                z_n = std::pow(z_n, 3) + cc;
                //z_n = std::pow(z_n, 2) + std::sin(z_n) + cc;
                if(std::real ( z_n ) > R || std::imag ( z_n ) > R)
                {
                    iteracio = i;
                    break;
                }
            }

            kep.set_pixel ( x, y,
                            png::rgb_pixel ( (iteracio*20)%255, (iteracio*40)%255, (iteracio*60)%255 ));
        }

        int szazalek = ( double ) y / ( double ) magassag * 100.0;
        std::cout << "\r" << szazalek << "%" << std::flush;
    }

    kep.write ( argv[1] );
    std::cout << "\r" << argv[1] << " mentve." << std::endl;

}
]]>
        </programlisting>                                 
      <para>A mandelbrothoz képest ez a program több argumentummal rendelkezik, 9 helyett 12 van.
      Az új argumentumok a <command>d,reC,imC és az R</command>.
      A reC és imC argumentumokból állítsuk elő a cc-t.
       Megtörténik a halmaz előállítása, a z_n változó harmadik hatványra emelése és cc hozzáadása. 
    Ha az R(valós) kissebb, mint a z_n, vagy ha R(képzetes) kissebb, mint z_n, akkor 
    az iteracio változó értékét i-vel tesszük egyenlővé.
    Alatta láthatjuk a kép elkészítését a set_pixel funkcióval.
    Ezalatt található egy visszajelzés, majd végül a kep.write funkció segítségével az 1. argumentumba megadott 
    fájlnévként kimenti a program a képet.
    Végül pedig kiírja annak nevét a konzolra.
      </para>                               
                                                                            
    </section>                     

    <section>
        <title>A Mandelbrot halmaz CUDA megvalósítása</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/gvaqijHlRUs">https://youtu.be/gvaqijHlRUs</link>
        </para>
        <para>
            Megoldás forrása:                
 <link xlink:href="../../../bhax/attention_raising/CUDA/mandelpngc_60x60_100.cu">
                <filename>bhax/attention_raising/CUDA/mandelpngc_60x60_100.cu</filename>
            </link> nevű állománya.            
        </para>
    </section>                     

    <section>
        <title>Mandelbrot nagyító és utazó C++ nyelven</title>
        <para>
            Építs GUI-t a Mandelbrot algoritmusra, lehessen egérrel nagyítani egy területet, illetve egy pontot
            egérrel kiválasztva vizualizálja onnan a komplex iteréció bejárta z<subscript>n</subscript> komplex számokat!
        </para>
        <para>
            Megoldás videó: <link xlink:href=""/>
            Illetve <link xlink:href="https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal">https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal</link>.        </para>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása: <link xlink:href="https://github.com/ghjbku/DE/tree/master/sajat/biomoprhs"/>
        </para>
        <para>Ezen feladat megoldása hihetetlenül sokáig tartott, és ez alatt nem a program megírását értem, hanem annak lefordítását.
        a legnagyobb fejfájást a makefile legenerálása okozta, viszont hosszas keresgélés után ráleltem a megoldásra, ami egyetlen sor:<command>sudo apt-get install qt5-default</command> ezután jöhet a <command>qmake -project</command> parancs, amivel létrehozzuk a *.pro fájlunkat, ebből lesz a make fájl.
        A makefile legenerálása ezen parancs beírásával történik: <command>qmake profájlneve.pro</command>, majd <command>make</command> és már futtatható a program.
        a képet a jobb egérgomb használatával lehet nagyítani.</para>
    </section>                     
                                                                                                                                                                            
    <section>
        <title>Mandelbrot nagyító és utazó Java nyelven</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/Ui3B6IJnssY">https://youtu.be/Ui3B6IJnssY</link>, 4:27-től.
            Illetve <link xlink:href="https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal">https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal</link>.
        </para>
        <para>
	Köszönet a forráskódért:<link xlink:href="https://github.com/lovaszbotond/Mandelbrot/blob/master/Javanagyito">Lovász Botond</link>        </para>
       <programlisting><![CDATA[
import java.awt.*;
import java.awt.image.BufferedImage;
import javax.swing.*;
import java.awt.event.*;
 
public class Mandelbrot extends JFrame implements ActionListener {
 
	private JPanel ctrlPanel;
	private JPanel btnPanel;
    private int numIter = 50;
    private double zoom = 130;
    private double zoomIncrease = 100;
    private int colorIter = 20;
    private BufferedImage I;
    private double zx, zy, cx, cy, temp;
    private int xMove, yMove = 0;
    private JButton[] ctrlBtns = new JButton[9];
    private Color themeColor = new Color(150,180,200);
 
    public Mandelbrot() {
        super("Mandelbrot Set");
        setBounds(100, 100, 800, 600);
        setResizable(false);
        setDefaultCloseOperation(EXIT_ON_CLOSE);
        plotPoints();
        
        Container contentPane = getContentPane();
        
        contentPane.setLayout(null);
        
        
        
        
        ctrlPanel = new JPanel();
        ctrlPanel.setBounds(600,0,200,600);
        ctrlPanel.setBackground(themeColor);
        ctrlPanel.setLayout(null);
        
        btnPanel = new JPanel();
        btnPanel.setBounds(0,200,200,200);
        btnPanel.setLayout(new GridLayout(3,3));
        btnPanel.setBackground(themeColor);
        
        ctrlBtns[1] = new JButton("up");
        ctrlBtns[7] = new JButton("down");
        ctrlBtns[3] = new JButton ("left");
        ctrlBtns[5] = new JButton("right");
        ctrlBtns[2] = new JButton("+");
        ctrlBtns[0] = new JButton("-");
        ctrlBtns[8] = new JButton(">");
        ctrlBtns[6] = new JButton("<");
        ctrlBtns[4] = new JButton();
        
        contentPane.add(ctrlPanel);
        contentPane.add(new imgPanel());
        ctrlPanel.add(btnPanel);
        
        for (int x = 0; x<ctrlBtns.length;x++){
        	btnPanel.add(ctrlBtns[x]);
        	ctrlBtns[x].addActionListener(this);
        }
        
        validate();
        
    }
 
    public class imgPanel extends JPanel{
    	public imgPanel(){
    		setBounds(0,0,600,600);
    		
    	}
    	
    	@Override
    	public void paint (Graphics g){
    		super.paint(g);
    		g.drawImage(I, 0, 0, this);
    	}
    }
    
    public void plotPoints(){
    	I = new BufferedImage(getWidth(), getHeight(), BufferedImage.TYPE_INT_RGB);
        for (int y = 0; y < getHeight(); y++) {
            for (int x = 0; x < getWidth(); x++) {
                zx = zy = 0;
                cx = (x - 320+xMove) / zoom;
                cy = (y - 290+yMove) / zoom;
                int iter = numIter;
                while (zx * zx + zy * zy < 4 && iter > 0) {
                    temp = zx * zx - zy * zy + cx;
                    zy = 2 * zx * zy + cy;
                    zx = temp;
                    iter--;
                }
                I.setRGB(x, y, iter | (iter << colorIter));
            }
        }
    }
    
    public void actionPerformed(ActionEvent ae){
    	String event = ae.getActionCommand();
    	
    	switch (event){
    	case "up":
    		yMove-=100;
    		break;
    	case "down":
    		yMove+=100;
    		break;
    	case "left":
    		xMove-=100;
    		break;
    	case "right":
    		xMove+=100;
    		break;
    	case "+":
    		zoom+=zoomIncrease;
    		zoomIncrease+=100;
    		break;
    	case "-":
    		zoom-=zoomIncrease;
    		zoomIncrease-=100;
    		break;
    	case ">":
    		colorIter++;
    		break;
    	case "<":
    		colorIter--;
    		break;
    	}
    	
    	
    	
    	plotPoints();
    	validate();
    	repaint();
    }
    
    
    
 
    public static void main(String[] args) {
        new Mandelbrot().setVisible(true);
    }
}
]]></programlisting>
<para>A program hasonlóképp funkcionál, mint a c++ verzió, viszont itt már több lehetőségünk van manipulálni a mutatott képet.
</para><para>Először létrehozzuk a "ctrlBtns[*]" változókat, majd lehallgatjuk őket a <command>ctrlBtns[x].addActionListener(this)</command> parancssal.
A Switch-ben inicializáljuk a gombok funkcióját.
A felfelé nyíl esetén az y koordinátánkat csökkentsük 100-al, lefelé nyíl esetén növeljük azt.
Bal nyíl megnyomására az x koordináta csökken 100-al, jobb nyíl-nál pedig növekszik.
A plusz gomb nagyít a képen, a mínusz nyíl távolít.
Végül a két kacsacsőr a szín megjelenítésén változtat.

</para>
    </section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Welch!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Első osztályom</title>
        <para>
            Valósítsd meg C++-ban és Java-ban az módosított polártranszformációs algoritmust! A matek háttér 
            teljesen irreleváns, csak annyiban érdekes, hogy az algoritmus egy számítása során két normálist
            számol ki, az egyiket elspájzolod és egy további logikai taggal az osztályban jelzed, hogy van vagy
            nincs eltéve kiszámolt szám.
        </para>
        <para>
            Megoldás videó:
        </para>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása Java-ban:                
        </para>
        <programlisting language="java"><![CDATA[
        public class PolárGenerátor {
    
    boolean nincsTárolt = true;
    double tárolt;
    
    public PolárGenerátor() {
        
        nincsTárolt = true;
        
    }
    
    public double következő() {
        
        if(nincsTárolt) {
            
            double u1, u2, v1, v2, w;
            do {
                u1 = Math.random();
                u2 = Math.random();
                
                v1 = 2*u1 - 1;
                v2 = 2*u2 - 1;
                
                w = v1*v1 + v2*v2;
                
            } while(w > 1);
            
            double r = Math.sqrt((-2*Math.log(w))/w);
            
            tárolt = r*v2;
            nincsTárolt = !nincsTárolt;
            
            return r*v1;
            
        } else {
            nincsTárolt = !nincsTárolt;
            return tárolt;
        }
    }
    
    public static void main(String[] args) {
        
        PolárGenerátor g = new PolárGenerátor();
        
        for(int i=0; i<10; ++i)
            System.out.println(g.következő());
        
    }
    
}]]></programlisting>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása C++-ban:                
        </para>
        <programlisting language="c++"><![CDATA[#include "std_lib_facilities.h" 


class PolarGenerator{

bool nincsTarolt=true;
double tarolt;

 public :
double kovetkezo()
 {
	

	if(nincsTarolt)
	{
	double u1,u2,v1,v2,w;
	u1= ((double) rand() / (double)(RAND_MAX));
	u2= ((double) rand() / (double)(RAND_MAX));
	v1=(2*u1)-1;
	v2=(2*u2)-1;
	
	w=(v1*v1)+(v2*v2);
	 while(w>1)
	 {double r = sqrt((-2*log(w))/w);
	  tarolt=r*v2;
	  nincsTarolt=!nincsTarolt;
	  return r*v1;
	 }
	}
	else
	{
	 nincsTarolt=!nincsTarolt;
	return tarolt;
	}
 };

};

int main()
{
std::srand(std::time(0));
PolarGenerator g;
for(int i=0; i<10; ++i)
	std::cout<<g.kovetkezo()<<std::endl;
return 0;
}]]></programlisting>
        <para>
            Tanulságok, tapasztalatok, magyarázat... térj ki arra is, hogy a JDK forrásaiban a Sun programozói
            pont úgy csinálták meg ahogyan te is, azaz az OO nemhogy nem nehéz, hanem éppen természetes neked!
        
        A java forrás szemantikailag megegyezik a JDK forrásokkal.
        </para>  
        <para>A Java kódhoz képes van egy kis változtatás a kódban.
        Már az elején található egy különbség, a <command>public</command> kulcsszó, amely Java-ban minden függvény elé bekerül, amit public-ként szeretnénk kezelni, amíg C++-ban egy egyszerű <command>public:</command> kulcsszó után bármennyi függvényt deklarálhatunk, az minden publikus lesz.</para>
        <para>Egy másik különbség, hogy amíg Java-ban a matematikai műveleteket a <command>Math.művelet</command> előtaggal hívjuk meg, addig C++-ban az összes ilyen művelet függvényként van beépítve egy cmath header fájlba, így csak a függvény neveit kell meghívnunk.
        Viszont hátrányként tekinthető, hogy az <command>#inculde <![CDATA[<cmath>]]></command> sor nélkül egy művelet se használható.(persze az alapműveletek kivételek: +-*/%)</para>              
    </section>        

    <section>
        <title>LZW</title>
        <para>
            Valósítsd meg C-ben az LZW algoritmus fa-építését!
            <command>Tutorált benne: Nagy Laszló Mihály</command>
        </para>
        <para>
            Megoldás videó:
        </para>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása: </para>
            <programlisting language="c"><![CDATA[// z.c
//
// LZW fa építő
// Programozó Páternoszter
//
// Copyright (C) 2011, Bátfai Norbert, nbatfai@inf.unideb.hu, nbatfai@gmail.com
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
// Ez a program szabad szoftver; terjeszthetõ illetve módosítható a
// Free Software Foundation által kiadott GNU General Public License
// dokumentumában leírtak; akár a licenc 3-as, akár (tetszõleges) késõbbi
// változata szerint.
//
// Ez a program abban a reményben kerül közreadásra, hogy hasznos lesz,
// de minden egyéb GARANCIA NÉLKÜL, az ELADHATÓSÁGRA vagy VALAMELY CÉLRA
// VALÓ ALKALMAZHATÓSÁGRA való származtatott garanciát is beleértve.
// További részleteket a GNU General Public License tartalmaz.
//
// A felhasználónak a programmal együtt meg kell kapnia a GNU General
// Public License egy példányát; ha mégsem kapta meg, akkor
// tekintse meg a <http://www.gnu.org/licenses/> oldalon.
//
//
// Version history:
//
// 0.0.1, http://progpater.blog.hu/2011/02/19/gyonyor_a_tomor
// 0.0.2, csomópontok mutatóinak NULLázása (nem fejtette meg senki :)
// 0.0.3, http://progpater.blog.hu/2011/03/05/labormeres_otthon_avagy_hogyan_dolgozok_fel_egy_pedat
//

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <math.h>

typedef struct binfa
{
  int ertek;
  struct binfa *bal_nulla;
  struct binfa *jobb_egy;

} BINFA, *BINFA_PTR;

BINFA_PTR
uj_elem ()
{
  BINFA_PTR p;

  if ((p = (BINFA_PTR) malloc (sizeof (BINFA))) == NULL)
    {
      perror ("memoria");
      exit (EXIT_FAILURE);
    }
  return p;
}

extern void kiir (BINFA_PTR elem);
extern void ratlag (BINFA_PTR elem);
extern void rszoras (BINFA_PTR elem);
extern void szabadit (BINFA_PTR elem);

int
main (int argc, char **argv)
{
  char b;

  BINFA_PTR gyoker = uj_elem ();
  gyoker->ertek = '/';
  gyoker->bal_nulla = gyoker->jobb_egy = NULL;
  BINFA_PTR fa = gyoker;

  while (read (0, (void *) &b, 1))
    {
//      write (1, &b, 1);
      if (b == '0')
	{
	  if (fa->bal_nulla == NULL)
	    {
	      fa->bal_nulla = uj_elem ();
	      fa->bal_nulla->ertek = 0;
	      fa->bal_nulla->bal_nulla = fa->bal_nulla->jobb_egy = NULL;
	      fa = gyoker;
	    }
	  else
	    {
	      fa = fa->bal_nulla;
	    }
	}
      else
	{
	  if (fa->jobb_egy == NULL)
	    {
	      fa->jobb_egy = uj_elem ();
	      fa->jobb_egy->ertek = 1;
	      fa->jobb_egy->bal_nulla = fa->jobb_egy->jobb_egy = NULL;
	      fa = gyoker;
	    }
	  else
	    {
	      fa = fa->jobb_egy;
	    }
	}
    }

  printf ("\n");
  kiir (gyoker);
  
  extern int max_melyseg, atlagosszeg, melyseg, atlagdb;
  extern double szorasosszeg, atlag;
 

  printf ("melyseg=%d\n", max_melyseg-1);

  /* Átlagos ághossz kiszámítása */
  atlagosszeg = 0;
  melyseg = 0;
  atlagdb = 0;
  ratlag (gyoker);
  // atlag = atlagosszeg / atlagdb;
  // (int) / (int) "elromlik", ezért casoljuk
  // K&R tudatlansági védelem miatt a sok () :)
  atlag = ((double)atlagosszeg) / atlagdb;

  /* Ághosszak szórásának kiszámítása */
  atlagosszeg = 0;
  melyseg = 0;
  atlagdb = 0;
  szorasosszeg = 0.0;

  rszoras (gyoker);

  double szoras = 0.0;

  if (atlagdb - 1 > 0)
    szoras = sqrt( szorasosszeg / (atlagdb - 1));
  else
    szoras = sqrt (szorasosszeg);

  printf ("altag=%f\nszoras=%f\n", atlag, szoras);

  szabadit (gyoker);
}


 // a Javacska ONE projekt Hetedik Szem/TudatSzamitas.java mintajara
 // http://sourceforge.net/projects/javacska/ 
 // az atlag() hivasakor is inicializalni kell oket, a
 // a rekurziv bejaras hasznalja
int atlagosszeg = 0, melyseg = 0, atlagdb = 0;

void
ratlag (BINFA_PTR fa)
{

  if (fa != NULL)
    {
      ++melyseg;
      ratlag (fa->jobb_egy);
      ratlag (fa->bal_nulla);
      --melyseg;

      if (fa->jobb_egy == NULL && fa->bal_nulla == NULL)
	{

	  ++atlagdb;
	  atlagosszeg += melyseg;

	}

    }

}

 // a Javacska ONE projekt Hetedik Szem/TudatSzamitas.java mintajara
 // http://sourceforge.net/projects/javacska/ 
 // az atlag() hivasakor is inicializalni kell oket, a
 // a rekurziv bejaras hasznalja
double szorasosszeg = 0.0, atlag = 0.0;

void
rszoras (BINFA_PTR fa)
{

  if (fa != NULL)
    {
      ++melyseg;
      rszoras (fa->jobb_egy);
      rszoras (fa->bal_nulla);
      --melyseg;

      if (fa->jobb_egy == NULL && fa->bal_nulla == NULL)
	{

	  ++atlagdb;
	  szorasosszeg += ((melyseg - atlag) * (melyseg - atlag));

	}

    }

}

//static int melyseg = 0;
int max_melyseg = 0;

void
kiir (BINFA_PTR elem)
{
  if (elem != NULL)
    {
      ++melyseg;
      if (melyseg > max_melyseg)
	max_melyseg = melyseg;
      kiir (elem->jobb_egy);
      // ez a postorder bejáráshoz képest
      // 1-el nagyobb mélység, ezért -1
      for (int i = 0; i < melyseg; ++i)
	printf ("---");
      printf ("%c(%d)\n", elem->ertek < 2 ? '0' + elem->ertek : elem->ertek,
	      melyseg-1);
      kiir (elem->bal_nulla);
      --melyseg;
    }
}

void
szabadit (BINFA_PTR elem)
{
  if (elem != NULL)
    {
      szabadit (elem->jobb_egy);
      szabadit (elem->bal_nulla);
      free (elem);
    }
}
]]></programlisting>

<para/>
<programlisting language="c"><![CDATA[
BINFA_PTR
uj_elem ()
{
  BINFA_PTR p;

  if ((p = (BINFA_PTR) malloc (sizeof (BINFA))) == NULL)
    {
      perror ("memoria");
      exit (EXIT_FAILURE);
    }
  return p;
}]]></programlisting>
<para>Ez a függvény egy p nevű BINFA_PTR típusú változót hoz létre,
ha a memóriafoglalás nem valósul meg, akkor a <command>perror()</command>-ban megadott szöveget adja vissza, majd kilép az EXIT_FAILURE kulcsszóval.
visszatérési értéke ez a p változó lesz.
</para>
<programlisting language="c"><![CDATA[[
extern void kiir (BINFA_PTR elem);
extern void ratlag (BINFA_PTR elem);
extern void rszoras (BINFA_PTR elem);
extern void szabadit (BINFA_PTR elem);]]></programlisting>
<para>ez a négy függvény extern, ami annyit jelent, hogy globálisan használható.
Egyébként visszatérési értéket nem várnak a függvények, argumentumként pedig egy BINFA_PTR típusú adatot várnak.</para>
    <programlisting language="c">
    <![CDATA[int
main (int argc, char **argv)
{
  char b;

  BINFA_PTR gyoker = uj_elem ();
  gyoker->ertek = '/';
  gyoker->bal_nulla = gyoker->jobb_egy = NULL;
  BINFA_PTR fa = gyoker;
]]>
    </programlisting>
    <para>
    A BINFA_PTR gyoker = uj_elem (); sor egy BINFA_PTR típusú változót hoz létre, és értékül az uj_elem függvény visszatérési értékét kapja, ami a p változó volt.
    Ez a gyoker változó rendelkezik <command>ertek</command> alváltozóval, aminek az értékére a '/' jelet állítsuk be. 
    a következő sorban a gyoker változó bal_nulla és jobb_egy értékeit lenullázzuk.
    Majd létrehozunk egy újabb változót, és értékül adjuk neki a gyoker változót.
    </para>
    <programlisting language="c"><![CDATA[
       if (b == '0')
	{
	  if (fa->bal_nulla == NULL)
	    {
	      fa->bal_nulla = uj_elem ();
	      fa->bal_nulla->ertek = 0;
	      fa->bal_nulla->bal_nulla = fa->bal_nulla->jobb_egy = NULL;
	      fa = gyoker;
	    }
	  else
	    {
	      fa = fa->bal_nulla;
	    }
	}]]></programlisting>
    <para>Nézzük a nullás ágat először:
    ha a b változó 0-át tartalmaz ebben a tickben, akkor :
    Ha a fa változó bal_nulla tagja eddig nem tartlamazott értéket, akkor 
    legyen az értéke az uj_elem függvény visszatérési értéke.
    a bal_nulla változó ertek tag értéke pedig legyen "0";
    Ezután a bal_nulla változóra mutató bal_nulla objektum értékét tesszük egyenlővé a jobb_egy változóéval, és azt lenullázzuk.
    Végül a fa objektumot egyenlővé tesszük a gyoker-rel.
    Ha a bal_nulla nem volt üres, akkor a fa változót tovább léptetjük a bal_nulla ágra.
    </para>
    <programlisting language="c"><![CDATA[  else
	{
	  if (fa->jobb_egy == NULL)
	    {
	      fa->jobb_egy = uj_elem ();
	      fa->jobb_egy->ertek = 1;
	      fa->jobb_egy->bal_nulla = fa->jobb_egy->jobb_egy = NULL;
	      fa = gyoker;
	    }
	  else
	    {
	      fa = fa->jobb_egy;
	    }
	}]]></programlisting>
    <para>Végül jöhet az eggyes ág:
    ha a jobb_egy objektum értéke eddig NULL volt, akkor:
    a jobb_egy legyen az uj_elem függvény p értéke.
    a jobb_egy ertek változó értéke legyen "1".
    A jobb_egy-&gt;bal_nulla objektum értékéül válaszzuk a jobb_egy-et, aminek pedig a NULL értéket adjuk.
    végül a fa objektumot egyenlővé tesszük a gyoker-el.
    Ha a jobb_egy nem volt NULL értékű, akkor a fa változót léptessük oda.</para>
    </section>        
        
    <section>
        <title>Fabejárás</title>
        <para>
            Járd be az előző (inorder bejárású) fát pre- és posztorder is!
        </para>
        <para>
            Megoldás videó:
        </para>

        <para>Preorderbejárás: azaz a gyökér elem majd a bal oldali részfa preorder bejárása, végül ajobboldali részfa preorder bejárása.</para>
         <programlisting language="C"><![CDATA[void
kiir (BINFA_PTR elem)
{
    if (elem != NULL)
        {
        ++melyseg;
        for (int i = 0; i < melyseg; ++i)
            printf ("---");
        printf ("%c(%d)\n", elem->ertek < 2 ? '0' + elem->ertek : elem->ertek,
                melyseg);
        if (melyseg > max_melyseg)
            max_melyseg = melyseg;
            
        kiir (elem->jobb_egy);
        kiir (elem->bal_nulla);
        --melyseg;
    }
}
]]></programlisting>
        <para>Inorderbejárás: azaz először a bal részfa inorder bejárása, majd a gyökérelem, végül ajobboldali részfa inorder bejárása.</para>
        <para>Postorderbejárás: azaz először a bal részfa posztorder bejárása, majd a jobboldali részfaposztorder bejárása, végül a gyökérelem feldolgozása.</para>
         <programlisting language="C"><![CDATA[void
kiir (BINFA_PTR elem)
{
    if (elem != NULL)
    {
        ++melyseg;
        
        if (melyseg > max_melyseg)
            max_melyseg = melyseg;
            
        kiir (elem->jobb_egy);
        kiir (elem->bal_nulla);

        for (int i = 0; i < melyseg; ++i)
            printf ("---");
        printf ("%c(%d)\n", elem->ertek < 2 ? '0' + elem->ertek : elem->ertek,
                melyseg);

        --melyseg;
    }
}
]]></programlisting>
    <para><link xlink:href="http://tananyag.ntszki.hu/BajanF/11-B/fabejaras.pdf">forrás</link></para>
    </section>        
                        
    <section>
        <title>Tag a gyökér</title>
        <para>
            Az LZW algoritmust ültesd át egy C++ osztályba, legyen egy Tree és egy beágyazott Node
            osztálya. A gyökér csomópont legyen kompozícióban a fával!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
         Megoldás forrása: <link xlink:href="https://raw.githubusercontent.com/ghjbku/DE/cpp/z3a7(1).cpp">a nagy forráskód miatt csak linkként jelenítem meg</link>                
     </para>
     <programlisting language="c++"><![CDATA[
     protected:			// ha esetleg egyszer majd kiterjesztjük az osztályt, mert
    // akarunk benne valami újdonságot csinálni, vagy meglévő tevékenységet máshogy... stb.
    // akkor ezek látszanak majd a gyerek osztályban is

    /* A fában tagként benne van egy csomópont, ez erősen ki van tüntetve, Ő a gyökér: */
    Csomopont gyoker;
    int maxMelyseg;
    double atlag, szoras;

    void rmelyseg (Csomopont * elem);
    void ratlag (Csomopont * elem);
    void rszoras (Csomopont * elem);

};]]></programlisting>
<para>
Amint láthatjuk, a binfa osztály protected ágában megtalálható a Csomopont típusú gyoker változó.
a fa objektum jelképezi a tree-t, míg a node-t jelképezi a Csomopont.
</para>
    </section>        
                
    <section>
        <title>Mutató a gyökér</title>
        <para>
          <command>Tutorálva Nagy Krisztián által.</command>
            Írd át az előző forrást, hogy a gyökér csomópont ne kompozícióban, csak aggregációban legyen a 
            fával!
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para><command>A forráskód-részlet Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása:  <link xlink:href="z3a7_gyoker.cpp"/>
        </para>
        <programlisting language="c++"><![CDATA[ LZWBinFa ():fa (gyoker = new Csomopont('/'))
    {
    }
    ~LZWBinFa ()
    {
        szabadit (gyoker->egyesGyermek ());
        szabadit (gyoker->nullasGyermek ());
	delete gyoker;
    }]]></programlisting>
    <para>Ehhez szükségünk lesz arra, hogy az előző feladatban megadott <command>Csomopont gyoker;</command>
    sort átírjuk <command>Csomopont gyoker*;</command>-ra</para>
    <para>Viszont mivel mutató lett belőle, valahol inicializálnunk kell a változót.
    Ezt jelenti a(z) <command><![CDATA[LZWBinFa ():fa (gyoker = new Csomopont('/'))]]></command> sor</para>
    <para>Át kell írnunk továbbá a programban található <command>gyoker</command> változó hívásokat <command>gyoker*</command>-ra.</para>
    <para>Viszont ez még mindíg nem elég, hiszen a memóriafoglalást követően valahogy fel is kell őket szabadítani.
  És itt jön be az ~LZWBinFa destruktor.  
  </para>
    </section>                     

    <section>
        <title>Mozgató szemantika</title>
        <para><command>Tutorált Gila Attila Zoltán</command>
            Írj az előző programhoz mozgató konstruktort és értékadást, a mozgató konstruktor legyen a mozgató
            értékadásra alapozva!
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para><command>A forráskód Tamás Racs tulajdonában áll.</command>
            Megoldás forrása:  
            std::move parancs API: <link xlink:href="https://en.cppreference.com/w/cpp/utility/move"/>
        </para>
        <programlisting language="c++"><![CDATA[
#include <iostream>
#include <fstream>
class LZWBinaryTree
{
public:
LZWBinaryTree ()
{
currentNode = root;
}
~LZWBinaryTree ()
{
free (root);
}
LZWBinaryTree (LZWBinaryTree&& other)
{
root = nullptr;
*this = std::move(other);
}
LZWBinaryTree& operator=(LZWBinaryTree&& other)
{
std::swap(root, other.root);
return *this;
}
void operator<< (char b)
{
if (b == ’0’)
{
if (!currentNode->getLeftChild ())
{
Node *uj = new Node (’0’);
currentNode->newLeftChild (uj);
currentNode = root;
}
else
{
currentNode = currentNode->getLeftChild ();
}
}
else
{
if (!currentNode->getRightChild ())
{
Node *uj = new Node (’1’);
currentNode->newRightChild (uj);
currentNode = root;
}
else
{
currentNode = currentNode->getRightChild ();
}
}
}
void print (void)
{
depth = 0;
print (root, std::cout);
}

int getDepth (void);
friend std::ostream & operator<< (std::ostream & os, LZWBinaryTree & bf ←-
)
{
bf.print (os);
return os;
}
void print (std::ostream & os)
{
depth = 0;
print (root, os);
}
private:
class Node
{
public:
Node (char b = ’/’):value (b), leftChild (0), rightChild (0)
{
};
~Node ()
{
};
Node *getLeftChild () const
{
return leftChild;
}
Node *getRightChild () const
{
return rightChild;
}
void newLeftChild (Node * gy)
{
leftChild = gy;
}
void newRightChild (Node * gy)
{
rightChild = gy;
}
char getValue () const
{
return value;
}
private:
char value;
Node *leftChild;
Node *rightChild;
Node (const Node &);
Node & operator= (const Node &);
};
Node *currentNode;
int depth;
LZWBinaryTree (const LZWBinaryTree &);
LZWBinaryTree & operator= (const LZWBinaryTree &);
void print (Node * n, std::ostream & os)
{
if (n != NULL)
{
++depth;
print (n->getLeftChild (), os);
for (int i = 0; i < depth; ++i)
os << "---";
os << n->getValue () << "(" << depth << ")" << std::endl;
print (n->getRightChild (), os);
--depth;
}
}
void free (Node * n)
{
if (n != NULL)
{
free (n->getLeftChild ());
free (n->getRightChild ());
delete n;
}
}
protected:
Node* root = new Node();
int maxDepth;
void getDepthRec (Node * n);
};
int LZWBinaryTree::getDepth (void)
{
depth = maxDepth = 0;
getDepthRec (root);
return maxDepth;
}
void LZWBinaryTree::getDepthRec (Node * n)
{
if (n != NULL)
{
++depth;
if (depth > maxDepth)
maxDepth = depth;
getDepthRec (n->getRightChild ());
getDepthRec (n->getLeftChild ());
--depth;
}
}
void usage (void)
{
std::cout << "Usage: lzwtree in_file" << std::endl;
}
int main (int argc, char *argv[])
{
if (argc != 2)
{
usage ();
return -1;
}
char *inFile = *++argv;
std::fstream beFile (inFile, std::ios_base::in);
if (!beFile)
{
std::cout << inFile << "Nem létezik a bemeneti fájl!" << std::endl;
usage ();
return -3;
}
char b;
LZWBinaryTree binFa;
while (beFile.read ((char *) &b, sizeof (char)))
{
if(b == ’0’)
{
binFa << b;
}
else if(b == ’1’)
{
binFa << b;
}
}
std::cout << "Eredeti fa:\n\n";
std::cout << binFa;
std::cout << "depth = " << binFa.getDepth () << std::endl;
LZWBinaryTree binFa2 = std::move(binFa);
std::cout << "\nEredeti fa mozgatás után:\n";
std::cout << binFa;
std::cout << "depth = " << binFa.getDepth () << std::endl;
std::cout << "\nMozgatással létrejött fa:\n\n";
std::cout << binFa2;
std::cout << "depth = " << binFa2.getDepth () << std::endl;
beFile.close ();
return 0;
}
]]>
</programlisting>
<para>A lent található két függvény teszi lehetővé az objektumok mozgatását.</para>
<para>Amint láthatjuk, az első sorban a jelenlegi root-ot lecseréli a program nullptr-re, majd 
a *this, tehát ezen tree értékét egyenlővé teszi az std::move(other) funkció visszatérési értékével.
Maga a move függvény nem tesz semmit az objektumunkkal, egyszerűen csak a baloldali értékből
jobboldali értéket készít.</para>
 <programlisting language="c++"><![CDATA[
LZWBinaryTree (LZWBinaryTree&& other)
{
root = nullptr;
*this = std::move(other);
}]]></programlisting>
<para>Majd az std::swap függvény segítségével kicseréljük a két objektum memóriacímét,
végül visszatérési értékként a *this pointert adjuk meg. </para>
 <programlisting language="c++">
 <![CDATA[
LZWBinaryTree& operator=(LZWBinaryTree&& other)
{
std::swap(root, other.root);
return *this;
}]]>
 </programlisting>

    </section>                     
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Conway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Hangyaszimulációk</title>
        <para>
            Írj Qt C++-ban egy hangyaszimulációs programot, a forrásaidról utólag reverse engineering jelleggel
            készíts UML osztálydiagramot is!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/10/10/myrmecologist">https://bhaxor.blog.hu/2018/10/10/myrmecologist</link>
        </para>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása: <link xlink:href=""/>               
        </para>
         <figure>
            <title>A hangyaszimuláció UML diagram</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="hangya/changya8.png" scale="50"/>
                </imageobject>
                <textobject>
                    <phrase>A hangyák akcióban</phrase>
                </textobject>
            </mediaobject>
        </figure>  
         <figure>
            <title>A hangyák akcióban</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="hangya/hangya.png" scale="30"/>
                </imageobject>
                <textobject>
                    <phrase>A hangyák akcióban</phrase>
                </textobject>
            </mediaobject>
        </figure>  
        <programlisting language="c++"><![CDATA[// BHAX Myrmecologist
//
// Copyright (C) 2019
// Norbert Bátfai, batfai.norbert@inf.unideb.hu
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.
//
// https://bhaxor.blog.hu/2018/09/26/hangyaszimulaciok
// https://bhaxor.blog.hu/2018/10/10/myrmecologist
// 

#include <QApplication>
#include <QDesktopWidget>
#include <QDebug>
#include <QDateTime>
#include <QCommandLineOption>
#include <QCommandLineParser>

#include "antwin.h"

/*
 * 
 * ./myrmecologist -w 250 -m 150 -n 400 -t 10 -p 5 -f 80 -d 0 -a 255 -i 3 -s 3  -c 22
 *
 */

int main ( int argc, char *argv[] )
{

    QApplication a ( argc, argv );

    QCommandLineOption szeles_opt ( {"w","szelesseg"}, "Oszlopok (cellakban) szama.", "szelesseg", "200" );
    QCommandLineOption magas_opt ( {"m","magassag"}, "Sorok (cellakban) szama.", "magassag", "150" );
    QCommandLineOption hangyaszam_opt ( {"n","hangyaszam"}, "Hangyak szama.", "hangyaszam", "100" );
    QCommandLineOption sebesseg_opt ( {"t","sebesseg"}, "2 lepes kozotti ido (millisec-ben).", "sebesseg", "100" );
    QCommandLineOption parolgas_opt ( {"p","parolgas"}, "A parolgas erteke.", "parolgas", "8" );
    QCommandLineOption feromon_opt ( {"f","feromon"}, "A hagyott nyom erteke.", "feromon", "11" );
    QCommandLineOption szomszed_opt ( {"s","szomszed"}, "A hagyott nyom erteke a szomszedokban.", "szomszed", "3" );
    QCommandLineOption alapertek_opt ( {"d","alapertek"}, "Indulo ertek a cellakban.", "alapertek", "1" );
    QCommandLineOption maxcella_opt ( {"a","maxcella"}, "Cella max erteke.", "maxcella", "50" );
    QCommandLineOption mincella_opt ( {"i","mincella"}, "Cella min erteke.", "mincella", "2" );
    QCommandLineOption cellamerete_opt ( {"c","cellameret"}, "Hany hangya fer egy cellaba.", "cellameret", "4" );
    QCommandLineParser parser;

    parser.addHelpOption();
    parser.addVersionOption();
    parser.addOption ( szeles_opt );
    parser.addOption ( magas_opt );
    parser.addOption ( hangyaszam_opt );
    parser.addOption ( sebesseg_opt );
    parser.addOption ( parolgas_opt );
    parser.addOption ( feromon_opt );
    parser.addOption ( szomszed_opt );
    parser.addOption ( alapertek_opt );
    parser.addOption ( maxcella_opt );
    parser.addOption ( mincella_opt );
    parser.addOption ( cellamerete_opt );

    parser.process ( a );

    QString szeles = parser.value ( szeles_opt );
    QString magas = parser.value ( magas_opt );
    QString n = parser.value ( hangyaszam_opt );
    QString t = parser.value ( sebesseg_opt );
    QString parolgas = parser.value ( parolgas_opt );
    QString feromon = parser.value ( feromon_opt );
    QString szomszed = parser.value ( szomszed_opt );
    QString alapertek = parser.value ( alapertek_opt );
    QString maxcella = parser.value ( maxcella_opt );
    QString mincella = parser.value ( mincella_opt );
    QString cellameret = parser.value ( cellamerete_opt );

    qsrand ( QDateTime::currentMSecsSinceEpoch() );

    AntWin w ( szeles.toInt(), magas.toInt(), t.toInt(), n.toInt(), feromon.toInt(), szomszed.toInt(), parolgas.toInt(),
                  alapertek.toInt(), mincella.toInt(), maxcella.toInt(),
                  cellameret.toInt() );

    w.show();

    return a.exec();
}]]></programlisting>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
            A hangyaszimuláció célja a hangyák viselkedésének rekonstruálása.
            A hangyák a szaglásuk segítségével tájékozódnak, mindíg a legerősebb szagot követik és ha szagot fognak, ők maguk is elkezdenek szagot kibocsátani, így a többi hangya is arra az útra jön.
            A szimulációhoz szükségünk van a QT5-ös verziójára.
        </para> 
        <para>
        Ez a forráskód a grafikus megjelenítési beállításokat és a hangyák tulajdonságait tartalmazza:
        A <command>QCommandLineOption szeles_opt</command> rész az ablak szélességét,
        A <command>QCommandLineOption magas_opt</command> pedig a magasságát.
          A <command>QCommandLineOption hangyaszam_opt</command>, <command>QCommandLineOption sebesseg_opt</command>,
          <command>QCommandLineOption parolgas_opt</command>, <command>QCommandLineOption feromon_opt</command> és
           <command>QCommandLineOption szomszed_opt</command>
          sorok a hangyák tulajdonságait szabályozzák.
        A <command>parser</command> parancs adja hozzá az ablakot a kerethez.     
        A <command>w.show();</command> parancs jeleníti meg az ablakot, és a végén a program visszatér az <command>a.exec()</command> objektummal.
        </para>           
    </section>        
    <section>
        <title>Java életjáték</title>
        <para>
        
            Írd meg Java-ban a John Horton Conway-féle életjátékot, 
            valósítsa meg a sikló-kilövőt!
        <command>Tutoráltam Nagy Krisztiánt </command>
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása: <link xlink:href="https://github.com/ghjbku/DE/blob/master/sajat/eletjatek/Sejtautomata.java"/>               
        </para>
        <para>
        </para>
        <programlisting language="java">
        <![CDATA[public class Sejtautomata extends java.awt.Frame implements Runnable {
    public static final boolean ÉLŐ = true;
    public static final boolean HALOTT = false;
    protected boolean [][][] rácsok = new boolean [2][][];
    protected boolean [][] rács;
    protected int rácsIndex = 0;
    protected int cellaSzélesség = 20;
    protected int cellaMagasság = 20;
    protected int szélesség = 20;
    protected int magasság = 10;
    protected int várakozás = 1000;
    private java.awt.Robot robot;
    private boolean pillanatfelvétel = false;
    private static int pillanatfelvételSzámláló = 0;

    public Sejtautomata(int szélesség, int magasság) {
        this.szélesség = szélesség;
        this.magasság = magasság;
        rácsok[0] = new boolean[magasság][szélesség];
        rácsok[1] = new boolean[magasság][szélesség];
        rácsIndex = 0;
        rács = rácsok[rácsIndex];
        for(int i=0; i<rács.length; ++i)
            for(int j=0; j<rács[0].length; ++j)
                rács[i][j] = HALOTT;
        siklóKilövő(rács, 5, 60);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent e) {
                setVisible(false);
                System.exit(0);
            }
        });
addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent e) {
                if(e.getKeyCode() == java.awt.event.KeyEvent.VK_K) {
                    cellaSzélesség /= 2;
                    cellaMagasság /= 2;
                    setSize(Sejtautomata.this.szélesség*cellaSzélesség,
                            Sejtautomata.this.magasság*cellaMagasság);
                    validate();
                } else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_N) {
                    cellaSzélesség *= 2;
                    cellaMagasság *= 2;
                    setSize(Sejtautomata.this.szélesség*cellaSzélesség,
                            Sejtautomata.this.magasság*cellaMagasság);
                    validate();
                } else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_S)
                    pillanatfelvétel = !pillanatfelvétel;
                else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_G)
                    várakozás /= 2;
                else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_L)
                    várakozás *= 2;
                repaint();
            }
        });

        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent m) {
                int x = m.getX()/cellaSzélesség;
                int y = m.getY()/cellaMagasság;
                rácsok[rácsIndex][y][x] = !rácsok[rácsIndex][y][x];
                repaint();
            }
        });

        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent m) {
                int x = m.getX()/cellaSzélesség;
                int y = m.getY()/cellaMagasság;
                rácsok[rácsIndex][y][x] = ÉLŐ;
                repaint();
            }
        });
 cellaSzélesség = 10;
        cellaMagasság = 10;
        try {
            robot = new java.awt.Robot(
                    java.awt.GraphicsEnvironment.
                    getLocalGraphicsEnvironment().
                    getDefaultScreenDevice());
        } catch(java.awt.AWTException e) {
            e.printStackTrace();
        }

        setTitle("Sejtautomata");
        setResizable(false);
        setSize(szélesség*cellaSzélesség,
                magasság*cellaMagasság);
        setVisible(true);
        new Thread(this).start();
 }


public void paint(java.awt.Graphics g) {
        boolean [][] rács = rácsok[rácsIndex];
        for(int i=0; i<rács.length; ++i) {
            for(int j=0; j<rács[0].length; ++j) {
                if(rács[i][j] == ÉLŐ)
                    g.setColor(java.awt.Color.BLACK);
                else
                    g.setColor(java.awt.Color.WHITE);
                g.fillRect(j*cellaSzélesség, i*cellaMagasság,
                        cellaSzélesség, cellaMagasság);
                g.setColor(java.awt.Color.LIGHT_GRAY);
                g.drawRect(j*cellaSzélesség, i*cellaMagasság,
                        cellaSzélesség, cellaMagasság);
            }
        }

        if(pillanatfelvétel) {
            pillanatfelvétel = false;
            pillanatfelvétel(robot.createScreenCapture
                    (new java.awt.Rectangle
                    (getLocation().x, getLocation().y,
                    szélesség*cellaSzélesség,
                    magasság*cellaMagasság)));
        }
    }

    public int szomszédokSzáma(boolean [][] rács,
            int sor, int oszlop, boolean állapot) {        
        int állapotúSzomszéd = 0;
        for(int i=-1; i<2; ++i)
            for(int j=-1; j<2; ++j)
                if(!((i==0) && (j==0))) {
            int o = oszlop + j;
            if(o < 0)
                o = szélesség-1;
            else if(o >= szélesség)
                o = 0;
            
            int s = sor + i;
            if(s < 0)
                s = magasság-1;
            else if(s >= magasság)
                s = 0;
            
            if(rács[s][o] == állapot)
                ++állapotúSzomszéd;
                }
        
        return állapotúSzomszéd;
    }
public void időFejlődés() {
        
        boolean [][] rácsElőtte = rácsok[rácsIndex];
        boolean [][] rácsUtána = rácsok[(rácsIndex+1)%2];
        
        for(int i=0; i<rácsElőtte.length; ++i) {
            for(int j=0; j<rácsElőtte[0].length; ++j) {
                
                int élők = szomszédokSzáma(rácsElőtte, i, j, ÉLŐ);
                
                if(rácsElőtte[i][j] == ÉLŐ) {

                    if(élők==2 || élők==3)
                        rácsUtána[i][j] = ÉLŐ;
                    else
                        rácsUtána[i][j] = HALOTT;
                }  else {

                    if(élők==3)
                        rácsUtána[i][j] = ÉLŐ;
                    else
                        rácsUtána[i][j] = HALOTT;
                }
            }
        }
        rácsIndex = (rácsIndex+1)%2;
    }

    public void run() {
        
        while(true) {
            try {
                Thread.sleep(várakozás);
            } catch (InterruptedException e) {}
            
            időFejlődés();
            repaint();
        }
    }

    public void sikló(boolean [][] rács, int x, int y) {
        
        rács[y+ 0][x+ 2] = ÉLŐ;
        rács[y+ 1][x+ 1] = ÉLŐ;
        rács[y+ 2][x+ 1] = ÉLŐ;
        rács[y+ 2][x+ 2] = ÉLŐ;
        rács[y+ 2][x+ 3] = ÉLŐ;
        
    }
public void siklóKilövő(boolean [][] rács, int x, int y) {
        
        rács[y+ 6][x+ 0] = ÉLŐ;
        rács[y+ 6][x+ 1] = ÉLŐ;
        rács[y+ 7][x+ 0] = ÉLŐ;
        rács[y+ 7][x+ 1] = ÉLŐ;
        
        rács[y+ 3][x+ 13] = ÉLŐ;
        
        rács[y+ 4][x+ 12] = ÉLŐ;
        rács[y+ 4][x+ 14] = ÉLŐ;
        
        rács[y+ 5][x+ 11] = ÉLŐ;
        rács[y+ 5][x+ 15] = ÉLŐ;
        rács[y+ 5][x+ 16] = ÉLŐ;
        rács[y+ 5][x+ 25] = ÉLŐ;
        
        rács[y+ 6][x+ 11] = ÉLŐ;
        rács[y+ 6][x+ 15] = ÉLŐ;
        rács[y+ 6][x+ 16] = ÉLŐ;
        rács[y+ 6][x+ 22] = ÉLŐ;
        rács[y+ 6][x+ 23] = ÉLŐ;
        rács[y+ 6][x+ 24] = ÉLŐ;
        rács[y+ 6][x+ 25] = ÉLŐ;
        
        rács[y+ 7][x+ 11] = ÉLŐ;
        rács[y+ 7][x+ 15] = ÉLŐ;
        rács[y+ 7][x+ 16] = ÉLŐ;
        rács[y+ 7][x+ 21] = ÉLŐ;
        rács[y+ 7][x+ 22] = ÉLŐ;
        rács[y+ 7][x+ 23] = ÉLŐ;
        rács[y+ 7][x+ 24] = ÉLŐ;
        
        rács[y+ 8][x+ 12] = ÉLŐ;
        rács[y+ 8][x+ 14] = ÉLŐ;
        rács[y+ 8][x+ 21] = ÉLŐ;
        rács[y+ 8][x+ 24] = ÉLŐ;
        rács[y+ 8][x+ 34] = ÉLŐ;
        rács[y+ 8][x+ 35] = ÉLŐ;
        
        rács[y+ 9][x+ 13] = ÉLŐ;
        rács[y+ 9][x+ 21] = ÉLŐ;
        rács[y+ 9][x+ 22] = ÉLŐ;
        rács[y+ 9][x+ 23] = ÉLŐ;
        rács[y+ 9][x+ 24] = ÉLŐ;
        rács[y+ 9][x+ 34] = ÉLŐ;
        rács[y+ 9][x+ 35] = ÉLŐ;
        
        rács[y+ 10][x+ 22] = ÉLŐ;
        rács[y+ 10][x+ 23] = ÉLŐ;
        rács[y+ 10][x+ 24] = ÉLŐ;
        rács[y+ 10][x+ 25] = ÉLŐ;
        
        rács[y+ 11][x+ 25] = ÉLŐ;
        
    }

    public void pillanatfelvétel(java.awt.image.BufferedImage felvetel) {
        StringBuffer sb = new StringBuffer();
        sb = sb.delete(0, sb.length());
        sb.append("sejtautomata");
        sb.append(++pillanatfelvételSzámláló);
        sb.append(".png");
        try {
            javax.imageio.ImageIO.write(felvetel, "png",
                    new java.io.File(sb.toString()));
        } catch(java.io.IOException e) {
            e.printStackTrace();
        }
    }
  
    public void update(java.awt.Graphics g) {
        paint(g);
    }    
  
    public static void main(String[] args) {
        new Sejtautomata(100, 75);
    }
}



]]>
        </programlisting>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
            A Java verzió ugyanazt tudja, mint a C++ verzió, persze a programnyelv miatt vannak különbségek a forrsákódban.
            A Java kompatibilitása miatt viszont szinte bárhol lefuttatható a program, ahol jvm található.
            A programban megtalálható pár billentyű funkció is, melyekkel a program működését befolyásolhatjuk.
            Az <command>s</command> betű megállítja a programot, a <command>k</command> az ablakot kicsinyíti, míg az <command>n</command> nagyítja.
            van még a <command>g és az l</command>, ezek gyorsítják és lassítják a programot.
        </para>            
    </section>        
    <section>
        <title>Qt C++ életjáték</title>
        <para>
            Most Qt C++-ban!
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása: <link xlink:href="eletjatek/main.cpp"/>               
        </para>
        <figure>
            <title>Az életjáték futás közben</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="eletjatek/elet1.png" scale="50"/>
                </imageobject>
                <textobject>
                    <phrase>A hangyák akcióban</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <programlisting language="c++"><![CDATA[//main.cpp tartalma
#include <QApplication>
#include "sejtablak.h"
#include <QDesktopWidget>

int main(int argc, char *argv[])
{
  QApplication a(argc, argv);
  SejtAblak w(100, 75);
  w.show();
  
  return a.exec();
}
]]></programlisting>
<para>
A main fájl rövid, hiszen csak annyi a dolga, hogy meghívja magát a program-ablakot, melyet meg is tesz ebben a sorban:
<command>SejtAblak w(100,75);</command> itt a sejtablak osztályt felhasználva készítünk egy w objektumot, melyeknek a 100 szélesség és 75
magasság paramétereket adjuk meg.
Majd a következő sorban a w.show(); függvényhívással megjelenítjük azt ablakot.
</para>
<programlisting language="c++"><![CDATA[//sejtablak.h tartalma
#ifndef SEJTABLAK_H
#define SEJTABLAK_H

#include <QMainWindow>
#include <QPainter>
#include "sejtszal.h"

class SejtSzal;

class SejtAblak : public QMainWindow
{
  Q_OBJECT
  
public:
  SejtAblak(int szelesseg = 100, int magassag = 75, QWidget *parent = 0);

  ~SejtAblak();
  // Egy sejt lehet élő
  static const bool ELO = true;
  // vagy halott
  static const bool HALOTT = false;
  void vissza(int racsIndex);
  
protected:
  // Két rácsot használunk majd, az egyik a sejttár állapotút
  // a t_n, a másik a t_n+1 időpillanatban jellemzi.
  bool ***racsok;
  // Valamelyik rácsra mutat, technikai jellegű, hogy ne kelljen a
  // [2][][]-ból az első dimenziót használni, mert vagy az egyikre
  // állítjuk, vagy a másikra.
  bool **racs;
  // Megmutatja melyik rács az aktuális: [rácsIndex][][]
  int racsIndex;
  // Pixelben egy cella adatai.
  int cellaSzelesseg;
  int cellaMagassag;
  
  int szelesseg;
  int magassag;    
  void paintEvent(QPaintEvent*);
  void siklo(bool **racs, int x, int y);
  void sikloKilovo(bool **racs, int x, int y);
  
private:
  SejtSzal* eletjatek;
  
};

#endif // SEJTABLAK_H
]]></programlisting>
 <para>Ha betekintünk a SejtAblak.h fájlba, láthatjuk magát az osztályt, amit a main.cpp-ben felhasználtunk.
 Az osztály public ágában találhatunk egy konstruktort, egy destruktort, és két bool típusú változót, 
 amely a sejtek állapotát szimbolizálja, halott, vagy él.
 A protected ágban megjelenik a ***racsok és a **racs pointer objektumok.
 Itt inicializáljuk a paintEvent funkciót és a két fő objektumunkat is, a siklót és a siklókilövőt.
 Ez utóbbi kettő a **racs pointert használja argumentumként, míg a paintEvent a QT-be integrált QPaintEvent osztályban található tagot használja.
 A fájl elején láthatunk még egy header fájlt, a sejtszal.h-t.

 </para>
 <programlisting language="c++"><![CDATA[//sejtszal.h tartalma
 #ifndef SEJTSZAL_H
#define SEJTSZAL_H

#include <QThread>
#include "sejtablak.h"

class SejtAblak;

class SejtSzal : public QThread
{
    Q_OBJECT

public:
    SejtSzal(bool ***racsok, int szelesseg, int magassag,
             int varakozas, SejtAblak *sejtAblak);
    ~SejtSzal();
    void run();

protected:
    bool ***racsok;
    int szelesseg, magassag;
    // Megmutatja melyik rács az aktuális: [rácsIndex][][]
    int racsIndex;
    // A sejttár két egymást követő t_n és t_n+1 diszkrét időpillanata
    // közötti valós idő.
    int varakozas;
    void idoFejlodes();
    int szomszedokSzama(bool **racs,
                        int sor, int oszlop, bool allapot);
    SejtAblak* sejtAblak;

};

#endif // SEJTSZAL_H
]]></programlisting>
<para>
a SejtSzal egy paraméterezett default konstruktor, mely bekéri a  racsok pointer-t, a szélességet, a magasságot,
a várakozást és egy sejtAblak típusú sejtablak pointert.
Alatta megtalálható a default destruktor az osztályhoz.
A protected ágban is láthatjuk a racsok pointert, a szelesseg és magassag változókat inicializálódni.
Itt deklaráljuk a várakozást, az idoFejlodes funkciót és a szomszedokSzama funkciót, legvégül pedig 
a sejtAblak* sejtAblak objektum is itt jelenik meg.
</para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
            A program forráskódja több fájlra esik szét, melyet <command>make</command> parancssal tudunk egy futtatható fájl-á konvertálni.
             Ez az életjáték a siklóKilövő szimulációt valósítja meg.

        </para>            
    </section>        
    <section>
        <title>BrainB Benchmark</title>
        <para>
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href="/esport-talent-search/"/>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     

<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Gutenberg!</title>
        <keywordset>
            <keyword/>
        </keywordset>
        <cover>
            <para>
                Programozás tankönyvek rövid olvasónaplói.
            </para>
        </cover>
    </info>
    <section>
        <title>Programozási alapfogalmak</title>
        <para>         
            <citation>PICI</citation>       
        </para>
        <para>Egy számítógép programozására három nyelvi szintet különböztetünk meg:</para>
<para>-Gépi kód</para>
<para>-assembly szint</para>
<para>-Magas szint</para>
<para>A magas szintű nyelveken megírt algoritmusokat forráskódoknak nevezzük.
A forráskódok nyelvtani szabályi a szintaktikai szabályok, míg a jelentésbeli, tartalmi szabályzat a szemantika.
Ezeket a kódokat interpreterrel, vagy fordítóprogrammal gépi kóddá kell konvertálni, hogy a processor értelmezni tudja.
Egy fordítóprogram tetszőleges nyelvről tetszőleges nyelvre fordít.Amíg ez az egész kódból egy tárgyprogramot készít, addig az interpreter értelezi és rögtön lefuttatja a kódot, programfájl nélkül.
</para>
<para>
<command>Kifejezések:</command>
Két részből állnak, értékből és típusból.
Egy kifejezés ezekből az összetevőkből áll:</para>
<programlisting language="c">
<![CDATA[-operandus: ez egy literál, változó vagy konstans, ez a kifejezés "értéke".
-operátor: ezek a műveleti jelek, aritmetikai/logikai műveletek végrehajtására.
-kerek zárójelek: a műveleti sorrend befolyásolására.]]>
</programlisting>
<para>
Léteznek konstans kifejezések, ezek értéke fordításkor eldől, a program futása közben nem változik.
</para>
<para>
<command>Utasítások:</command></para><programlisting>
értékadó utasítás: Ezen típusú utasítás a változók értékét módosítja a program futása során.
Üres utasítás: ilyenkor a processor egy üres gépi utasítást hajt végre.
Ugró utasítás: A program egyik soráról a másikra ugrik a vezérlés, általános alak a <command>GOTO</command>.
Elágazásos utasítás(kétfelé ágazás utasítás): A program egy pontján két lehetőség közül választ a program egy feltétel alapján.
Formája: if...then...else...
Többirányú elágazás:A program egy pontján meghatározott számú opciókból kiválaszt egyet, amelyet végrehajt.
A választást egy kifejezés értéke szerint határozzuk meg.
Formája: switch(kifejezés){
case egész_kifejezés: [tevékenység]
case egész_kifejezés: [tevékenység]
default: tevékenység };
A case-ágak értékei különbözzenek.
Ha a case-ágak közül egyik sem egyezik a feltétellel, akkor a default tevékenység hajtódik végre.
</programlisting>
<para>
<command>Blokk:</command>
Egy programegység egy másik program belsejében.Eljárásorientált nyelvekben csak a <command>hatáskör</command>ben van szerepe.
Kétféle hatáskörkezelés létezik, statikus és dinamikus.
Előbbi a fordítási időben valósul meg, a fordítóprogram által.
A hatáskör csak befelé terjed, kintről nem látni, ha a változót látjuk kintről, akkor az globális változó.
A dinamikus hatáskörkezelés futási idő közben zajlik le, azt a rendszer végzi.
Ha szabad nevet talál, a hívási láncon keresztül lépked felfelé, amíg a nevet meg nem találja.
Az Eljárásorientált nyelvek a statikus kezelést használják.

</para>
<para>
<command>I/O</command>:
A programnyelvek azon eszközrendszere, amely a perifériákkal való kommunikációt hajtja végre, az operatív tárból küld, vagy vár adatokat.
Az I/O középpontja az állomány.
Ez lehet logikai és fizikai.
Az előbbi egy olyan programozási eszköz, amely névvel rendelkezik, és állományjellemzői attribútumként vannak jelen.
Fizikai állománynak pedig a hétköznapi, perifériákon megjelenő, adatokat tároló vagy tartalmazó állományt nevezzük.
</para>

    </section>        
    <section>
        <title>Programozás bevezetés</title>
        <para>                
            <citation>KERNIGHANRITCHIE</citation>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/zmfT9miB-jY">https://youtu.be/zmfT9miB-jY</link>
        </para>
        <para>
            A C nyelvben kevés adattípust találhatunk<command>(char, int, float, double)</command>,
             de hozzájuk egyfajta minősítők is tartozhatnak:(short(16 bit), long(32 bit) int).
            ezek Különböző hosszúságú egészeket írnak le.
            Az ún. "bűvös számok" elkerülésére használhatjuk a #define parancsot, amellyel Szimbolikus állandókat hozhatunk létre.
            Használata: #define név behelyettesítendő-szöveg-vagy-szám
       </para>
       <para>
       <command>változóérvényességi tartomány:</command>
       A változók deklarálása általában lokális módon történik,ezek a függvényen kívül nem látszanak, a másik függvény/osztály nem fér hozzájuk.
       Ha azt szeretnénk, hogy a változónk látható legyen a függvényen kívül is, szükségünk lesz a változó elé beírni egy <command>extern</command>
       szót, ezzel globális változóvá téve az eredetileg lokális változót.
       </para>
       <para>
       <command>Változók deklarálása:</command>
       A változók deklarálása 3 féle képpen történhet, lista szerint,szétválasztva, vagy értékadással.
       </para>
       <para>Lista például:<![CDATA[char c,t[5];
       int i,g,k;]]> 
       </para>
        <para>
        szétválasztva: char c; char t[5];int i; int g; int k;
        </para>
        <para>értékadással: char c = 'a'; int i=0;</para>
        <para>Minden változó elé kitehetünk egy const minsősítőt, ha azt szeretnénk, hogy 
        a változó értékét ne lehessen megváltoztatni.</para>
        <para>
        <command>Típuskonverzió:</command>
        atoi függvény, a char típusú változók értékét integerré konvertálja.
        ASCII karakterkészlet esetén használható a lower() függvény, ami a nagybetűket kisbetűkké alakítja.
        </para><para><command>Bitenkénti operátorok:</command>
        A C nyelvben 6 olyan operátor található, amelyet bitenkénti műveletekre használhatunk.
        Ezek az operátorok csak char,short,int,long, és ezek előjeles/előjel nélküli formájára használhatóak.

        </para>
        <programlisting language="c"><![CDATA[&     bitenkénti ÉS-kapcsolat
|     bitenkénti megengedő (inkluzív) VAGY-kapcsolat
^     bitenkénti kizáró (exkluzív) VAGY-kapcsolat
<<    balra léptetés
>>    jobbra léptetés
~     egyes komplemens képzés (unáris)]]></programlisting>
        <para><command>Regiszter változó:</command>
        Ezen fajta deklaráció a fordítóprogrammal közli, hogy az adott változóra gyakran lesz szükségünk, ezért
        regiszterbe helyeztessük, ezzel meggyorsítva a működést, és kissebb méretet kapunk.
        A fordítóprogram nem köteles ezt a kérést teljesíteni, figyelmen kívül is hagyhatja.
        deklarációs forma: register int c; register char g;
        </para>
        <para>
        <command>Rekurzivitás:</command>
        A függvények rekurzívan hívhatják önmagukat, ilyenkor az automatikus változók értékei újramásolódnak az új híváshoz.
        Ezek az értékek egymástól függetlenül léteznek, nincs hatásuk egymásra.

        </para>
        <para>
        <command>Makrók: </command>A #define paranccsal nem csak Szimbolikus állandók hozhatók létre.
        Segítségükkel makrókat is inicializálhatunk, tehát akár egy egész függvényt is egy szóval behelyettesíthetünk.
        Amikor ez a szó idézőjel nélkül, egymagában megjelenik a kódban, akkor a helyettesítési értéke illesztődik be a kódba.

        </para>
        <para>
        <command>Pointerek:</command>
        Ezek olyan változók, amelyek más változók memóriacímét tárolják.
        C-ben gyakran használják a mutatókat, mivel hatékonyság és tömörség növelő hatása van.
        Ha van két változónk, <![CDATA[char c és char* p, és p = &c; a &-jel (egyoperandusú operátor) hozzárendeli a p-hez a c címét.
        Ezt úgy szoktuk mondani, hogy a p c-re mutat.]]> Ez az operátor csak változókra és tömbelemekre használható. 
        
        </para>
        <para>
        <command>Parancssori argumentumok:</command> 
        Lehetőségünk van argumentumok átadására a programunknak a terminálról, ezek az argumentumok 
        a main() függvény *argc* és *argv[]* tagjai.
        az argc egy számot tartalmaz, ez a szám az argumentumok száma.
        Az argv[] tömb pedig az összes argumentumot tartalmazza, argv[0] a program neve.

        </para>
    </section>        
    <section>
        <title>Programozás</title>
        <para>                
            <citation>BMECPP</citation>
            A C++ nyelv a C nyelv továbbfejlesztése, annak kényelmesebb használatára hivatott.
        Alapértelmezett függvényargumentumok és függvénynevek túlterhelése segíti a programozók dolgát.

        </para>
        <para>
        C-ben egy üres paraméterlistával rendelkező függvénynek bármennyi paramétere lehet, ez C++-ban viszont egy paraméter nélküli függvény.
        Amíg C-ben megadhatunk típus nélküli függvényeket, (melyek <command>int</command> típusúak lesznek)
        addig C++-ban nincs Alapértelmezett típus, tehát ez hibát eredményez.
        </para>
        <para>
        C++-ban a <command>main()</command> függvény Alapértelmezetten renelkezik két paraméterrel, az argc és argv[] paraméterekkel, előbbi az argumentumok számát, utóbbi az argumentumokat tárolja.
        C++-ban megjelenik a bool típus, amely logikai értékeket vehet fel.
        Előnye az olvashatóság,valamint operátor túlterhelhetőség.
        </para>
        <para>
        C-ben a több-bájtos stringek eléréséhez meg kellett hívni a fejlécben az <![CDATA[<stddef.h>,<stdlib.h> vagy <wchar.h> fájlokat]]>.
        Ez C++-ban már beépített típus lett, így meghívását egyszerűen megtehetjük: <command>wchar_t text=L"sss";</command>
        </para>
        <para>
        <command>objektumok és osztályok</command>
        </para>
        <para>
        Az objektumorientáltság az 1960-as években kezdődött, és 1990-től terjedt el nagy mértékben.
        Egy egységbe záró adattstruktúra neve az osztály.
        Ezen osztálynak az egyedpéldányai az objektumok.
        Ha azt szeretnénk, hogy a programban más férhessen hozzá egy bizonyos objektumhoz, akkor azt a valahogy meg kell oldanunk.
        Ez a védelmi mechanizmus lesz az "adatrejtés".
        Ezt megtehetjük azzal, hogy az objektum elé egy "private:" kulccsszót írunk.
        Így csak az osztályon belüli tagok férhetnek hozzá az adathoz.
        A dinamikus memóriakezelést C-ben a <command>malloc és free </command> függvénypárossal végeztük.
        A paraméterek átadása miatt C++-ban már nem is függvény felelős a memóriakazelésért, hanem operátor.
        Ez az operátor a <command>new</command>
        </para>
        <programlisting language="c++">
        <![CDATA[int* p;
        p=new int;
        *p=10;
        delete p;//a változó használata után felszabadítjuk a helyét a memóriában
        ]]>
        </programlisting>
        <para>Ha szeretnénk, hogy a private:-ban található objektumainkat az osztályon kívül is el tudjuk érni, szükségünk lesz
        egy <command>Friend</command> függvény vagy osztály megadására az osztályunkban.
         </para><para><command>Konstansok és inline függvények</command></para>
         <para>A konstansokat a "közönséges" változókhoz hasonlóan használhatjuk, viszont ezek értékei nem változhatnak a program futása során.
         Bármiféle változtatás az értékével programhibához vezet. </para>
        <para>Léteznek konstans pointerek is, ezeket kétfélé módon adhatjuk meg, ha a típus elé írjuk, akkor a mutatott érték válik megváltoztathatatlanná.
        </para>
        <para><link xlink:href="elmelet/testprog.c++"/></para>
        <programlisting language="c++"><![CDATA[
        char tomb[5];
        const char* pointer=tomb;
        *pointer="g";//ez fordítási hibához vezet, hiszen ez a mutatott érték
        pointer++; //hiba nélkül lefut]]></programlisting>
        <para>A másik változat, amikor a const-ot a pointer neve elé írjuk, ekkor a mutató lesz megváltoztathatatlan.
        </para>
        <programlisting language="c++"><![CDATA[
        char tomb[5];
        char* const pointer =tomb;
        *pointer="g";//lefut
        pointer++;//fordítási hibát jelez]]></programlisting>
        <para>Ezek kombinálása is lehetséges.</para>
        <para><command>Inline függvények</command></para>
        <para>
        Ezen függvények esetében a fordító behelyettesíti a 
        hívás helyére az inline-ban megadott kódrészt,ezzel
        gyorsítva az általános függvényhívás menetét.</para>
        <para><command>I/O alapok</command></para>
        <para>
        <command>operátor túlterhelés</command></para>
        <para>A c++ nyelvben néhány új operátor lett bevezetve a C-hez képest.
        Ilyen például a hatókör operátor(::), a pointer-tag ooperátor(.* és -&gt;*).
        </para>
        <para/>
    </section>        
</chapter>

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Schwarzenegger!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Szoftmax Py MNIST</title>
        <para>aa
            Python
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <programlisting language="python">
        <![CDATA[# Copyright 2015 The TensorFlow Authors. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================

"""Builds the MNIST network.

Implements the inference/loss/training pattern for model building.

1. inference() - Builds the model as far as is required for running the network
forward to make predictions.
2. loss() - Adds to the inference model the layers required to generate loss.
3. training() - Adds to the loss model the Ops required to generate and
apply gradients.

This file is used by the various "fully_connected_*.py" files and not meant to
be run.
"""
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import math

import tensorflow as tf

# The MNIST dataset has 10 classes, representing the digits 0 through 9.
NUM_CLASSES = 10

# The MNIST images are always 28x28 pixels.
IMAGE_SIZE = 28
IMAGE_PIXELS = IMAGE_SIZE * IMAGE_SIZE


def inference(images, hidden1_units, hidden2_units):
  """Build the MNIST model up to where it may be used for inference.

  Args:
    images: Images placeholder, from inputs().
    hidden1_units: Size of the first hidden layer.
    hidden2_units: Size of the second hidden layer.

  Returns:
    softmax_linear: Output tensor with the computed logits.
  """
  # Hidden 1
  with tf.name_scope('hidden1'):
    weights = tf.Variable(
        tf.truncated_normal([IMAGE_PIXELS, hidden1_units],
                            stddev=1.0 / math.sqrt(float(IMAGE_PIXELS))),
        name='weights')
    biases = tf.Variable(tf.zeros([hidden1_units]),
                         name='biases')
    hidden1 = tf.nn.relu(tf.matmul(images, weights) + biases)
  # Hidden 2
  with tf.name_scope('hidden2'):
    weights = tf.Variable(
        tf.truncated_normal([hidden1_units, hidden2_units],
                            stddev=1.0 / math.sqrt(float(hidden1_units))),
        name='weights')
    biases = tf.Variable(tf.zeros([hidden2_units]),
                         name='biases')
    hidden2 = tf.nn.relu(tf.matmul(hidden1, weights) + biases)
  # Linear
  with tf.name_scope('softmax_linear'):
    weights = tf.Variable(
        tf.truncated_normal([hidden2_units, NUM_CLASSES],
                            stddev=1.0 / math.sqrt(float(hidden2_units))),
        name='weights')
    biases = tf.Variable(tf.zeros([NUM_CLASSES]),
                         name='biases')
    logits = tf.matmul(hidden2, weights) + biases
  return logits


def loss(logits, labels):
  """Calculates the loss from the logits and the labels.

  Args:
    logits: Logits tensor, float - [batch_size, NUM_CLASSES].
    labels: Labels tensor, int32 - [batch_size].

  Returns:
    loss: Loss tensor of type float.
  """
  labels = tf.to_int64(labels)
  cross_entropy = tf.nn.sparse_softmax_cross_entropy_with_logits(
      logits, labels, name='xentropy')
  loss = tf.reduce_mean(cross_entropy, name='xentropy_mean')
  return loss


def training(loss, learning_rate):
  """Sets up the training Ops.

  Creates a summarizer to track the loss over time in TensorBoard.

  Creates an optimizer and applies the gradients to all trainable variables.

  The Op returned by this function is what must be passed to the
  `sess.run()` call to cause the model to train.

  Args:
    loss: Loss tensor, from loss().
    learning_rate: The learning rate to use for gradient descent.

  Returns:
    train_op: The Op for training.
  """
  # Add a scalar summary for the snapshot loss.
  tf.scalar_summary(loss.op.name, loss)
  # Create the gradient descent optimizer with the given learning rate.
  optimizer = tf.train.GradientDescentOptimizer(learning_rate)
  # Create a variable to track the global step.
  global_step = tf.Variable(0, name='global_step', trainable=False)
  # Use the optimizer to apply the gradients that minimize the loss
  # (and also increment the global step counter) as a single training step.
  train_op = optimizer.minimize(loss, global_step=global_step)
  return train_op


def evaluation(logits, labels):
  """Evaluate the quality of the logits at predicting the label.

  Args:
    logits: Logits tensor, float - [batch_size, NUM_CLASSES].
    labels: Labels tensor, int32 - [batch_size], with values in the
      range [0, NUM_CLASSES).

  Returns:
    A scalar int32 tensor with the number of examples (out of batch_size)
    that were predicted correctly.
  """
  # For a classifier model, we can use the in_top_k Op.
  # It returns a bool tensor with shape [batch_size] that is true for
  # the examples where the label is in the top k (here k=1)
  # of all logits for that example.
  correct = tf.nn.in_top_k(logits, labels, 1)
  # Return the number of true entries.
  return tf.reduce_sum(tf.cast(correct, tf.int32))]]>
        </programlisting>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
            Ez a program egy számítógépet betanító program, futtatásához a TensorFlow szükséges.
        Alacsony felbontású képeket analízáltat a számítógéppel, majd ezen képek alapján megpróbál egy másik képről hasonlóságot találni, és kitaláni, hogy mi látható a képen.
Itt konkrétan kézzel írt számokról dönti el, hogy a képen melyik szám látható.
A betanítási folyamat hossza függ a program bonyolultságától, de ez a program egyszerűnek számít, tehát elég könnyen 90% fölé mehet a pontossága, és a betanítási idő is rövid.
a <command>def</command> kulcsszóval definiálhatunk függvényeket.
Az első ilyen függvény az "inference", amely három argumentumot vár:
az <command>images</command>, <command>hidden1_units</command> és <command>hidden2_units</command> argumentumokat.  
Az első a képek helyét jelenti az input() függvényből, a második és a harmadik pedig a rejtett layerek méretét jelenti.
A függvényünk visszatérési értéke a softmax_linear, ez a kiszámolt "logit"-eket tárolja.
        </para>
        <para>A második függvény a loss(logits,labels), ez a logitekből és cimkékből kiszámítja a veszteséget.
        A harmadik függvény felel a betanításért, ez a training(loss,learning_rate).
        Az utolsó függvény az evaluation, amely visszaadja, hogy milyen sikerességgel találta el a program a helyes számot.
        </para>
    </section>        

   <!-- <section>
        <title>Szoftmax R MNIST</title>
        <para>
            R            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
-->
    <section>
        <title>Mély MNIST</title>
        <para>
            Python            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
              <programlisting language="python">
        <![CDATA[
# Copyright 2015 The TensorFlow Authors. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================

"""A deep MNIST classifier using convolutional layers.
See extensive documentation at
https://www.tensorflow.org/get_started/mnist/pros
"""
# Disable linter warnings to maintain consistency with tutorial.
# pylint: disable=invalid-name
# pylint: disable=g-bad-import-order

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import argparse
import sys
import tempfile

from tensorflow.examples.tutorials.mnist import input_data

import tensorflow as tf

FLAGS = None


def deepnn(x):
  """deepnn builds the graph for a deep net for classifying digits.
  Args:
    x: an input tensor with the dimensions (N_examples, 784), where 784 is the
    number of pixels in a standard MNIST image.
  Returns:
    A tuple (y, keep_prob). y is a tensor of shape (N_examples, 10), with values
    equal to the logits of classifying the digit into one of 10 classes (the
    digits 0-9). keep_prob is a scalar placeholder for the probability of
    dropout.
  """
  # Reshape to use within a convolutional neural net.
  # Last dimension is for "features" - there is only one here, since images are
  # grayscale -- it would be 3 for an RGB image, 4 for RGBA, etc.
  with tf.name_scope('reshape'):
    x_image = tf.reshape(x, [-1, 28, 28, 1])

  # First convolutional layer - maps one grayscale image to 32 feature maps.
  with tf.name_scope('conv1'):
    W_conv1 = weight_variable([5, 5, 1, 32])
    b_conv1 = bias_variable([32])
    h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1)

  # Pooling layer - downsamples by 2X.
  with tf.name_scope('pool1'):
    h_pool1 = max_pool_2x2(h_conv1)

  # Second convolutional layer -- maps 32 feature maps to 64.
  with tf.name_scope('conv2'):
    W_conv2 = weight_variable([5, 5, 32, 64])
    b_conv2 = bias_variable([64])
    h_conv2 = tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2)

  # Second pooling layer.
  with tf.name_scope('pool2'):
    h_pool2 = max_pool_2x2(h_conv2)

  # Fully connected layer 1 -- after 2 round of downsampling, our 28x28 image
  # is down to 7x7x64 feature maps -- maps this to 1024 features.
  with tf.name_scope('fc1'):
    W_fc1 = weight_variable([7 * 7 * 64, 1024])
    b_fc1 = bias_variable([1024])

    h_pool2_flat = tf.reshape(h_pool2, [-1, 7*7*64])
    h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)

  # Dropout - controls the complexity of the model, prevents co-adaptation of
  # features.
  with tf.name_scope('dropout'):
    keep_prob = tf.placeholder(tf.float32)
    h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob)

  # Map the 1024 features to 10 classes, one for each digit
  with tf.name_scope('fc2'):
    W_fc2 = weight_variable([1024, 10])
    b_fc2 = bias_variable([10])

    y_conv = tf.matmul(h_fc1_drop, W_fc2) + b_fc2
  return y_conv, keep_prob


def conv2d(x, W):
  """conv2d returns a 2d convolution layer with full stride."""
  return tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding='SAME')


def max_pool_2x2(x):
  """max_pool_2x2 downsamples a feature map by 2X."""
  return tf.nn.max_pool(x, ksize=[1, 2, 2, 1],
                        strides=[1, 2, 2, 1], padding='SAME')


def weight_variable(shape):
  """weight_variable generates a weight variable of a given shape."""
  initial = tf.truncated_normal(shape, stddev=0.1)
  return tf.Variable(initial)


def bias_variable(shape):
  """bias_variable generates a bias variable of a given shape."""
  initial = tf.constant(0.1, shape=shape)
  return tf.Variable(initial)


def main(_):
  # Import data
  mnist = input_data.read_data_sets(FLAGS.data_dir, one_hot=True)

  # Create the model
  x = tf.placeholder(tf.float32, [None, 784])

  # Define loss and optimizer
  y_ = tf.placeholder(tf.float32, [None, 10])

  # Build the graph for the deep net
  y_conv, keep_prob = deepnn(x)

  with tf.name_scope('loss'):
    cross_entropy = tf.nn.softmax_cross_entropy_with_logits(labels=y_,
                                                            logits=y_conv)
  cross_entropy = tf.reduce_mean(cross_entropy)

  with tf.name_scope('adam_optimizer'):
    train_step = tf.train.AdamOptimizer(1e-4).minimize(cross_entropy)

  with tf.name_scope('accuracy'):
    correct_prediction = tf.equal(tf.argmax(y_conv, 1), tf.argmax(y_, 1))
    correct_prediction = tf.cast(correct_prediction, tf.float32)
  accuracy = tf.reduce_mean(correct_prediction)

  graph_location = tempfile.mkdtemp()
  print('Saving graph to: %s' % graph_location)
  train_writer = tf.summary.FileWriter(graph_location)
  train_writer.add_graph(tf.get_default_graph())

  with tf.Session() as sess:
    sess.run(tf.global_variables_initializer())
    for i in range(20000):
      batch = mnist.train.next_batch(50)
      if i % 100 == 0:
        train_accuracy = accuracy.eval(feed_dict={
            x: batch[0], y_: batch[1], keep_prob: 1.0})
        print('step %d, training accuracy %g' % (i, train_accuracy))
      train_step.run(feed_dict={x: batch[0], y_: batch[1], keep_prob: 0.5})

    print('test accuracy %g' % accuracy.eval(feed_dict={
        x: mnist.test.images, y_: mnist.test.labels, keep_prob: 1.0}))

if __name__ == '__main__':
  parser = argparse.ArgumentParser()
  parser.add_argument('--data_dir', type=str,
                      default='/tmp/tensorflow/mnist/input_data',
                      help='Directory for storing input data')
  FLAGS, unparsed = parser.parse_known_args()
tf.app.run(main=main, argv=[sys.argv[0]] + unparsed)]]>
        </programlisting>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
            32 bites képeket használ a betanulási fázisban, ezek egyfajta "neurális hálón" haladnak keresztül, és a gép a csomópontokban megadott feltételek szerint dönt a kép azonosításáról.
            A végén százalékos formában kiírja a pontosságot.
            Ez kissebb erőforrásigényű programoknál 90+% fölé mehet, amely az embernél jobb hatékonyságot jelent.
        </para>
        <para>A legelső függvényünk a deepnn(x), ez a függvény egy gráfot épít ki a mély hálónknak,amely a számokat osztályozza.
        az X argumentum a dimenziók száma.
        Visszatérési értékként az y_conv ls a keep_prob térnek vissza.
        Az y változó a szám alakját adja vissza, 0 és 9 között változhat ez az érték.
        </para>
        <para>
        Következő funkció a conv2d(x,W).
        Ez egy 2d konvulációs réteget ad vissza.
        </para>
        <para>az ez alatt található funkció a max_pool_2x2, ez a függvény csökkenti a mintákat 2x.
        Ezután jön a weight_variable(shape) függvény, amely a nevéből is kideríthetően súlyozást ad a képhez, egy shape alapján.
        Végül a bias_variable, amely ugyancsak a shape alapján állít be bias-t. </para>
        <para>A legvégén található egy main() függvény, amely először importálja az adatokat,majd elkészíti a modellt, a veszteséget kiszámítja és végül felépíti a gráfot.
        </para>
    </section>        

    <section>
        <title>Minecraft-MALMÖ</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/bAPSu3Rndi8">https://youtu.be/bAPSu3Rndi8</link>      
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
            Sajnos nem volt alkalmam beszerezni a játékot.
        </para>
    </section>       
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chaitin!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Iteratív és rekurzív faktoriális Lisp-ben</title>
        <para>
               <command>Az SMNIST-el kiváltva</command> 
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
    </section>        
        
    <!--<section>
        <title>Weizenbaum Eliza programja</title>
        <para>
            Éleszd fel Weizenbaum Eliza programját!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
    </section>        
-->
    <section>
        <title>Gimp Scheme Script-fu: króm effekt</title>
        <para>
            Írj olyan script-fu kiterjesztést a GIMP programhoz, amely megvalósítja a króm effektet egy 
            bemenő szövegre!
		 <command>Az SMNIST-el kiváltva</command>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/OKdAkI_c7Sc">https://youtu.be/OKdAkI_c7Sc</link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Chrome">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Chrome</link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>    
    </section>        

    <section>
        <title>Gimp Scheme Script-fu: név mandala</title>
        <para>
            Írj olyan script-fu kiterjesztést a GIMP programhoz, amely név-mandalát készít a
            bemenő szövegből!               
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2019/01/10/a_gimp_lisp_hackelese_a_scheme_programozasi_nyelv">https://bhaxor.blog.hu/2019/01/10/a_gimp_lisp_hackelese_a_scheme_programozasi_nyelv</link>      
        </para>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Mandala">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Mandala</link>               
        </para>
       
    </section>        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
  <!--  <section>
        <title>Lambda</title>
        <para>
            Hasonlítsd össze a következő programokat!
        </para>
        <para>
            Megoldás videó: <link xlink:href=""></link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""></link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        

    <section>
        <title>Omega</title>
        <para>
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
    </section>        
         -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
</chapter>     
    
            
</part>                                                              

    <part xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Második felvonás</title>
    <partintro>
        <para> 
        </para>
<tip>
              <title>Bátf41 Haxor Stream</title>
              <para>
                  A feladatokkal kapcsolatos élő adásokat sugároz
                  a <link xlink:href="https://www.twitch.tv/nbatfai">https://www.twitch.tv/nbatfai</link> csatorna,
                  melynek permanens archívuma a <link xlink:href="https://www.youtube.com/c/nbatfai">https://www.youtube.com/c/nbatfai</link> 
                  csatornán található.
              </para>            
            </tip>    
        
    </partintro>

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Berners-Lee!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Olvasónaplók</title>
        <para>
C++:Benedek Zoltán,Levendovszky Tihamér Szoftverfejlesztés C++ nyelven
Java: Nyékyné Dr. Gaizler Judit et al. Java 2 útikalauz programozóknak 5.0
ebből a kettőből egy pár oldalas összehasonlító esszé.
Python:Forstner Bertalan,Ekler Péter,Kelényi Imre:Bevezetés a mobilprogramozásba
Gyors prototípus-fejlesztés Python és Java nyelven(35-51 oldal)
-ebből 1-oldalas élmény-napló
	    </para>

        <para>
            <command>C++ és Java összehasonlítás</command>           
        </para>

        <para>
            java-ban minden metódusnak kell visszatérési érték típust adni.
C++-ban viszont nem muszáj, hiszen alapértelmezetten int típust feltételez a program, ha nem adunk neki típust.
A cpp-tól eltérően Java-ban String[]tömb tárolja az argumentumokat
ezzel szemben a C ill. C++-ban argv és argc változó együttes tárolja azokat
argv az argumentumokat tároló vektor, az argc pedig az argumentumok számát tároló változó.
        </para>

        <para>
        logikai típus C++-ban bool, Java-ban boolean.
        </para><para>
basic io művelet java-ban System.out.Println(),  C++-ban std::cout parancs használatával történik.
ezek listázása is eltérő, java-ban a pascal-hoz hasonlóan + jellel fűzünk össze változókat ill. szöveget, Cpp-ban pedig &gt;&gt; jel váltja fel a + szerepét
Továbbá Java-ban nincs operátor túlterhelés!
        </para>

        <para>
        Java-ban a karakterkészlet defaultban utf-8, c++-ban include-olni kell egy library-t, hogy utf-8-as karaktereket használhassunk, anélkül nehézkes a használatuk.
        a konstansok megadása Java-ban a "final" kulcsszó használatával lehetséges, c++-ban ezt a const-al tehetjük meg
        Példák:
        </para>

        
        <programlisting language="java"><![CDATA[final static double pi=3.14;]]></programlisting>
        
        <programlisting language="C++"><![CDATA[const double pi=3.14;]]>
        </programlisting>
        <para>
        Az objektumok elemeire hivatkozhatunk, az <command>"objektum neve"."elem neve"</command> módon.
Ha az elem-nek egy elemére szertnénk hivatkozni, azt hasonló modon kell megtenni.
A java-ban nincs explicit mód a memóriahely felszabadítására, a pointerek NULL-ra állítását tehetjük meg, amit a "garbage collector" később eltűntet.
nincs dekonstruktor, ezzel szemben C-ben és C++-ban van dekonstruktor, amit az objektum elején elhelyezett "~" jellel "állítunk elő".

        </para>
        <programlisting language="C++"><![CDATA[~LZWBinFa ()
    {
        
    }]]></programlisting>
    <para>
    Továbbá C++-ban lehetőségünk van(és kell is) a pointerek által lefoglalt memóriahelyek felszabadítására 3 módszerrel.
    </para>
    <programlisting language="C++"><![CDATA[delete ptr;
ptr=NULL;
//vagy pedig
free(ptr);]]></programlisting>
<para>
C-ben nincs lehetőség a <command>"delete ptr;"</command> módszerre.
A pointer NULL-ra állítása viszont nem szabadítja fel a helyet, csak ún. "árvát" hoz létre, mivel a C++ nem "garbage collector" nyelv.
A lefoglalt terület még fennáll, de nem lehet elérni, és egy memory leak képződik.
Ezek a memória leak-ek csak akkor okoznak nagyobb gondot, ha elfogy a memória, ekkor a program preemptív kilép, "crash-el".
</para>
<para>
Ha egy objektumot a <command>new()</command> metódussal hoztunk létre, akkor a <command>delete</command> paranccsal szabadítsuk fel a helyet, ha a <command>malloc()-ot</command> használtuk memória lefoglaláshoz, akkor a <command>free()</command>-vel szabadítjuk fel a memóriában foglalt helyet.
Fontos tudni, hogy a <command>free()</command> nem hívja a destructor-t, azt csak a <command>delete</command> teszi meg!
</para>
<para>
Mindkét programnyelvben megtalálható az automatikus/implicit típus konverzió.
Ha a fordító program a vártnál eltérő típusú adatot kap, azt automatikusan megpróbálja átkonvertálni a várt típusra.
Ez nem mindíg lehetséges!
Például az egyénileg létrehozott típusokat nem tudja átkonvertálni.
</para>
<para>
A try-catch hibakezelő metódus mindkét nyelvben elérhető.
Ezekről egy-egy példakód itt:</para><para><link xlink:href="https://github.com/ghjbku/prog2/tree/master/elm%C3%A9let/Osztas.java">Java</link> 
</para>
<para>
<link xlink:href="https://github.com/ghjbku/prog2/tree/master/elm%C3%A9let/try_Catch.cpp">C++</link> 
</para>
<para>A  java nyelvben a tömb típus egy igazi típus, amíg c++-ban csak egy mutató típus. mindkét nyelvben 0-val kezdődik az indexelés a tömbben, Továbbá az enum típus is jelen van.
Java-ban a pont minden esetben a tagok elérésére szolgál, és a C++-tól eltérően itt nincs megkülönböztető jelölés osztálytagok elérésénél(C++-ban :: operátor)
</para>
<para>A C és C++-tól eltérően a Java-ban nics GOTO utasítás, azzal a címszóval lett elhagyva, hogy ezáltal biztonságosabb és megbízhatóbb programokat kapunk.
a korábbi goto-val megoldott problémákra új megoldások vannak:
ciklus elhagyása a <command>break</command> utasítással történik, a ciklus folytatása a <command>continue</command> utasítással.
Java-ban a legkissebb önálló egységek az osztályok.</para>
  <para/>



        <para>
            <command>Python könyv élmény-napló </command>           
        </para>
        <para>
        A Python <command>magasszintű, általános célú nyelv</command>, szkriptnyelvként szokták emlegetni.
A kódokat egy futtatókörnyezeten keresztül futtatják általában, viszont vannak már kísérleti stádiumban natív kódot generáló fordítóprogramok is.
Mind a procedurális, és az objektumorientált programozást támogatja
Könyvátárnak mérete a nyelv egyik erősségének mondható, melyben még http támogatás is megtalálható.
C, cpp nyelven készült modulok is egyszerűen adhatók hozzá a környezethez.
Népszerűségét az egyszerűségnek köszönheti, <command>szinte bármilyen feladatot meg lehet oldani a nyelvben</command>, viszont elsősorban kliensszoftverek készítésére alkalmazzák.
A mobileszközökön is futtatható, írható python kód, viszont ez nem újdonság, hiszen java ill. C++ kódokat is futtathatunk manapság.
        </para>

        <para>
	A <command>Symbian OS</command> mobiltelefon operációs rendszer egyike a napjainkban legtöbbet alkalmazott operációs rendszereknek.
	Mind C++-ban, Python-ban és Java-ban is írhatónk rá kódokat, viszont a rendszer felett még ott van egy GUI(Grafikus felhasználói felület), ezekből manapság 2 típus ismert:
	<command>S60(korábban Series60)</command> és az <command>UIQ</command>.
	Hasonló funkcionalitás lelhető fel mindkét rendszerben, viszont ennek ellenére a kettő nem kompatibilitis egymással, az egyikre írt programok nem fognak a másikon elfutni.
	Az operációs rendszer alapfunkcióiban azonban megegyezik, tehát csak az UI-hez kötődő részeket kell külön megírnunk kétféleképpen.
       </para>

        <para>
	A <command>Windows Mobile</command> pedig a Microsoft mobiltelefonokhoz fejlesztett operációsrendszer,amely a Windows CE rendszeren alapul.
	A Symbian-hoz képest több lehetőségünk van a programnyelvek használatát illetően.
	A C++, Python és Java-n kívül natív alkalmazásokat készíthetünk C nyelven is, és persze az ugyancsak Microsoft által fejlesztett .NET compact framework technológiával egyaránt.
	Ez utóbbi a Microsoft .NET telefonokra kifejlesztett változata. 
        </para>

	<para>
	A Harmadik operációsrendszer mobiltelefonokra a nyílt forráskódú, Linux-ra épülő <command>Maemo</command>, ez a rendszer a Nokia fejlesztése alatt áll.
	A rendszer nagyrészben az internetes elérésekre,megoldásokra fókuszál, viszont az alapvető funkciókat ezen a rendszeren is el tudjuk végezni.
Jelenleg a Bluetooth és WLAN funkciókat támogatja, de már a Wimax támogatását is híresztelik.
	</para>
    </section>       
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>  

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Arroway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>OO szemlélet</title>
        <para>A módosított polártranszformációs normális generátor beprogramozása Java nyelven.
Mutassunk rá, hogy a mi természetes saját megoldásunk és az OpenJDK, Oracle JDK-ban a Sun által adott OO szervezés ua.!
<link xlink:href="https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog1_5.pdf">Prog1_5.pdf</link>               
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/ghjbku/prog2/tree/master/OO_szemlelet">github link</link> </para>
        <para>
            </para>
            <figure>
            <title>A <type> JDK</type> kód</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="OO_szemlelet/gauss.png" scale="200"/>
                </imageobject>
                <textobject>
                    <phrase>A <type> JDK</type> kód</phrase>
                </textobject>
            </mediaobject>
        </figure> 
        <para>Amint láthatjuk, a változók elnevezésén kívül és <command>StrictMath,nextDouble</command> metódusokon kívül az általunk írt kód megegyezik.
        Mi ugyanis StrictMath helyett a Math metódust használtuk a gyökvonás és logaritmus képzésnél.</para>
        <programlisting language="java"><![CDATA[double r=Math.sqrt((-2*Math.log(c))/c);]]></programlisting>   
    <para>A fő eltérés a két metódus között(azon kívül, hogy a StrictMath-ban hiperbolikus és egyéb függvények is elérhetőek) az, hogy a <command>StrictMath</command>-nál ha meghívunk egy függvényt, annak ugyan azt az értéket kell visszaadnia például x86-os lebegőpontos változónál, mint SPARC lebegőpontos-nál.
    Ezzel szemben a Math megengedi, hogy a pontosságért cserébe gyorsabban leforduljon a programunk.(na persze a pontossági eltérés nem számottevő a jelen programunk megírásánál)</para>
    <programlisting language="java"><![CDATA[public class polargenerator
{]]></programlisting><para>Amint láthatjuk, az egész programkód egy osztályba van elhelyezve, ez a Java-nak egy sajátossága.</para>
   <programlisting language="java"><![CDATA[ boolean nincstar=true;
 double tarolt;]]></programlisting><para>A forráskód elején inicializálunk két változót, a <command>nincstar</command> változó egy logikai változó, amely megmondja, hogy van-e eltárolva adat.
 Ezzel szemben a <command>tarolt</command> változó hordozza majd a tárolni kívánt értéket.</para>
<programlisting language="java"><![CDATA[ public double kovetkezo()
	{
	if(nincstar)
		{
		double a1,a2,b1,b2,c; ]]></programlisting><para>Itt pedig egy kovetkezo nevű metódust hozunk létre, ha a nincstar értéke igaz, akkor végrehajtódik az if-ben leírt változók deklarálása.
        </para>
        <programlisting language="java"><![CDATA[do{
		  a1=Math.random();
		  a2=Math.random();
		  b1=2*a1-1;
		  b2=2*a2-1;
		  c=b1 * b1 + b2 * b2;
		          }while(c>1);]]></programlisting><para>Ez a következő pár sor egy hátultesztelős ciklus.
                         Először az a1,a2 változók értékét randomizáljuk, majd a b1,b2 változókban az előbbi két értéket
                         megduplázzuk és csökkentjük az értéket 1-el.
                         a c változó értékét a b1 és b2 változók négyzetével tesszük egyenlővé. Ez addig fut, amíg a c értéke nagyobb lesz, mint 1.
                          </para>
        <programlisting language="java"><![CDATA[double r=Math.sqrt((-2*Math.log(c))/c);
		tarolt=r*b2;
		nincstar=!nincstar;
		return r*b1;
        ]]></programlisting><para>ezekben a sorokban létrehozunk egy r változót, és annak az értékéül a <![CDATA[Math.sqrt((-2*Math.log(c))/c)]]> függvény eredményét adjuk.
        a tárolandó érték az r változó és a b2 változó szorzata lesz, az értékadás után pedig a nincstar értékét negáljuk.
        végül visszatérési értékként a r és a b1 szorzatát adjuk meg.
        </para>
        <programlisting language="java"><![CDATA[else
		{
		nincstar=!nincstar;
		return tarolt;		
		}
	]]></programlisting><para>Az else ágban csak annyi a dolgunk, hogy a nincstar értékét negáljuk, és a tárolt értéket adjuk meg visszatérési értékként.
    Végezetül pedig kiíratjuk a main-ben.</para>
     <programlisting language="java"><![CDATA[public static void main(String[] args)
	{polargenerator g = new polargenerator();
	for(int i=0; i<10;++i)
		{
		System.out.println(g.kovetkezo());
		}
	}]]></programlisting>
    </section>        

<section>
        <title>"Gagyi"</title>
        <para>
Az ismert formális <command><![CDATA[while(x <=t && x>=t && t!=x);]]></command> tesztkérdéstípusra adj a szokásosnál "mélyebb" választ, írj Java példaprogramot mely egyszer végtelen ciklus, más x és t értékekkel pedig nem!
A példát építsd a JDK Integer.java forrására, hogy a 128-nál inkluzív objektum példányokat poolozza! 
<link xlink:href="https://www.facebook.com/groups/udprog/permalink/437825193072042/">facebook post</link>
	</para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/ghjbku/prog2/tree/master/gagyi">github link</link>
                       
        </para>
    
        <para>
    <![CDATA[while (x <= t && x >= t && t != x);]]>        
        </para>
        <para>Amint láthatjuk, az első két tagja a ciklus feltételeknek a két változó értékét hasonlítja össze
        . A harmadik viszont (<command>t!=x</command>) a változók referenciáját, ami az integer-cache miatt -128 és 127 között ugyanaz lesz.
        A gagyi.java fájl ezért végtelenciklust képez, hiszen a -129 már nincs benne a cache-ben, ezért 
        a t!=x mindíg igaz lesz.
        a gagyi2.java viszont a -128 értékkel dolgozik, ami benne van a cache-ben, tehát a ciklus nem jön létre.
        </para>
        <para>Érdekesség még, hogy a Java6 óta bevezették a felső érték bindelését, amely a 
        </para><para><command>java.lang.Integer.IntegerCache.high</command>
         segítségével a programozó által is állítható lett.
         Fontos tudni viszont, hogy a maximális érték legalább 127 kell, hogy legyen.
         Ha az érték kevesebb, akkor egy AssertionError hibakódot kapunk.</para>
         <figure>
            <title>A <type> gagyi</type> futás</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="gagyi/gagyirun.png" scale="200"/>
                </imageobject>
                <textobject>
                    <phrase>A <type> gagyi</type> futás</phrase>
                </textobject>
            </mediaobject>
        </figure> 
    </section>   

    <section>
        <title>Yoda</title>
        <para>
Írjunk olyan Java programot, ami java.lang.NullPointerEx-el leáll, ha nem követjük a Yoda conditions-t!           
<link xlink:href="https://en.wikipedia.org/wiki/Yoda_conditions">yoda wiki</link>
	</para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/ghjbku/prog2/tree/master/yoda">github link</link>              
        </para>
        <programlisting language="java"><![CDATA[public class yoda
{
	String i;
   public yoda()
   {
   i=null;
		
   }
   public static void main(String[] args)
	{
	yoda f=new yoda();
	
	if("5".equals(f.i))//if(f.i.equals("5"))
	{
	System.out.println("t");
	}
	else
	{
	System.out.println("f");
	}
   }
}]]></programlisting>
 <para>
           A fenti programkód a yoda kondíciós megoldást mutatja, ami annyit tesz, hogy a konstanst rakjuk 
           a ciklusmagban az első helyre, amelyel a NullPointer kivételeket elkerülhetjük.
           A kikommentelt részt beillesztve pedig a program lefutásánál megkapjuk a nullpointer exception-t.
       a <command>yoda f=new yoda();</command> sor példányosítja a yoda osztályt.

        </para>
        <figure>
            <title>A <type> yoda</type> futás</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="yoda/unknown.png" scale="200"/>
                </imageobject>
                <textobject>
                    <phrase>A <type> yoda</type> futás</phrase>
                </textobject>
            </mediaobject>
        </figure> 

    </section>        
    <section>
        <title>Homokozó</title>
        <para>    Megoldás forrása:<link xlink:href="https://github.com/ghjbku/prog2/tree/master/arroway">github link</link>              
       </para>
    </section>
<section>
        <title>Kódolás from scratch</title>
        <para>
Induljunk ki ebből a tudományos közleményből:<link xlink:href="http://crd-legacy.lbl.gov/~dhbailey/dhbpapers/bbp-alg.pdf">http://crd-legacy.lbl.gov/~dhbailey/dhbpapers/bbp-alg.pdf</link>
és csak ezt tanulmányozva írjuk meg Java nyelven a BBP algoritmus megvalósítását!
Ha megakadsz, de csak végső esetben:<link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apbs02.html#pi_jegyei">https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apbs02.html#pi_jegyei</link>

	</para>
         <para>
            Megoldás forrása:<link xlink:href="https://github.com/ghjbku/prog2/tree/master/pibbp">github link</link>              
        </para>
         <figure>
            <title>A <type> piBBP</type> futás</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="pibbp/pibbp.png" scale="200"/>
                </imageobject>
                <textobject>
                    <phrase>A <type> piBBP</type> futás</phrase>
                </textobject>
            </mediaobject>
        </figure> 
        <para>
            a <command>public PiBBP(int d) </command> rész a d+1 hexadecimális jegytől számítja ki a jegyeket
        , azon belűl a 16^d pi képket kiszámítása.
        A <command> public double d16Sj(int d, int j)</command> eljárás a {16^d Sj} részlet kiszámítását végzi.
        <command> public long n16modk(int n, int k)</command> végzi a hatványozás modulóját, itt n a kitevő, k a modulus.
        </para>
        <programlisting language="java"><![CDATA[public String toString() {
        
        return d16PiHexaJegyek;
    }]]></programlisting><para>ez az eljárás a kiszámolt hexadecimális értékeket konvertálja át stringbe, majd visszaadja az értéket.
    </para>
    </section>       
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     
    
 <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Liskov!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
	
	<section>
<title>Liskov helyettesítés sértése</title>
        <para>Írjunk olyan OO, leforduló Java és C++ kódcsipetet, amely megsérti a Liskov elvet! Mutassunk rá a
megoldásra: jobb OO tervezés.
https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_1.pdf (93-99 fólia)
(számos példa szerepel az elv megsértésére az UDPROG repóban, lásd pl. source/binom/Batfai-
Barki/madarak/)</para>
<para>
            Megoldás forrása:<link xlink:href="https://github.com/ghjbku/prog2/tree/master/liskov">github link</link>              
        </para>
		<para>Először nézzük a liskov elvet követő programot:</para>
		<programlisting language="c++"><![CDATA[class Madar {
//public:
//  void repul(){};
};]]></programlisting>
<para>itt nincs repul metódus a Madar osztály tagjaként, tehát nem örökli majd a pingvinünk a repul objektumot.
Ez a RepuloMadar osztálypéldányosított sas osztály-nak az egyedisége.
</para>
<programlisting language="c++"><![CDATA[
class Program {
public:
     void fgv ( Madar &madar ) {
          // madar.repul(); a madár már nem tud repülni
          // s hiába lesz a leszármazott típusoknak
          // repül metódusa, azt a Madar& madar-ra úgysem lehet hívni
     }
};

class RepuloMadar : public Madar {
public:
     virtual void repul() {};
};

class Sas : public RepuloMadar
{};

class Pingvin : public Madar 
{};
]]></programlisting>
<para>itt látható a madar.repul funkció kikommentelve, tehát nem öröklődik a pingvinünk-nél, ezért az fgv függvény nem fogja repültetni azt.
</para>
<para>A liskov elvet sértő program pedig így néz ki:</para>
<programlisting language="c++"><![CDATA[
class Madar {
public:
     virtual void repul() {};
};

// ez a két osztály alkotja a "P programot" az LPS-ben
class Program {
public:
     void fgv ( Madar &madar ) {
          madar.repul();
     }
};

]]></programlisting>
<para>Itt nincs kikommentelve a madar.repül metódus, ezzel a későbbiekben megsértjük majd az elvet.
</para>
<programlisting language="c++"><![CDATA[
class Sas : public Madar
{};

class Pingvin : public Madar // ezt úgy is lehet/kell olvasni, hogy a pingvin tud repülni
{};

int main ( int argc, char **argv )
{
     Program program;
     Madar madar;
     program.fgv ( madar );

     Sas sas;
     program.fgv ( sas );

     Pingvin pingvin;
     program.fgv ( pingvin ); // sérül az LSP, mert a P::fgv röptetné a Pingvint, ami ugye lehetetlen.

}]]></programlisting>
<para>Itt pedig látható, hogy a sas-nak nincs külön alosztály generálva, a RepuloMadar osztály, ehelyett
mindkét állat a madar osztály tagjaként van hitelesítve.
</para>
	</section>
	
	<section>
<title>Szülő-gyerek</title>
        <para>Írjunk Szülő-gyerek Java és C++ osztálydefiníciót, amelyben demonstrálni tudjuk, hogy az ősön
keresztül csak az ős üzenetei küldhetőek!
https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_1.pdf (98. fólia)</para>
<para>A java forrás:<command> A forrás Kovács Ferencz tulajdona.</command></para>
<programlisting language="java"><![CDATA[
class szulo
{
protected int m_age;
protected String m_name;
    public void setAge(int age) {
    m_age = age;
    }
    public void setName(String name) {
    m_name = name;
    }
    public int getAge(){
    return m_age;
    }
}
class gyerek extends szulo
{
    public String getName() {
    return m_name;
    }
}
class szuloGyerek
{
    public static void main (String args[])
    {
    szulo s = new gyerek();
    s.setName("Apuci");
    s.setAge(60);
    gyerek gy = new gyerek();
    s.setName("Laci");
    s.setAge(15);

    System.out.println(gy.getName() + " " + s.getName());
    }
}]]></programlisting>
<para>Látható, hogy a program három osztályra bomlik szét, az első, a szülő osztály, itt létrehozunk 
két protected változót, az m_name és m_age változókat.
Továbbá itt inicializálunk két metódust, a setAge és setName-et.
A setAge egy int típusú adatot kér be, majd a protected m_age változó értékét egyenlővé teszi a bekért értékkel.
Ugyan ez történik a setName-ben, azzal a különbséggel, hogy ez a függvény string adatot vár.
Van még továbbá egy getAge függvényünk, amely az m_age változó értékét adja vissza, ezzel biztosítva, hogy az értéket használhassuk az osztályon kívül is.
</para>
<para>Következő osztály a gyerek.
ez egy rövid kis osztály, egyetlen tagja a getName függvény, amely megpróbálja elérni a szülő osztály m_name változóját, de persze
ez nem sikerül majd, mivel az protected.</para>
<para>A harmadik osztályban teszteljük az elméletünket, először feltültjük a változók értékeit a set függvények segítségével,
majd megpróbáljuk lekérni a nevet a <command><![CDATA[System.out.println(gy.getName() + " " + s.getName());]]></command> sorral.
Amint azt látni fogjuk, ez nem sikerül.</para>
<figure>
            <title>A <type> szülőgyerek </type> futás</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="liskov/szulogyerek.png" scale="250"/>
				  </imageobject>
                <textobject>
                    <phrase>A <type> szülőgyerek </type> futás</phrase>
                </textobject>
            </mediaobject>
        </figure> 
	</section>

	<section>
<title>Anti OO</title>
        <para>A BBP algoritmussal 4 a Pi hexadecimális kifejtésének a 0. pozíciótól számított 10 6, 107, 108 darab
jegyét határozzuk meg C, C++, Java és C# nyelveken és vessük össze a futási időket!
https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apas03.html#id561066</para>
<para>
            Megoldás forrása:<link xlink:href="https://github.com/ghjbku/prog2/tree/master/liskov">github link</link>              
        </para>
		<figure>
            <title>A <type> 4 nyelv</type> futás</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="liskov/negy.png" scale="300"/>
				  </imageobject>
                <textobject>
                    <phrase>A <type> 4 nyelv</type> futás</phrase>
                </textobject>
            </mediaobject>
        </figure> 
		<figure>
            <title>A <type> 4 nyelv</type> futás</title>
            <mediaobject>
                <imageobject>
					<imagedata fileref="liskov/antitabla.png" scale="200"/>
                </imageobject>
                <textobject>
                    <phrase>A <type> 4 nyelv</type> futás</phrase>
                </textobject>
            </mediaobject>
        </figure> 
		<para>Mint láthatjuk, a JAVA mind 3 esetben a legjobban teljesített a számítások során.
		Különös viszont, hogy minél kisebb számjegyét keressük a pi-nek, annál gyorsabban végez a java a többiekhez képest.
		Második helyen a C# volt, nem sokkal lassabb,mint a Java, és a legutolsó a C nyelv.
		Minden 10-ed után kb. 10-szeresére nőtt a futási idő.
		A C fordításánál ügyelni kell arra, hogy a -lm kapcsolót is hozzáadjuk az argumentumok listájához, mivel anélkül nem fog lefordulni a program.
		A hibakód a következő:
		</para>
		<programlisting language="c"><![CDATA[/usr/bin/ld: /tmp/ccKOkIzA.o: in function `d16Sj':
anti_c.c:(.text+0xfe): undefined reference to `floor'
/usr/bin/ld: /tmp/ccKOkIzA.o: in function `main':
anti_c.c:(.text+0x1ff): undefined reference to `floor'
/usr/bin/ld: anti_c.c:(.text+0x227): undefined reference to `floor'
collect2: error: ld returned 1 exit status
]]></programlisting>
<para>A gcc dokumentációban csak annyi található az -lm kapcsolóról, hogy az -l kapcsoló 
paramétere az m, ez egy úgynevezett megosztott library, amely osztályokra van bonta, és objektumokat tartalmaz.
A mi esetünkben az m könyvtár tartalmát kívánjuk használni, amelyben a floor függvény található.
Ez a math lib.
Ha includeoljuk a math.h headert, akkor erre a kapcsolóra is szükségünk lesz.
Ez C++-ban már nem szükséges, elég csak az include.</para>
	</section>

	<section>
<title>Hello, Android!</title>
        <para>Élesszük fel az SMNIST for Humans projektet!
https://gitlab.com/nbatfai/smnist/tree/master/forHumans/SMNISTforHumansExp3/app/src/main
Apró módosításokat eszközölj benne, pl. színvilág.</para>
	</section>

	<section>
<title>Ciklomatikus komplexitás</title>
        <para>Számoljuk ki valamelyik programunk függvényeinek ciklomatikus komplexitását! Lásd a fogalom
tekintetében a https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_2.pdf (77-79
fóliát)!</para>
<para>A ciklomatikus komplexitás számításakor a beágyazott ciklusok azonos súllyal vannak számolva, mint a külső ciklusok.
Viszont valójában a belső ciklusok jelenlétével a programkód megértése nehezebb lesz.
Attól függetlenül, hogy a ciklusok száma szerint a program bonyolultsága alacsony kéne, hogy legyen, még lehet bonyolult a forráskód.
</para>
<para><command>a kódrészlet saját tulajdonban áll.</command></para>
<programlisting language="c++"><![CDATA[
void fight(int intel, int d)
{
	int i = 0;
	int j = 0;
	int k = 0;
	if (intel == 1)
	{
		cout << "you remember the paper you found had a bear drawing on it with three numbers: 5 2 4\n";
	}
	else if (intel == 0)
	{
	}
	cout << "the bear attacks first with a rush attack\nyou: 1.defend\n 2.side step to the right and try to hit its knee\n 3. back step\n 4.slash it with your sword \n5.side step to the left\n";
	cin >> i;
	if (i == 1)
	{
		cout << "you can`t defend without a shield, you died.";
	}
	else if (i == 2)
	{
		cout << "you try to dodge by sidestepping to right, but the bear somehow knows you would do that\nit slashes you and deals critical damage\nyou died.";
	}
	else if (i == 3)
	{
		cout << "you try to backstep, but why? \nthe bear doesn`t even have to turn anywhere, it easily kills you.\n";
	}
	else if (i == 4)
	{
		cout << "you slash the bear with your dagger as it reaches you\nyou dealt almost no damage.\nthe bear bites you with unbearable strength\nyou died";
	}
	else if (i == 5)
	{
		d++;
		cout << "you sidestep to the left,the bear, surprised lounges to the right.\nit hits nothing but air.\nthe bear,enraged even further try to attack you from the right.\n[decision making " << d << "]\nyou: ";
		cout << "1.defend\n 2.side step to the right and try to hit its knee\n 3. back step\n 4.slash it with your sword \n5.side step to the left\n";
		cin >> j;
		if (j == 1)
		{
			cout << "you can`t defend without a shield, you died.";
		}

		if (j == 2)
		{
			d++;
			cout << " you sidestep to the right,the bear surprised again, you use the momentum to slash its knees.\nthe bear falls to the ground.\n[decision making " << d << "]\n ";

			cout << "\nyou: 1.defend\n 2.side step to the right and try to hit its knee\n 3. back step\n 4.slash it with your sword \n5.side step to the left\n";
			cin >> k;
			if (k == 1)
			{
				cout << "why would you..?,you died...";
			}

			else if (k == 2)
			{
				cout << "why would you..?,you died...";
			}

			else if (k == 4)
			{
				d = d + 2;
				cout << "you slash the head of the bear while its down.\nyou dealt monsterous amount of damage.\nyou 1hit killed the bear.[decision making " << d << "]\n\n\nCongratulations, \nYou Won The Game!";
			}

			else if (k == 3)
			{
				cout << "why would you..?,you died...";
			}

			else if (k == 5)
			{
				cout << "why would you..?,you died...";
			}
		}

		if (j == 3)
		{
			cout << "you try to back step,and you succeed, but the bear somehow kicks you in the head and you die.";
		}

		if (j == 4)
		{
			cout << "you try to slash it with your sword, but do you think you hit harder than a bear?\nyou died from a pawn hit in the head.";
		}

		if (j == 5)
		{
			cout << "you try to sidestep to the left,but the bear remembers you doing that before,it turns toward you and slashes...\nyou died.";
		}
	}
}
]]></programlisting>
<figure>
            <title>A <type> ciklomatikus</type> ábra</title>
            <mediaobject>
                <imageobject>
					<imagedata fileref="liskov/ciklomatikus.png" scale="250"/>
                </imageobject>
                <textobject>
                    <phrase>A <type> ciklomatikus</type> ábra</phrase>
                </textobject>
            </mediaobject>
        </figure> 
		<para>A komplexitás 17-2+3=18</para>
		<para>a komplexitási érték 4 típusra bontja fel a forráskódokat.
		Ha a komplexitás végeredményeként <command>1-10 közötti szám</command>ot kapunk, akkor a forráskód egyszerűnek mondható.
		</para><para><command>11 és 20 között</command> mérsékelten nehézkes a kód megértése.</para>
		<para><command>21 és 50 között</command> a programkód bonyolult</para><para>az utolsó osztály pedig a 
		<command>50 feletti</command> számok, mely a nagyon bonyolult forráskódoknál fordul elő, és magas a kockázat a hibák ejtésénél.
		</para>
		<para>Számolásunkat a <link xlink:href="www.lizard.ws">lizard.ws</link> oldal is approválja.</para>
	<figure>
            <title>A <type> lizard ciklomatikus</type> számolás</title>
            <mediaobject>
                <imageobject>
					<imagedata fileref="liskov/ciklo_lizard.png" scale="250"/>
                </imageobject>
                <textobject>
                    <phrase>A <type> lizard ciklomatikus</type> számolás</phrase>
                </textobject>
            </mediaobject>
        </figure> 
	</section>

	<section>
<title>deprecated - Hello, Android!</title>
	<para>Élesszük fel a https://github.com/nbatfai/SamuEntropy/tree/master/cs projektjeit és vessünk össze
néhány egymásra következőt, hogy hogyan változtak a források!</para>
	</section>
	
	<section>
	<title>Hello, SMNIST for Humans!</title>
	<para>Fejleszd tovább az SMNIST for Humans projektet SMNIST for Anyone emberre szánt appá! Lásd
az smnist2_kutatasi_jegyzokonyv.pdf-ben a részletesebb hátteret!</para>
	</section>
</chapter>     
    
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Mandelbrot!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
	
	<section>
<title>Reverse engineering UML osztálydiagram</title>
<para>

UML osztálydiagram rajzolása az első védési C++ programhoz. Az osztálydiagramot a forrásokból
generáljuk (pl. Argo UML, Umbrello, Eclipse UML) Mutassunk rá a kompozíció és aggregáció
kapcsolatára a forráskódban és a diagramon, lásd még: https://youtu.be/Td_nlERlEOs.
https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog1_6.pdf (28-32 fólia)
</para>
<figure>
            <title>Az <type>LZW UML  </type></title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="mandelbrot/uml_binfa.png" scale="40"/>
				  </imageobject>
                <textobject>
                    <phrase>Az <type> LZW UML </type> </phrase>
                </textobject>
            </mediaobject>
        </figure> 
        <para>Az aggregáció egy rész-egész kapcsolatot jelent.
         A fő-objektum fizikailag is tartalmazza, vagy birtokolja a rész-objektumot, 
        általában ezen objektum létezése függésben van a fő-objektumtól.
        Ennek két fajtája lehet, gyenge és erős aggregáció.
        A <command>gyenge aggregáció</command>-ban a rész-objektum létezhet a fő-obj. nélkül is, míg 
        az <command>erős aggregáció</command>-nál ez nem lehetséges.
        Általában az erős aggregáció-t szokták <command>kompozíció</command>-nak nevezni. 
        A <command>gyenge aggr.</command> jele a két osztály között húzott telített egyenes, melynek végén egy üres rombusz található.
        A rombusz azon az oldalon van, amely osztály a fő-objektum.
        Az <command>erős aggr./kompozíció</command> jele is egy vonal, viszont a végén egy telített rombusz található.
        Az UML ábrán megtalálható mindkét típusú asszociáció.
        </para>
</section>

<section>
<title>Forward engineering UML osztálydiagram</title>
<para>UML-ben tervezzünk osztályokat és generáljunk belőle forrást!</para>
<figure>
            <title>Az <type>új UML  </type></title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="mandelbrot/class diagram.png" scale="150"/>
				  </imageobject>
                <textobject>
                    <phrase>Az <type> új UML </type> </phrase>
                </textobject>
            </mediaobject>
        </figure> 
        <figure>
            <title>Az <type>új UML  </type></title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="mandelbrot/uml_generated.png" scale="250"/>
				  </imageobject>
                <textobject>
                    <phrase>Az <type> új UML </type> </phrase>
                </textobject>
            </mediaobject>
        </figure> 
        <para>
        Az UML segítségével létrehozott diagramon az Osztályok között kétirányú összeköttetés, ún. asszociáció áll fenn. 
        Ezen kapcsolat iránya megadható,de nem szükséges. 
        A kapcsolatban résztvevő osztályok léte egymástól általában független, 
        de minimum az egyikük ismeri/használja a másikat.
        Gyakorlatilag az osztályokból létrejövő objektumok között van összefüggés.

Jele: a két osztály között telített vonal, a végén nyíllal, ha írányt is jelölünk.</para>
<para>Ebben az UML-ben 3 osztályt ábrázoltam, amelyek segítségével eldönti a program, hogy a bekért állat neve és faja alapján
madár-e, avagy sem.
Az első két osztály a <command>bird/madár</command> és a <command>not_bird/nem_madár</command> osztályok.
Ezekben az osztályokban tároljuk majd a különböző állatokat aszerint, hogy madár vagy sem a megadott adat.
A harmadik osztály az <command>is_it_bird/madár?</command>, melynek feladata e fontos kérdés eldöntése.
Miután megkapja a <command>species</command> és <command>name</command> adatokat, egy if-statement sorozat segítségével
eldönti, hogy melyik osztályhoz küldi tovább az adatokat.
</para>
</section>


<section>
<title>BPMN</title>
<para>Rajzoljunk le egy tevékenységet BPMN-ben!
https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_7.pdf (34-47 fólia)</para>
<figure>
            <title>A <type>BPMN ábra</type></title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="mandelbrot/bpmn diagram.png" scale="80"/>
				  </imageobject>
                <textobject>
                    <phrase>A <type>BPMN</type> ábra </phrase>
                </textobject>
            </mediaobject>
        </figure> 
        <para>A képen egy regisztrációs folyamat BPMN ábrája látható.(Business Process Model and Notation/ üzleti folyatmodellezés és jelölés)
        Indulunk a <command>regisztráció</command> gomb megnyomásától.
        Ekkor az oldal egy kérést küld a szervernek, amely után egy új lap jelenik meg, ezen a lapon helyezkedik majd el
        a regisztrációhoz szükséges szövegdobozok és utasítások sorozata, na meg persze a <command>regisztráció</command> gomb.
        A szerver válaszában már az egész oldalt küldi el, amelyben az oldal tartalma egészében megtalálható, a felhasználónak csak annyi a dolga, hogy
        megadja a szükséges információkat.
        Ezután két dolog történhet, ha az oldal képes az on-the-spot információ-ellenőrzésre, akkor
        már a <command>regisztráció</command> gomb megnyomása előtt visszajelzést ad, hogy a megadott adatok helyesek-e, esetleg már valaki által foglaltak-e vagy sem.
        A másik lehetőség ugyebár,hogy csak a gomb megnyomása után tudjuk meg, hogy valid adatokat adtunk-e meg.
        A model az első opció szerint lett elkészítve.
        </para>
        <para>Ha minden validálva lett, akkor jöhet a regisztráció.
        A felhasználó újra megnyomja a gombot.
        Ezután a kliens kérést küld a szervernek, amelyben a titkosított adatok is jelen vannak.
        Ez egy keretbe van foglalva, és egy ún. SET/POST kérés-típus kel útra a szerver felé, amely arra kéri 
        a szervert, hogy az adatokat vigye be az adatbázisba, ezzel véglelegítve a regisztrációt.
        Végezetül a szerver visszaigazoló üzenetet küld, amelyben megtaláljuk, hogy a regisztráció sikeres volt-e, vagy egy esetleges szerver-oldali hiba miatt sikertelen.
        Az utóbbi esetben később újrapróbálkozhat a felhasználó, esetleg ha van elérhetőség kitéve az oldalra, ott tájékoztathatja az oldal üzemeltetőjét.

        </para>

</section>

<section>
<title>Egy Esettan</title>
<para>A BME-s C++ tankönyv 14. fejezetét (427-444 elmélet, 445-469 az esettan) dolgozzuk fel!</para>
<para>forrás:<link xlink:href="https://github.com/ghjbku/prog2/tree/master/mandelbrot/esettanulmany">github link</link>              
        </para>
        <para>A product.h headerfájl tartlamazza a termékkel kapcsolatos adatokat, mint például 
        a termék kora, beszerzési dátum és ár, a termék neve és a jelenlegi ára.
        Mivel viszont az <command>initialPrice, dateOfAcquisition és a name</command> tagváltozók 
        protected/védettek, ezért azok eléréséhez szükségünk van a publikus:</para>
        <programlisting language="C++"><![CDATA[time_t Product::GetDateOfAcquisition() const
        {return dateOfAcquisition;}
        
        int Product::GetInitialPrice() const {return initialPrice;}

        string Product::GetName() const {return name;}]]></programlisting><para>függvényekre.</para>
        <para>A termék korának kiszámítását a <command>GetAge</command> függvény végzi, amely az aktuális dátumból és a beszerzési dátumból számolja ki azt.
        A függvény forráskódja a következő:</para>
        <programlisting language="C++"><![CDATA[int Product::GetAge() const
        {
            time_t currentTime;
            time(&currentTime);
            double timeDiffInSec = Difftime(cirrentTime, dateOfAcquisition);
            return (int)(timeDiffInSec/(3600*24));
        }]]></programlisting><para>A függvény return sorában láthatjuk az (int) szócskát a timediff előtt, ez 
        egy ún. típus kényszerítés, jelen esetben a visszatérési érték típusát integerré konvertálja.</para>
        <para>Az osztályban megtalálható a GetCurrentPrice függvény is, amely segítségével
        a termék jelenlegi ára számítható ki,viszont mivel az ár termékfüggő, ezért azt virtuálisan definiáljuk,
         hogy később a leszármazott osztályok felüldefiniálhassák azt.
         Ez a függvény a beszerzési árat adja vissza a product.h fájlban.
</para>
<para>A hardDisk osztályban megtalálható ezen függvény felüldefiniálása:</para>
<programlisting language="C++"><![CDATA[class HardDisk : public Product
{
    int speedRPM;
public:
int GetCurrentPrice() const;
...
};

int HardDisk::GetCurrentPrice() const
{
    int ageInDays = GetAge();
    if(ageInDays < 30)
    {
        return initialPrice;
    }
    else if (ageInDays >= 30 && ageInDays <90)
    {return (int)(initialPrice * 0.9);}
    else
    {return (int)(initialPrice * 0.8);}
}
]]></programlisting><para>Itt is megtalálható a típuskényszerítés, amivel elérjük, hogy
ne tört számot kapjunk vissza, hanem egész számot.</para>
</section>

<section>
<title>TEX uml</title>
<para>Valamilyen TeX-es csomag felhasználásával készíts szép diagramokat az OOCWC projektről (pl.
use case és class diagramokat).
</para>
</section>

<section>
<title>BPEL Helló, Világ! - egy visszhang folyamat</title>
<para>
Egy visszhang folyamat megvalósítása az alábbi teljes „videó tutoriál” alapján:
https://youtu.be/0OnlYWX2v_I
</para>
</section>
</chapter>     
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chomsky!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
	
	<section>
<title>Encoding</title>
<para>

Fordítsuk le és futtassuk a Javat tanítok könyv MandelbrotHalmazNagyító.java forrását úgy, hogy a
fájl nevekben és a forrásokban is meghagyjuk az ékezetes betűket!
https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/adatok.html
</para>
<figure>
            <title>A <type> mandel </type> futás</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="chomsky/encoding_fut.png" scale="250"/>
				  </imageobject>
                <textobject>
                    <phrase>A <type> mandel </type> futás</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <para>A képen látható, amint megpróbáljuk az encoding nélkül lefordítani a programunkat, kevés sikerrel.
        A -encoding kapcsoló használatával és a megfelelő karakterkészlettel viszont tökéletesen/hiba nélkül lefordul és lefut a program.
        A lehetséges karakterkészletek megtalálhatóak az oracle oldalán:</para><para> <link xlink:href="https://docs.oracle.com/javase/7/docs/technotes/guides/intl/encoding.doc.html">https://docs.oracle.com/javase/7/docs/technotes/guides/intl/encoding.doc.html</link>              
        </para>
        <para>
        Az általunk használt készlet a 1252-es, amit Latin-1-nek is hívnak.
        A javac -encoding nélkül általában a rendszer által használt codeset-et használja alapértelmezetten, de mivel a JVM nem igazán veszi figyelembe a helyi rendszert(hiszen virtual machine), ezért ez nem univerzális "igazság".
        Viszont az igaz, hogy a javac-ban konfigurálható az alapértelemezett enkódolási charset, és ez általában megyegyezik a helyi gépen használtal.
        A program futása folyamán ez az alapértelemezett karakterkészlet megállapítható a <command><![CDATA[Charset.defaultCharset()]]></command> parancs használatával.</para> 
</section>

<section>
<title>Full screen(ződ)</title>
<para>
Készítsünk egy teljes képernyős Java programot!
Tipp: https://www.tankonyvtar.hu/en/tartalom/tkt/javat-tanitok-javat/ch03.html#labirintus_jatek</para>
<programlisting language="java"><![CDATA[import java.awt.*;
import javax.swing.JFrame;

public class bucky extends JFrame
{
	public static void main (String[] args)
	{
	DisplayMode dm = new DisplayMode(800,600,16,DisplayMode.REFRESH_RATE_UNKNOWN);
	bucky b = new bucky();
	b.run(dm);
	}

	public void run(DisplayMode dm)

		{
		setBackground(Color.BLACK);
		setForeground(Color.WHITE);
		setFont(new Font("Arial",Font.PLAIN, 24));
	
		Screen s = new Screen();
		try{
		s.SetFullScreen(dm, this);
			try{
			Thread.sleep(2700);
			
		}catch(Exception ex){}
		}finally{
			s.RestoreScreen();
		}
	}
	 
	public void paint(Graphics g)
	{
	
	g.drawString("This...A programozásra gondolva olykor valami misztikus érzés járja ",200,200);
g.drawString("át az embert, ami további hajtóerőt és lelkesedést kölcsönöz. A sikeres oktatás ",200,300);
g.drawString("elsődleg es célja ennek átadása, ebből fejlődhet majd ki minden más, ami csak kell:",200,400); 
g.drawString(" A könyvet elsősorban\n tanári kézikönyvként ajánljuk középiskolai informatikatanároknak, de kiegészítő\n irodalomként hasznos olvasmánynak tartjuk informatikus tanárjelöltek, diákok és általában a programozni tanulni vágyók számára \negyaránt. ",200,450);
g.drawString("az ipar számára a professzionális programozó, a tudománynak és az emberiségnek a komplex problémákkal megküzdeni tudó algoritmuselmélész, az\n egyénnek és a társadalomnak a boldog és tetterős polgár. Reményeink szerint ennek az érzésnek az átadásához ezzel a digitális szakkönyvvel \nmi is hozzá tudunk járulni, miközben általában foglalkozunk \na programozással, annak elméletével és filozófiájával, majd részletesen és gyakorlatiasan az objektumorientált paradigmával, és ezen belül\n a Java programozással. Ebben a kézikönyvben\n a Java nyelvvel egy labirintus játék világának felépítése során ismerkedünk meg, a\nmi során ezt az egyszerű, példa labirintus játékot elkészítjük a weboldalon elhelyezhető appletként, mobiltelefonos és teljes képernyős\n PC-s, illetve hálózati: TCP/IP, Java Servlet\n, Java RMI és CORBA változatban is. De ezeken a labirintus témájú esettanulmányokon túl biológiai, matematikai és informatikai programozási példákkal is megismerkedhet majd \na kedves Olvasó.",200, 500);
	}
}
]]></programlisting><para>Itt látható a bucky.java fájl tartalma.
Mint láthatjuk, a program a dm objektumban inicializálja a megjelenítési beállításokat,</para>
<programlisting language="java">
<![CDATA[ DisplayMode dm = new DisplayMode(800,600,16,DisplayMode.REFRESH_RATE_UNKNOWN);]]></programlisting>
<para>
Az első két integer típus a felbontást, a harmadik a színkészletet,
az utolsó paraméter pedig a frissítési rátát állítják be, viszont az utóbbit nem tudjuk,
 ezért az REFRESH_RATE_UNKNOWN parancsot használjuk.</para>
 <programlisting language="java"><![CDATA[public void run(DisplayMode dm)

		{
            .
            .
            .
            Screen s = new Screen();
		try{
		s.SetFullScreen(dm, this);]]></programlisting>
 <para>A run metódus a program megjelenítési képét inicializálja, itt található a SetFullScreen parancs is, amely a 
 teljes-képernyős mód beállításáért felel.</para><programlisting language="java"><![CDATA[setBackground(Color.BLACK);
		setForeground(Color.WHITE);
		setFont(new Font("Arial",Font.PLAIN, 24));]]></programlisting><para>
 Itt állítjuk be a betűk típusát, méretét, illetve a betűk és a háttér színét is, melyek ebben a sorrendben fehér ill. fekete szinűek.</para>
<para>A <command>Screen s = new Screen();</command> parancs példányosítja a megjeleníteni kívánt ablakunkat.</para>
<programlisting language="java"><![CDATA[public void paint(Graphics g)
	{
	
	g.drawString("This...A programozásra gondolva olykor valami misztikus érzés járja ",200,200);
g.drawString("át az embert, ami további hajtóerőt és lelkesedést kölcsönöz. A sikeres oktatás ",200,300);
g.drawString("elsődleg es célja ennek átadása, ebből fejlődhet majd ki minden más, ami csak kell:",200,400); 
g.drawString(" A könyvet elsősorban\n tanári kézikönyvként ajánljuk középiskolai... ",200,450);
g.drawString("az ipar számára a professzionális programozó, a tudománynak ...",200, 500);
	}]]></programlisting><para>Végül pedig látható a paint metódus.
    Ez felel a képernyőre "festésért",ami ezesetben csak pár sor szöveg, de lehet ez akár ábrák, képek sokasága is, a megjeleníteni kívánt objektum szerint viszont a kód is változik, és nehézségi foka is egyre nől.
</para><para>Megoldás forrásai:<link xlink:href="https://github.com/ghjbku/prog2/tree/master/chomsky">github link</link>              
     
    </para>
<figure>
            <title>A <type> fullscreen </type> futás</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="chomsky/fullscreen.png" scale="150"/>
				  </imageobject>
                <textobject>
                    <phrase>A <type> fullscreen </type> futás</phrase>
                </textobject>
            </mediaobject>
        </figure> 
</section>

<section>
<title>Paszigráfia Rapszódia OpenGL full screen vizualizáció</title>
<para>
Lásd vis_prel_para.pdf! Apró módosításokat eszközölj benne, pl. színvilág, textúrázás, a szintek jobb
elkülönítése, kézreállóbb irányítás.
</para>
<para>A program módosítás szempontjából az alábbiakon esett át:
színvilág változtatás, mostantól a kockák teste kék színű.
Az irányítás kézreállóságának biztosítása: wasd billentyűk használhatóak a nyilak funkciójának ellátásához, továbbá a Z irányú mozgásra (ami eddig a page up és page down bill.-el történt), most a q és e billentyűk szolgálhatnak.
A Forgatási sebesség pozitív irányban meg lett növelve, korrigálhatóság miatt a negatív irány azonos értéken maradt.
A régi irányítás is működik, esetleges használati kényelmetlenségek elkerülése végett.</para>
<programlisting language="c++"><![CDATA[void keyboard ( unsigned char key, int x, int y )
{
    .
    .
    .
    .
       else if( key == 'w' ) {
                cubeLetters[index].rotx += 25.0;
        } else if ( key == 's') {
                cubeLetters[index].rotx -= 5.0;
        } else if ( key == 'd' ) {
                cubeLetters[index].roty -= 5.0;
        } else if ( key == 'a' ) {
                cubeLetters[index].roty += 25.0;
        } else if ( key == 'q' ) {
                cubeLetters[index].rotz += 25.0;
        } else if ( key == 'e' ) {
                cubeLetters[index].rotz -= 5.0;
        }

        glutPostRedisplay();
}]]></programlisting>
<para>itt látható az irányításra szolgáló billentyűk kiosztásának a kódrészlete, emellett pedig a forgatások sebességét is láthatjuk a kódrészleten.
</para>
<para>a program lefordításához a következő kapcsolók kellenek:
g++ para6.cpp -o para <command> -lboost_system -lGL -lGLU -lglut</command></para>
<para>Az lboost_system library a boost-nak a használata miatt szükséges, az lGL, az lGLU ls az lglut kapcsolók pedig az openGL könyvtárai, hiszen az openGL-t használva jelenítettük meg a kockákat, ezért ezekre is szükségünk volt.
Érdekes viszont megfigyelnünk, hogy az glut(opengl utility toolkit) támogatása már több,mint 15 éve lejárt, ehelyett a freeglut-ot használják manapság az openGL programok írásánál,
viszont ez a jelenlegi programunkat nem befolyásolja, a megfelelő library-k segítségével tökéletesen működőképes.
A freeglut megtalálható itt:<link xlink:href="http://freeglut.sourceforge.net/">http://freeglut.sourceforge.net/</link></para>
           
 
</section>


<section>
<title>l334d1c4<superscript>5</superscript> (ződ)</title>
<para>
Írj olyan OO Java vagy C++ osztályt, amely leet cipherként működik, azaz megvalósítja ezt a betű
helyettesítést: https://simple.wikipedia.org/wiki/Leet (Ha ez első részben nem tetted meg, akkor írasd
ki és magyarázd meg a használt struktúratömb memóriafoglalását!)</para>

<para>A cipher java-ban.</para>
<programlisting language="java"><![CDATA[import java.util.Scanner;
import java.util.Vector;


public class Leet {

    public static Vector<String> translate(String word, Vector<String> wordvect)
    {
        
        word=word.toUpperCase();
        for(int i=0;i<word.length();i++)
        {
            switch (word.charAt(i)) {
                case 'A' : wordvect.add("4");
                     break;
                case 'B' : wordvect.add("|3");
                     break;
                case 'C' : wordvect.add("(");
                     break;
                case 'D' : wordvect.add("|)");
                     break;
                case 'E' : wordvect.add("3");
                     break;
                case 'F' : wordvect.add("|=");
                     break;
                case 'G' : wordvect.add("6");
                     break;
                case 'H' : wordvect.add("|-|");
                     break;
                case 'I' : wordvect.add("|");
                     break;     
                case 'J' : wordvect.add(".]");
                     break;
                case 'K' : wordvect.add("|<");
                     break;      
                case 'L' : wordvect.add("1");
                     break;      
                case 'M' : wordvect.add("|Y|");
                     break;
                case 'N' : wordvect.add("N");
                     break;
                case 'O' : wordvect.add("0");
                     break;
                 case 'P' : wordvect.add("P");
                     break;
                case 'Q' : wordvect.add("Q");
                     break;
                case 'R' : wordvect.add("|2");
                     break;
                case 'S' : wordvect.add("5");
                     break;
                case 'T' : wordvect.add("7");
                     break;
                case 'U' : wordvect.add("|_|");
                     break;                    
                case 'V' : wordvect.add("V");
                     break;
                case 'W' : wordvect.add("W");
                     break;                    
                case 'X' : wordvect.add("}{");
                     break;                     
                case 'Y' : wordvect.add("'/");
                     break;
                case 'Z' : wordvect.add("2");
                     break;
                case ' ' : wordvect.add(" ");
                     break;      
            }
        
        
        }
        
    return wordvect; 
    }
    
    public static void main(String[] args) {
       Vector<String> wordvect = new Vector<>();
       Scanner scan = new Scanner(System.in);
       String word;
       String question;
       boolean questionbool = true;
 
      while(questionbool=true)
      {
       questionbool=false;
       System.out.println("irj be egy szót!");
       word=scan.nextLine();
       System.out.println("szó: "+word);
       
       wordvect=translate(word,wordvect);
               
       for(int i=0;i<wordvect.size();i++)
         System.out.print(wordvect.get(i));
       
       System.out.print("\n");
       System.out.println("tovább?(y / n)");
       question=scan.nextLine();
       if(question.startsWith("y"))
       {
           wordvect.clear();
           questionbool = true;
       }
       else
           break;
      }
           
       
       
    }
    
}
]]></programlisting>
<para>A program "backbone"-ja a translate funkció, amely a "word", azaz a bekért szót először átírja csupa nagybetűre,
majd a switch elágazásból kiválasztja a szó jelenlegi karakterét, és behelyettesíti a hozzá tartozó 1337 "betű"-vel.
A szó összes karakterén végighalad a for-ciklussal, míg a szó végéhez nem ér.</para>
<programlisting language="java"><![CDATA[public static Vector<String> translate(String word, Vector<String> wordvect)
    {
        
        word=word.toUpperCase();
        for(int i=0;i<word.length();i++)
        {
            switch (word.charAt(i)) {
                case 'A' : wordvect.add("4");
                     break;
                case 'B' : wordvect.add("|3");
                     break;
                case 'C' : wordvect.add("(");
                     break;
                case 'D' : wordvect.add("|)");
                     break;
                case 'E' : wordvect.add("3");
                     break;
                case 'F' : wordvect.add("|=");
                     break;
                case 'G' : wordvect.add("6");
                     break;
                case 'H' : wordvect.add("|-|");
                     break;
                case 'I' : wordvect.add("|");
                     break;     
                case 'J' : wordvect.add(".]");
                     break;
                case 'K' : wordvect.add("|<");
                     break;      
                case 'L' : wordvect.add("1");
                     break;      
                case 'M' : wordvect.add("|Y|");
                     break;
                case 'N' : wordvect.add("N");
                     break;
                case 'O' : wordvect.add("0");
                     break;
                 case 'P' : wordvect.add("P");
                     break;
                case 'Q' : wordvect.add("Q");
                     break;
                case 'R' : wordvect.add("|2");
                     break;
                case 'S' : wordvect.add("5");
                     break;
                case 'T' : wordvect.add("7");
                     break;
                case 'U' : wordvect.add("|_|");
                     break;                    
                case 'V' : wordvect.add("V");
                     break;
                case 'W' : wordvect.add("W");
                     break;                    
                case 'X' : wordvect.add("}{");
                     break;                     
                case 'Y' : wordvect.add("'/");
                     break;
                case 'Z' : wordvect.add("2");
                     break;
                case ' ' : wordvect.add(" ");
                     break;      
            }
        
        
        }
        
    return wordvect; 
    }]]></programlisting>
    <para>Ha vége a szónak, kilép a ciklusból és visszatérési értékként visszadobja a <command>wordvect</command> vektor-t.
    </para>
    <programlisting language="java"><![CDATA[public static void main(String[] args) {
       Vector<String> wordvect = new Vector<>();
       Scanner scan = new Scanner(System.in);
       String word;
       String question;
       boolean questionbool = true;]]></programlisting>
       <para>A main függvényben példányosítjuk a wordvect objektumot, majd egy szöveg-scannert inicializálunk, 
       melyel majd a szavakat kérjük be a felhasználótól.</para>
       <programlisting language="java"><![CDATA[while(questionbool=true)
      {
       questionbool=false;
       System.out.println("irj be egy szót!");
       word=scan.nextLine();
       System.out.println("szó: "+word);
       
       wordvect=translate(word,wordvect);
               
       for(int i=0;i<wordvect.size();i++)
         System.out.print(wordvect.get(i));
       ]]></programlisting><para>Követekző a while ciklus, amely magáért a szó bekéréséért és annak lefordításáért felel.
       a <command>word=scan.nextLine();</command> sor kéri be a word változóba a szót,a <command>wordvect=translate(word,wordvect);</command> sor pedig magáért a lefordításért felelős.
       Végül a for-ciklus kiírja a lefordított szöveget karakterenként.</para>
</section>

<section>
<title>Paszigráfia Rapszódia LuaLaTeX vizualizáció</title>
<para>

Lásd vis_prel_para.pdf! Apró módosításokat eszközölj benne, pl. színvilág, még erősebb 3D-s hatás.
</para>
</section>

<section>
<title>OOCW lexer</title>
<para>Izzítsuk be az OOCWC-t és vázoljuk a https://github.com/nbatfai/robocar-emulator/blob/master/justine/rcemu/src/carlexer.ll lexert és kapcsolását a programunk OO struktúrájába!</para>
</section>

<section>
<title>Perceptron osztály</title>
<para>

Dolgozzuk be egy külön projektbe a projekt Perceptron osztályát!
Lásd https://youtu.be/XpBnR31BRJY
</para>
</section>
</chapter>     
            
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Stroustrup!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>JDK osztályok</title>
        <para>

            Írjunk olyan Boost C++ programot (indulj ki például a fénykardból) amely kilistázza a JDK összes
            osztályát (miután kicsomagoltuk az src.zip állományt, arra ráengedve)!
        </para>
        <para>
            A programkód forrása (
            <command>Nem saját source</command>
            ):
            <link xlink:href="https://github.com/ghjbku/prog2/tree/master/stroustrup">github link</link>
        </para>
        <figure>
            <title>
                A
                <type>jdk</type>
                futás
            </title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="stroustrup/jdk.png" scale="250"/>
                </imageobject>
                <textobject>
                    <phrase>
                        A
                        <type>jdk</type>
                        futás
                    </phrase>
                </textobject>
            </mediaobject>
        </figure>
        <para>A program három függvényből áll, a GetCurrentWorkingDir,readClasses és searchRootFolders függvényekből.
        Nézzük először a <command>GetCurrentWorkingDir</command> funkciót:</para>
        <programlisting language="c++"><![CDATA[
string GetCurrentWorkingDir( void )
{
char buff[FILENAME_MAX];
GetCurrentDir( buff, FILENAME_MAX );
string current_working_dir(buff);
return current_working_dir;
}]]></programlisting>
<para>A függvényünk nem kér be paraméternek semmit, a GetCurrentDir beépített függvényt használja(getcwd)
,hogy az aktuális könyvtár nevét bekérje, majd létrehoz egy string típusú <command>current_working_dir</command>
 változót, melyben eltároljuk a buffer-ben található fájlnevet, melyet végül visszaad a függvény.</para>
   <para>Következő funkció egy visszatérési érték nélküli funkció/metódus lesz, a <command>readClasses:</command></para>
   <programlisting language="c++"><![CDATA[
void readClasses ( boost::filesystem::path path, vector<string>& classes)
{
if ( is_regular_file ( path ) ) {
std::string ext ( ".java" );
if ( !ext.compare ( boost::filesystem::extension ( path ) ) ){
classes.push_back(path.string());
}
} else if ( is_directory ( path ) )
for ( boost::filesystem::directory_entry & entry : boost::filesystem::directory_iterator ( path ) )

readClasses ( entry.path(),classes);
}]]></programlisting>
   <para>A függvény paraméterként egy path típusú path változót és egy string-vector objektumot vár.
   Ha az is_regular_file függvény igaz értéket ad vissza, akkor megadjuk a keresni kívánt fájl-kiterjesztést az ext objektumban,
   ami most a ".java"</para>
   <para>A Következő if elágazásban megnézzük, hogy az ext objektumunk értéke megegyezik-e a path-ban található kiterjesztéssel.
   Ha nem,akkor push_back, tehát a classes vektor végéhez adja a path-et.
   </para>
   <para>Else if ágba lépünk, ha az <command>is_regular_file</command> nem volt igaz, ekkor 
   az <command>is_directory</command> függvényt hívjuk meg ellenőrzésre.
   Ha a path egy könyvtár, akkor meghívunk egy for ciklust, melyben az entry.path() elérési utakat behelyezzük a classes vektorunkba.
   A ciklus addig megy, amíg van entry.</para>
   <para>Utolsó függvény pedig a <command>searchRootFolders</command>:</para>
   <programlisting language="c++"><![CDATA[
   vector<string> searchRootFolders (vector<string> folders)
{
vector <string> classes;
for ( const auto & path : folders)
{
boost::filesystem::path root ( path );
readClasses ( root, classes);
}
return classes;
}]]></programlisting>
<para>Láthatjuk, hogy ez a függvény már használja a readClasses függvényt,amit az előbb néztünk át,
itt a path a root objektum lesz, a class pedig marad a régi.
visszatérési érték a classes objektum lesz.</para>
<para>Végül jöhet a main függvény:</para>
<programlisting language="c++"><![CDATA[
int main(int argc, char const *argv[])
{
vector<string> roots = {
GetCurrentWorkingDir()+"/"+"src"
};

vector<string> classes = searchRootFolders ( roots );
cout<<endl<<"-----------------Printing java classes------------------------"<<endl;
for(auto &i : classes)
{
cout << i << endl;
}
cout << "összesen " << classes.size() << " osztály található\n";
return 0;
}]]></programlisting><para>A classes vektorunk értékéül a searchRootFolders függvény visszatérési értékét adjuk, ami ugyancsak a classes objektum volt.
Ezután egy for ciklusban kiíratjuk a classes-ben található elérési utakat, végül a classes.size()-al megnézzük, hogy mennyi osztályt talált a program.</para>
    </section>

    <section>
        <title>Másoló-mozgató szemantika</title>
        <para>

            Kódcsipeteken (copy és move ctor és assign) keresztül vesd össze a C++11 másoló és a mozgató
            szemantikáját, a mozgató konstruktort alapozd a mozgató értékadásra!

        </para>
        <programlisting language="c++"><![CDATA[LZWBinFa (LZWBinFa&& regi){
            std::cout<< "LZWBinFa movetor" << std::endl;
            
            *this = std:move(regi);]]></programlisting>
            <para>Itt látható az std::move funkció,
             amely egy jobbérték referenciát ad vissza, ezzel "mozgatva" az objektumot.
            </para>
<programlisting language="c++"><![CDATA[LZWBinFa (const LZWBinFa& regi)
{
std::cout << "LZWBinFa copytor" << std::endl;

gyoker.ujEgyesGyerek (masol (regi.gyoker.egyesGyerek (), regi.fa));
gyoker.ujNullasGyerek (masol (regi.gyoker.nullasGyerek (), regi.fa));

if (regi.fa == & (regi.gyoker)){fa = &gyoker;}
}

}]]></programlisting><para>Ez a másoló konstruktor,mely lemásolja a regi.fa-ban található nullás és egyes gyermekek-et,
és az új fa-ba másolja azokat.</para>
    
    <programlisting language="c++"><![CDATA[LZWBinFa (const LZWBinFa& regi)
{
std::cout << "LZWBinFa masolo ertekadas" << std::endl;

szabadit (gyoker.egyesGyerek());
szabadit (gyoker.nullasGyerek());

gyoker.ujEgyesGyerek (masol (regi.gyoker.egyesGyerek (), regi.fa));
gyoker.ujNullasGyerek (masol (regi.gyoker.nullasGyerek (), regi.fa));

if (regi.fa == & (regi.gyoker)){fa = &gyoker;}
}

}]]></programlisting><para>EZ pedig a másoló értékadás, amely nagyban hasonlít a konstruktoros megoldásra,
csak annyi a különbség,hogy a másolás előtt felszabadítja az egyes- és nullásgyermek-et, Null-ra állítja értéküket.
</para>

<programlisting language="c++"><![CDATA[LZWBinFa (LZWBinFa&& regi)
{
            std::cout<< "LZWBinFa movetor" << std::endl;
            
            gyoker.ujEgyesGyerek (regi.gyoker.egyesGyerek());
            gyoker.ujNullasGyerek (regi.gyoker.nullasGyerek());
            
            regi.gyoker.ujEgyesGyerek(nullptr);
            regi.gyoker.ujNullasGyerek(nullptr);
}]]></programlisting><para>Különbség az eredeti "movetor"-hoz képest, hogy itt nem egy jobbérték referenciát ad vissza egy move függvény,
helyette az új fa gyokerének az új Egyes és Nullás gyermekei-t a régi gyökér nullás és egyes gyermekeire állítjuk be, majd a regi fa gyökerének gyermekeit beállítjuk, hogy nullpointerre mutassanak.
</para>


</section>


    <section>    <title>Hibásan implementált RSA törése</title>
    <para>

        Készítsünk betű gyakoriság alapú törést egy hibásan implementált RSA kódoló:
        https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_3.pdf (71-73 fólia) által
        készített titkos szövegen.
    </para>
    <para>A forráskód itt található:<link xlink:href="https://github.com/ghjbku/prog2/tree/master/stroustrup">github link</link>
        </para><para>Az encrypt függvény:</para>
        <programlisting language="java"><![CDATA[
public BigInteger[] encript(String msg) {
byte[] buffer = msg.getBytes();
java.math.BigInteger[] priv = new java.math.BigInteger[buffer.length];
for (int i = 0 ; i < priv.length ; i++) {
priv[i] = new java.math.BigInteger(new byte[] {buffer[i]});
priv[i] = priv[i].modPow(this.e, this.n);
}
return priv;]]></programlisting><para>A BigInteger[] egy BigInteger tömb, ez a típus a java.math.BigInteger importálásával érhető el.
</para>
<programlisting language="java"><![CDATA[byte[] buffer = msg.getBytes();]]></programlisting><para>
Ez a sor létrehoz egy byte tömböt, amely a buffer névre hallgat.
Ez a buffer értékül kapja a <command>msg</command> string byte-sorozattá alakított változatát.
A sorozattá alakítás a platform alapértelmezett charset-ével történik.</para><para>
A következő sorban egy priv változót hozunk létre, amely szintén BigInteger tömb típusú lesz.
Ezután egy for ciklust indítunk, ami a priv változó összes elemén végigmegy, először az i-edik elemét egyenlővé teszi
egy új BigInteger-el, majd egy modulus exponenciális függvényt végez el azokon.
A <command>this.e</command> jelenti az exponenciális számot, míg a <command>this.n</command> a modulus-t. 
A pow-al szemben a modpow képes elvégezni a számítást akkor is, ha az exp negatív szám.
</para>
      
        <programlisting language="java"><![CDATA[
        public String atlagDecrypt(String clean ,BigInteger[] msg , Map<Character,Integer> m) {
byte[] buffer = clean.getBytes();
for (int i = 0 ; i < msg.length ; i++) {
msg[i] = msg[i].modPow(this.d, this.n);
buffer[i] = msg[i].byteValue();
}
.
.
.
.
.]]></programlisting><para>Ez pedig az átlag szerinti szöveg-törés függvénye.
Mint az encrypt-ben, itt is lesz egy buffer változónk, amely a clean változó byte-sorozattá alakított változatát tárolja.
A for ciklusban a msg tömb elemein megyünk végig, először megint a modpow függvény segítségét hívjuk, majd 
a buffer-en is végigmegyünk, és a buffer i-edik elemének értékéül a msg i-edik elemének a byte-szerinti értékét adjuk.(mivel ugye a msg egy szám típusú tömb,
annak vesszük a modulusát, hatványozását, attól még szám lesz, és ezt a számot konvertáljuk át byte formára.)</para>
        <programlisting language="java"><![CDATA[
        for (int i = 0 ; i < wrong_dm.length() ; i++) {
Character c;
if ( ( (c = contains(currentMap.get(wrong_dm.charAt(i)),m )) != null )) {
wrong_dm =wrong_dm.replace(wrong_dm.charAt(i), c);
currentMap.remove(wrong_dm.charAt(i));
}
        ]]></programlisting><para>Itt látható a karakterek kicserélése a map-ban látott gyakoriságot követve, és ezzel létrejön a "tiszta, lefordított szöveg".
        </para>
         <figure>
            <title>
                Az
                <type>rsa</type>
                futás
            </title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="stroustrup/rsa2.png" scale="250"/>
                </imageobject>
                <textobject>
                    <phrase>
                        Az
                        <type>rsa</type>
                        futás
                    </phrase>
                </textobject>
            </mediaobject>
        </figure><para>Látható, hogy a program egyfajta bruteforce metódusként üzemel azzal, hogy az RSA kódolás
        betűk helyett szavanként történt meg, ezért a betű előfordulási arány segítségével készíthető olyan program, amely az eredeti szöveg egy részét képes "lefordítani".
        Sajnos ez nem teljesen lehetséges, hiszen ha a betűk aránya a szövegben nem egyezik meg az online található statisztikával, akkor az betű-elcsúszásokhoz vezet, emiatt szinte lehetetlen a teljes decriptálás.
        </para><figure>
            <title>
                Az
                <type>rsa</type>
                futás
            </title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="stroustrup/rsa.png" scale="250"/>
                </imageobject>
                <textobject>
                    <phrase>
                        Az
                        <type>rsa</type>
                        futás
                    </phrase>
                </textobject>
            </mediaobject>
        </figure><para>
        Látható viszont a felső képnél, hogy ha minden betűt sikeresen eltalál, onnan már egész egyszerű kitalálnunk az eredeti szót.
        Ha nem sikerült volna megfejteni a szót, amire gondoltam, a szó: <command>valami</command></para>
        <figure>
            <title>
                Az
                <type>rsa</type>
                futás
            </title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="stroustrup/rsa3.png" scale="250"/>
                </imageobject>
                <textobject>
                    <phrase>
                        Az
                        <type>rsa</type>
                        futás
                    </phrase>
                </textobject>
            </mediaobject>
        </figure><para>Ezen a képen látható, hogy az utolsó két sor szinte pofon-egyszerűen kitalálható a törést követően, na persze nem 100%-os a törés, de egy pár futás után össze lehet illeszteni a szöveget.</para>
</section>

    <section>
        <title>Változó argumentumszámú ctor</title>
        <para>

            Készítsünk olyan példát, amely egy képet tesz az alábbi projekt Perceptron osztályának bemenetére
            és a Perceptron ne egy értéket, hanem egy ugyanakkora méretű „képet” adjon vissza. (Lásd még a 4
            hét/Perceptron osztály feladatot is.)
        </para>
    </section>
    <section>
        <title>Összefoglaló</title>
        <para>

            Az előző 4 feladat egyikéről írj egy 1 oldalas bemutató „”esszé szöveget!
        </para>
    </section>
    <section>
        <title>+feladat</title>
        <para>
            egy egyszerű string osztály elkészítését
            (hogy ne a verembe tegyük a kockászárójel megvalósítását,
            mert az nyilván odacsap az osztály értelmezésének)
        </para>
    </section>
</chapter>     

<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Gödel!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
	
<!-- 	<section>
<title>gengszterek</title>
        <para>Gengszterek rendezése lambdával a Robotautó Világbajnokságban
https://youtu.be/DL6iQwPx1Yw (8:05-től)</para>
	</section>-->

	<section>
	<title>C++11 Custom Allocator</title>
	<para>https://prezi.com/jvvbytkwgsxj/high-level-programming-languages-2-c11-allocators/ a
CustomAlloc-os példa, lásd C forrást az UDPROG repóban!</para>
	<para>forráskód:<link xlink:href="https://github.com/ghjbku/prog2/tree/master/godel/">github link</link> </para>
<programlisting language="c++"><![CDATA[template<class T>
class TrackingAllocator
{
public:
    using value_type = T;

    using pointer = T *;
    using const_pointer = const T *;

    using size_type = size_t;

    TrackingAllocator() = default;

    template<class U>
    TrackingAllocator(const TrackingAllocator<U> &other) {}

    ~TrackingAllocator() = default;]]></programlisting>
    <para>A template segítségével bármilyen típusra alkalmazható az allokátor, a használni kívánt
     paramétereket a <command>using </command>kulcsszóval ellátott parancsok-nál láthatjuk.
     Maga a <command>T</command> lesz az értéktípus, a pointer ugyebár egy T típusú pointer lesz, ugyanez a constans pointer is, csak a const kulcsszóval ellátva,
     Továbbá deklarálunk egy méret-típust is a <command>size_t</command>-re.</para>
     <para>Láthatjuk továbbá a konstruktort és dekonstruktort, melyekhez a default értéket párosítjuk.
     Ez az érték a compiler felé utasítást ad, miszerint ha nem adunk más értéket, akkor a compiler maga fog egy alapértelmezett értéket adni.
     Látható még egy fúrcsa szócska a <command><![CDATA[template<class U]]></command> sor után, az a bizonyos <command><![CDATA[&other]]></command>.
     Ez egy ún. referencia, ez a referált érték memóriahelyét kapja, nincs külön memóriahelye.
     Itt a TrackingAllocator osztályon egy ún. overload-ot hajtunk végre.</para>
    <programlisting language="c++"><![CDATA[class TrackingAllocator
{
.
.
.

pointer allocate(size_type numObjects)
    {
        mAllocations += numObjects;
        return static_cast<pointer>(operator new(sizeof(T) * numObjects));
    }

    void deallocate(pointer p, size_type numObjects)
    {
        operator delete(p);
    }

]]></programlisting>
<para>A programkód legfontosabb részletei az allokációért felelős <command>allocate</command> és a deallokációért felelős <command>deallocate</command> függvények.
Ezek a TrackingAllocator osztályban foglalnak helyet.</para>
<para>az <command>allocate</command> függvényben láthatjuk, hogy a visszatérési értékben allokáljuk az új
memóriahelyeket a new funkcióval, melyben megszámoljuk a T méretét, majd azt megszorozzuk az objektumok számával, amit ugye paraméterként kap az allokációs függvény
.
Ez egy ún. operátor túlterhelés/overload.
Ezt az egészet egy static_cast-al átkonvertáljuk pointer típussá, és ezt a pointert fogja majd a függvényünk visszaadni.
Ez a metódus a fordítás során castolja át a megadott paraméterként kapott értéket.
Na persze ebben a függvényben adjuk az mAllocations változónak az értéket is, melyet majd a végén használunk fel, hogy megkapjuk, mennyi memóriahelyet allokáltunk.</para>
	 <figure>
            <title>
                Az
                <type>allokátor</type>
                futás
            </title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="godel/alloc.png" scale="250"/>
                </imageobject>
                <textobject>
                    <phrase>
                        Az
                        <type>allokátor</type>
                        futás
                    </phrase>
                </textobject>
            </mediaobject>
        </figure>

    </section>

	<section>
	<title>STL map érték szerinti rendezése</title>
	<para>Például: https://github.com/nbatfai/future/blob/master/cs/F9F2/fenykard.cpp#L180</para>
	<para>forráskód:<link xlink:href="https://github.com/ghjbku/prog2/tree/master/godel/">github link</link> </para>
    <programlisting language="c++"><![CDATA[#include <iostream>
#include <map>

 int main(void){
 srand(time(NULL));
 std::map<char, int> map;
 std::map<int, char> sortedMap;


 for(char c = 'a'; c <= 'd'; c++){
map.insert({c,(rand()% 100 + 0)});
 }


 std::cout << "unsorted numbers: " << std::endl;
 for(auto const numb: map){
 std::cout << numb.first << ": " << numb.second << std::endl;
sortedMap[numb.second] = numb.first;
 }

 std::cout <<std::endl <<"Sorted numbers: " << std::endl;
 for(auto const numb: sortedMap)
 std::cout << numb.second << ": " << numb.first << std::endl;


 return 0;
}]]></programlisting>
<para>
a map-ek használatához szükségünk van a map library-ra,ezek olyan tárolók, melyeknek van egy azonosítója(egy kulcs) és van egy értéke.
Két map rekordnak az azonosítója soha nem egyezik/egyezhet meg. 
</para>
<programlisting language="c++"><![CDATA[int main(void){
 srand(time(NULL));
 std::map<char, int> map;
 std::map<int, char> sortedMap;
]]></programlisting>
<para>Először létrehozunk két map-et, az egyik tárolja majd a rendezetlen, a másik a rendezett számokat.
az <command>std::map</command> "paraméterei" a következők: az első, kacsacsőr utáni paraméter a kulcs érték típusa, a második param. pedig a map érték.
Így tehát az unsorted-map kulcsértéke char típusú lesz, és számokat tárol, a sortedMap kulcsértéke viszont már szám típusú, és karaktereket tárol.
</para>
<programlisting language="c++"><![CDATA[for(char c = 'a'; c <= 'd'; c++){
map.insert({c,(rand()% 100 + 0)});
 }]]></programlisting><para>A deklarálás után feltöltjük az unsorted mapunkat.
 Ehhez egy for-ciklus lesz segítségünkre.</para>
 <para>A ciklus a-tól d-ig fog menni, és minden tick-ben insertel egy adatpárt a map-ba.
 A map.instert szintaktikája a következő:</para>
 <para><command>map_név.insert({kulcs,map_érték});</command></para>
 <para>A mapunk értékét randomizált 100-ig terjedő számokkal töltjük meg, a kulcs pedig a ciklus-változó értéke lesz.
 </para>

<programlisting language="c++"><![CDATA[std::cout << "unsorted numbers: " << std::endl;
 for(auto const numb: map){
 std::cout << numb.first << ": " << numb.second << std::endl;
sortedMap[numb.second] = numb.first;
 }]]></programlisting>
 <para>Harmadik lépésként kiíratjuk az unsorted-map értékpárosait, ezt is for-ciklus segítségével.
 Észrevehetjük, hogy a for-ciklus szintaxisa nem éppen az előzőhöz hasonló.
 Ezt a for ciklust range-based for-nak hívják.
 ennek a szintaktikája a következő:</para>
 <para><command>for(típus1 változó: vektor/map/array/etc. )</command></para><para>Fontos tudni viszont,
 hogy a változónak azonos típusúnak kell lennie a map-ban levő érték típusával.
 Mivel a mi esetünkben auto típust adtunk meg, ezért a típusmegválasztást a compiler-re hagyjuk, az pedig a map értékeit figyelembe véve választ majd típust.
 </para>

<programlisting language="c++"><![CDATA[std::cout <<std::endl <<"Sorted numbers: " << std::endl;
 for(auto const numb: sortedMap)
 std::cout << numb.second << ": " << numb.first << std::endl;
]]></programlisting><para>Végül kiíratásra kerül a sortedMap tartalma, amely az előbbi ciklushoz hasonlóan zajlik.
</para>
    <figure>
            <title>
                Az
                <type>stl</type>
                futás
            </title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="godel/stl.png" scale="250"/>
                </imageobject>
                <textobject>
                    <phrase>
                        Az
                        <type>stl</type>
                        futás
                    </phrase>
                </textobject>
            </mediaobject>
        </figure>

    </section>

<!-- 	<section>
	<title>Alternatív Tabella rendezése</title>
	<para>Mutassuk be a https://progpater.blog.hu/2011/03/11/alternativ_tabella<![CDATA[ a programban a java.lang
Interface Comparable<T> szerepét!]]></para>
</section>

	<section>
	<title>Prolog családfa</title>
	<para>Ágyazd be a Prolog családfa programot C++ vagy Java programba! Lásd para_prog_guide.pdf!</para>
	</section>-->

	<section>
	<title>GIMP Scheme hack</title>
	<para>Ha az előző félévben nem dolgoztad fel a témát (például a mandalás vagy a króm szöveges
dobozosat) akkor itt az alkalom!</para>
	<para>
            Írj olyan script-fu kiterjesztést a GIMP programhoz, amely név-mandalát készít a
            bemenő szövegből!               
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2019/01/10/a_gimp_lisp_hackelese_a_scheme_programozasi_nyelv">https://bhaxor.blog.hu/2019/01/10/a_gimp_lisp_hackelese_a_scheme_programozasi_nyelv</link>      
        </para>
        <para><command>A forráskód Bátfai Norbert tulajdonában áll.</command>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Mandala">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Mandala</link>               
        </para>
<para>
            
            Tanulságok, tapasztalatok, magyarázat...
            A megszokott-tól eltérően a nyelvben nem infix alakban adjuk meg a műveleteket, hanem prefix alakban.

        </para> 
        <programlisting><![CDATA[(define (elem x lista)

    (if (= x 1) (car lista) (elem (- x 1) ( cdr lista ) ) )

)]]></programlisting> 
<para>Mint láthatjuk, itt a define kulcsszóval lehet függvényeket inicializálni.
Ez a függvény az "elem" névre hallgat, és 2 paramétert kér be, az "x"-et és a "lista"-át.
Ha az x=1, akkor a (car lista) parancs hajtódik végre, ha nem, akkor pedig az (elem (x-1) (cdr lista)) parancs.
Ez miatt a sor miatt a függvény rekurzív lesz, hiszen addig hajta végre az "else" ágat, amíg az x!=1.
A car és cdr függvények a lista elején ill. végén lévő elemet adják vissza.
</para>
<programlisting><![CDATA[(define (text-width text font fontsize)
(let*
    (
        (text-width 1)
    )
    (set! text-width (car (gimp-text-get-extents-fontname text fontsize PIXELS font)))    

    text-width
    )
)]]></programlisting>  
<para>
Ez a függvény a szöveg szélességét kezeli.
paraméterként bekéri a szöveget, a betűtípust és a betűméretet.
A függvény törzsében a megadott paraméterekkel a gimp beállítja a szöveg kinézetét.
</para>  
<programlisting><![CDATA[(define (script-fu-bhax-mandala text text2 font fontsize width height color gradient)
(let*
    (]]></programlisting>
    <para>Ezen kezdetű függvény tekinthető a main fügvénynek, hiszen itt alkalmazzuk az előbb megadott függvényeket, itt 
    írjuk a program érdemi részét.
     </para>      
     <programlisting><![CDATA[(gimp-image-insert-layer image layer 0 0)

    (gimp-context-set-foreground '(0 255 0))
    (gimp-drawable-fill layer FILL-FOREGROUND)
    (gimp-image-undo-disable image) ]]></programlisting>
    <para>
    Az első sor beilleszt egy layert, a második sor beállítja annak háttérszínét zöldre, a harmadik sor kitölti a hátteret, az utolsó
    sor pedig újra aktiválja a képet.
    </para>

	</section>
</chapter>     
    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, !</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
   <title>FUTURE tevékenység editor</title> <para>
Javítsunk valamit a ActivityEditor.java JavaFX programon!
https://github.com/nbatfai/future/tree/master/cs/F6
Itt láthatjuk működésben az alapot: https://www.twitch.tv/videos/222879467</para>

<figure>
            <title>
                Az
                <type>editor</type>
                futás
            </title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="future/f6.png" scale="200"/>
                </imageobject>
                <textobject>
                    <phrase>
                        Az
                        <type>editor</type>
                        futás
                    </phrase>
                </textobject>
            </mediaobject>
        </figure>
        <para>látható, hogy a tevékenység-fa-ba kattintás hatására a "tevékenységekhez hozzárendelt tulajdonságok" szöveg eltűnik, ez a szöveg az <command>actPropsLabel</command> objektumban található.
        Ezen bug kiküszöbölhető, ha az else ágból kivesszük a actPropsLabel.setText(""); sort, így csak akkor tűnik el a szöveg, ha egy tevékenységre rákattintunk.
        Viszont a szerekesztés után még ekkor sem jelenik meg újra az alapértelmezett szöveg, helyette üres marad a label.
        A szöveget visszahozhatjuk, ha az onclicked event-ben az item!=null elágazás után beillesszük ezt a pár sort:</para>
        <programlisting language="java"><![CDATA[class FileTree extends javafx.scene.control.TreeView<java.io.File> {
        static final String actlab="A tevékenységekhez hozzárendelt tulajdonságok";
        .
        .
        .
/*ez az if(item!=null) utolsó ága*/} else {

                    save(propsEdit, actPropsLabel);
                    propsEdit.setText("");
                    
                }

        if(item==root){
                    save(propsEdit, actPropsLabel);
            actPropsLabel.setText(actlab);
                }]]></programlisting>
                <para>Ez azt fogja tenni, hogy ha rákattintunk a City-re, ami a gyökérkönyvtár,akkor elmenti a propsEdit-ben található szöveget, majd
                az actPropsLabel szövegét újra beállítja az alapértelmezettre, ezt a szöveget az actlab változóban tároljuk el.</para>
        
        <figure>
            <title>
                Az
                <type>editor javitott</type>
                futása
            </title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="future/f6jav.png" scale="200"/>
                </imageobject>
                <textobject>
                    <phrase>
                        Az
                        <type>editor javitott</type>
                        futása
                    </phrase>
                </textobject>
            </mediaobject>
        </figure>
        
        <para>Sajnos a java 8.1-től nem található meg a java-ban a JavaFX, ezért ezt külön telepítenünk kell,
        A program lefordításához szükségünk van az openjfx 8.u202-3 verziójára(minimum):</para>
        <figure>
            <title>
                A
                <type>javafx</type>
                
            </title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="future/fx.png" scale="200"/>
                </imageobject>
                <textobject>
                    <phrase>
                        A
                        <type>javafx</type>
                        
                    </phrase>
                </textobject>
            </mediaobject>
        </figure>
        <para>kód snippetek a változtatásról:</para>
        <programlisting language="java"><![CDATA[import javafx.scene.paint.Color;
import javafx.scene.paint.Paint;
import javafx.scene.control.TextField;
import javafx.scene.layout.Background;
import javafx.scene.layout.BackgroundFill;
.
.
.
//410-dik sor
public class ActivityEditor extends javafx.application.Application {
]]></programlisting>
<para>a paint.Color osztályt azért importáltuk, mivel használni fogjuk a Color.GREENYELLOW parancsot, na persze bármely színt használhatjuk, miután a class importálva lett.
a paint.Paint osztály felel a háttér "befestéséért", de más ábrák, szövegdobozok és egyéb színezéséért is felelős.Kódunkban a fill objektum (alúl) egy Paint típusú változó. 
A TextField-et használjuk a szövegmezők megjelenítéséhez,a " tevékenységekhez hozzárendelt tulajdonságok" label alatti rész egy ilyen textfield.
A Background és BackgroundFill class-ok a háttér-ért felelősek.
A BackgroundFill teszi lehetővé a háttér színezését, egyedül a Paint nem elegendő.
A 410-edik sor-tól kezdődik az editor megjelenítésének "leírása".</para>
<programlisting language="java"><![CDATA[private static Paint fill;
.
.
.
public void start(javafx.stage.Stage stage) {
    .
    .
    .
  javafx.scene.layout.VBox box = new javafx.scene.layout.VBox();
        box.setBackground(new Background(new BackgroundFill(null,null,null)));
       
        String style = "-fx-background-color: rgba(255, 255, 0, 5);";
        
        final javafx.scene.Scene scene = new javafx.scene.Scene(box,800,400,Color.GREENYELLOW);
.
.
.
javafx.scene.control.TreeView<String> stringTree = new StringTree(properties, true, propsEdit);
        stringTree.setEditable(false);
        stringTree.setBackground(new Background(new BackgroundFill(fill, null,null)));
        
.
.
.

        box.getChildren().add(new javafx.scene.control.Label("Tulajdonságok fája"));

        box.getChildren().add(stringTree);
        box.getChildren().add(new javafx.scene.control.Label("Tevékenységek fája és a tevékenységekhez hozzárendelt tulajdonságok"));
        box.getChildren().add(fileTree);
        box.setStyle(style);]]></programlisting>
        <programlisting language="java"><![CDATA[javafx.scene.layout.VBox box = new javafx.scene.layout.VBox();
         box.setBackground(new Background(new BackgroundFill(null,null,null)));
    ]]></programlisting><para>Ez a sor létrehoz egy vertikális "teret", és a gyermekeit mind egy sorba rendezi ezen a téren belül.
        A setBackground metódusban a BackgroundFill paraméterként null-t kapott, tehát a háttér transzparens/átlátszó. 
        a BackgroundFill második paramétere a CornerRadii, ami a sarok-lekerekítések rádiuszát/sugarát adja meg, a harmadik pedig az inseteket adja meg, ezek a keretek.
        A használatukhoz be kell importálnunk a javafx.geometry.Insets osztályt.</para>
        <programlisting language="java">String style = "-fx-background-color: rgba(255, 255, 0, 5);";</programlisting>
        <para>Ez egy narancssárgás színárnyalatot kölcsönöz a GREENYELLOW szín mellé., az objektumot később, a setStyle metódussal használjuk fel.
        </para>
        <programlisting language="java"><![CDATA[final javafx.scene.Scene scene = new javafx.scene.Scene(box,800,400,Color.GREENYELLOW);
]]></programlisting><para>A scene lesz a "vászon", ezen foglal helyet minden, ha a szövegdobozok háttérszíne nem lenne fehér, akkor láthatnánk, hogy az egész ablak zöldes-sárga.
</para>
<programlisting language="java"><![CDATA[javafx.scene.control.TreeView<String> stringTree = new StringTree(properties, true, propsEdit);
        stringTree.setEditable(false);
        stringTree.setBackground(new Background(new BackgroundFill(fill, null,null)));]]></programlisting>
        <para>Ez a parancs hoz létre egy fa ágazat menüt,paraméterekként egy listát(properties), egy boolean típusú paramétert(az expanded opció ki és bekapcsolására) és egy TextArea szövegmezőt tartalmaz.
        a setEditable funkció segítségével állíthatjuk be, hogy az ágazatunk szerkeszthető legyen-e.
        Végül itt is beállítjuk a hátteret.</para>
        <programlisting language="java">box.getChildren().add()</programlisting><para>Ez a függvény 
        adja hozzá az üres tárolónkhoz a sorokat.</para>
    </section>



<section>
<title>SamuCam</title>
<para>
Mutassunk rá a webcam (pl. Androidos mobilod) kezelésére ebben a projektben:
https://github.com/nbatfai/SamuCam</para>
<programlisting language="c++"><![CDATA[#include "opencv2/objdetect.hpp"
#include "opencv2/videoio.hpp"
#include "opencv2/highgui.hpp"
#include "opencv2/imgproc.hpp"
]]></programlisting><para>
<link xlink:href="https://github.com/opencv/opencv/blob/master/modules/videoio/include/opencv2/videoio.hpp">
https://github.com/opencv/opencv/blob/master/modules/videoio/include/opencv2/videoio.hpp</link>              
     </para>
<programlisting language="c++"><![CDATA[class SamuCam : public QThread
{
    Q_OBJECT

public:
    SamuCam ( std::string videoStream, int width, int height );
    ~SamuCam();

    void openVideoStream();]]></programlisting>
<para>Az opencv segítségével képes a program a kamera használatára, a SamuCam osztály egy QThread objektumot képvisel,
ezen belűl található az openVideoStream, melyet majd a felvétel kezeléséhez használunk a <command>  cv::VideoCapture videoCapture;</command> segítségével.
</para>
<programlisting language="c++"><![CDATA[void SamuCam::openVideoStream()
{
  videoCapture.open ( videoStream );

  videoCapture.set ( CV_CAP_PROP_FRAME_WIDTH, width );
  videoCapture.set ( CV_CAP_PROP_FRAME_HEIGHT, height );
  videoCapture.set ( CV_CAP_PROP_FPS, 10 );
}]]></programlisting>
<para>Itt láthatjuk az openVideoStream felhasználását.
a videoCapture.open indítja el a felvételt, paraméterként pedig egy fájlnevet kap meg.
A metódus először hívja a <command>VideoCapture::release</command>-t, ha a felvétel már folyamatban van.</para>
<para>Alatta beállítjuk a felvétel szélességét és magasságát, valamint az fps rátát.</para>
<programlisting language="c++"><![CDATA[if ( ! videoCapture.isOpened() )
        {
          openVideoStream();
        }
]]></programlisting><para>Ezzel a sorral hívjuk meg a felvételt.</para>
<programlisting language="c++"><![CDATA[void SamuCam::run()
{

  cv::CascadeClassifier faceClassifier;

  std::string faceXML = "lbpcascade_frontalface.xml"; // https://github.com/Itseez/opencv/tree/master/data/lbpcascades

  if ( !faceClassifier.load ( faceXML ) )
    {
      qDebug() << "error: cannot found" << faceXML.c_str();
      return;
    }]]></programlisting><para>Található továbbá a samu::run-ban egy <command>cv::CascadeClassifier</command> is, ez az objektumok értelmezésére hivatott, használatához az objdetect library behívása szükséges.
    </para>
    <para>a faceXML fájl egy osztályozást tárol emberi arcokról,ha a program nem tudja megnyitni a fájlt(mint láthatjuk, a program feltételezi, hogy ez a bizonyos xml fájl azonos mappában található a cpp fájl-al.),
    akkor egy qDebug funkció-n keresztül dob egy hibaüzenetet.
    Ez a Qdebug library-ban található,használatával egyszerűbbé válik a hibák értelmezése.
    Például a <command> QDate::currentDate()</command> metódussal lehetőségünk van a dátum megjelenítésére a hibaüzenetben.</para>
</section>



<section>
<title>BrainB</title>
<para>
Mutassuk be a Qt slot-signal mechanizmust ebben a projektben: https://github.com/nbatfai/esport-talent-search</para>
<programlisting language="c++"><![CDATA[BrainBWin::BrainBWin ( int w, int h, QWidget *parent ) : QMainWindow ( parent )
{

//    setWindowTitle(appName + " " + appVersion);
//    setFixedSize(QSize(w, h));

        statDir = appName + " " + appVersion + " - " + QDate::currentDate().toString() + QString::number ( QDateTime::currentMSecsSinceEpoch() );

        brainBThread = new BrainBThread ( w, h - yshift );
        brainBThread->start();

        connect ( brainBThread, SIGNAL ( heroesChanged ( QImage, int, int ) ),
                  this, SLOT ( updateHeroes ( QImage, int, int ) ) );

        connect ( brainBThread, SIGNAL ( endAndStats ( int ) ),
                  this, SLOT ( endAndStats ( int ) ) );

}
]]></programlisting><para>ez a slot-signal mechanizmus az objektumok közötti kommunikációt teszi lehetővé.
Ez a meta-object rendszer segítségével lehetséges.
</para><para>Más keretrendszerek callback funkciójához hasonlóan működik,viszont a callback-el ellentétben ez a mechanizmus nem küszködik típus-tartási hibákkal, hiszen <command>csak akkor hajtódik végre a slot-ban helyetfoglaló függvény, ha a jel típusa megegyezik a slot-ban várt típussal.</command>
A slotban található funkció virtuálisként is definiálható, és teljes mértékben egy normál funkcióval megegyező függvény található a slotban.
Tehát ha a heroesChanged függvény végrehajtódik, akkor egy jel küldődik az updateHeroes slotba, és ezzel az updateHeroes függvény is végrehajtásra kerül.
</para>
<programlisting language="c++"><![CDATA[QImage dest ( src.data, src.cols, src.rows, src.step, QImage::Format_RGB888 );
        dest=dest.rgbSwapped();
        dest.bits();

        emit heroesChanged ( dest, heroes[0].x, heroes[0].y );

    }]]></programlisting>
<para>A brainBThread header fájlban találunk rá erre a signál-ra,a draw függvényben.</para>
<para>az endAndStats szignál akkor kerül elküldésre, ha lejár az idő, ezt a slot "elkapja" és végrehajtódik az ugyanezzel a névvel ellátott függvény, amely a következőt jeleníti meg:</para>
<programlisting language="c++"><![CDATA[void BrainBWin::endAndStats ( const int &t )
{

        qDebug()  << "\n\n\n";
        qDebug()  << "Thank you for using " + appName;
        qDebug()  << "The result can be found in the directory " + statDir;
        qDebug()  << "\n\n\n";

        save ( t );
        close();
}]]></programlisting><para>megköszöni az app használatát, kiírja a statisztikák "lelőhelyét", elmenti az időt és végül bezárja az ablakot.
</para>
</section>


<section>
<title>OOCWC Boost ASIO hálózatkezelése</title>
<para>
Mutassunk rá a scanf szerepére és használatára! https://github.com/nbatfai/robocar-emulator/blob/master/justine/rcemu/src/carlexer.ll</para>
</section>


<section>
<title>OSM térképre rajzolása</title>
<para>Debrecen térképre dobjunk rá cuccokat, ennek mintájára, ahol én az országba helyeztem el a DEAC
hekkereket: https://www.twitch.tv/videos/182262537 (de az OOCWC Java Swinges
megjelenítőjéből:
https://github.com/nbatfai/robocar-emulator/tree/master/justine/rcwin
is
kiindulhatsz, mondjuk az komplexebb, mert ott időfejlődés is van...)</para></section>
</chapter>     
 <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Schwarzenegger!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

	<section>
<title>Port scan</title>
<para>Mutassunk rá ebben a port szkennelő forrásban a kivételkezelés szerepére!
https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/ch01.html#id527287</para>
<figure>
            <title>
                A
                <type>socket</type>
                futás
            </title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="schwarz/socket.png" scale="150"/>
                </imageobject>
                <textobject>
                    <phrase>
                        A
                        <type>socket</type>
                        futás
                    </phrase>
                </textobject>
            </mediaobject>
        </figure>
	</section>
<programlisting language="java"><![CDATA[try {
                
                java.net.Socket socket = new java.net.Socket(args[0], i);
                
                System.out.println(i + " figyeli");
                
                socket.close();
                
            } catch (Exception e) {
                
                System.out.println(i + " nem figyeli");
                
            }]]></programlisting>

	<section>
<title>AOP</title>
<para>Szőj bele egy átszövő vonatkozást az első védési programod Java átiratába! (Sztenderd védési
feladat volt korábban.)</para>
	</section>


	<section>
<title>Android Játék
</title>
<para>Írjunk egy egyszerű Androidos „játékot”! Építkezzünk például a 2. hét „Helló, Android!” feladatára!</para>
	</section>


	<section>
<title>Junit teszt</title>
<para>A https://progpater.blog.hu/2011/03/05/labormeres_otthon_avagy_hogyan_dolgozok_fel_egy_pedat
poszt kézzel számított mélységét és szórását dolgozd be egy Junit tesztbe (sztenderd védési feladat
volt korábban).</para>
	</section>



	<section>
<title>OSCI</title>
<para>Készíts egyszerű C++/OpenGL-es megjelenítőt, amiben egy kocsit irányítasz az úton. A kocsi
állapotát minden pillanatban mentsd le. Ezeket add át egy Prolog programnak, ami egyszerű reflex
ágensként adjon vezérlést a kocsinak, hasonlítsd össze a kézi és a Prolog-os vezérlést. Módosítsd
úgy a programodat, hogy ne csak kézzel lehessen vezérelni a kocsit, hanem a Prolog reflex ágens
vezérelje!</para>
	</section>

</chapter> 

 <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Calvin!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

	<section>
<title>MNIST</title>
<para>Az alap feladat megoldása, +saját kézzel rajzolt képet is ismerjen fel,
https://progpater.blog.hu/2016/11/13/hello_samu_a_tensorflow-bol Háttérként ezt vetítsük le:
https://prezi.com/0u8ncvvoabcr/no-programming-programming/</para>
	</section>


	<section>
<title>Deep MNIST</title>
<para>Mint az előző, de a mély változattal. Segítő ábra, vesd össze a forráskóddal a
https://arato.inf.unideb.hu/batfai.norbert/NEMESPOR/DE/denbatfai2.pdf 8. fóliáját!</para>
	</section>


	<section>
<title>CIFAR-10</title>
<para>Az alap feladat megoldása, +saját fotót is ismerjen fel,
https://progpater.blog.hu/2016/12/10/hello_samu_a_cifar-10_tf_tutorial_peldabol</para>
	</section>


	<section>
<title>Android telefonra a TF objektum detektálója</title>
<para>Telepítsük fel, próbáljuk ki!</para>
	</section>



	<section>
<title>SMNIST for Machines</title>
<para>Készíts saját modellt, vagy használj meglévőt, lásd: https://arxiv.org/abs/1906.12213</para>
	</section>


	<section>
<title>Minecraft MALMO-s példa</title>
<para><link xlink:href="https://github.com/Microsoft/malmo">A https://github.com/Microsoft/malmo</link> felhasználásával egy ágens példa, lásd pl.:
<link xlink:href="https://youtu.be/bAPSu3Rndi8">youtube</link>, <link xlink:href="https://bhaxor.blog.hu/2018/11/29/eddig_csaltunk_de_innentol_mi">bhax_blog_eddig_csaltunl</link>,
<link xlink:href="https://bhaxor.blog.hu/2018/10/28/minecraft_steve_szemuvege">bhax_szemüveg</link></para>
	</section>

</chapter> 
</part>                                                              


    <bibliography xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Irodalomjegyzék</title>
    <bibliodiv>
        <title>Általános</title>
        <biblioentry xml:lang="hu">
            <abbrev>MARX</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>György</firstname>
                        <surname>Marx</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>Gyorsuló idő</title>
            <publisher>
                <publishername>
                    Typotex
                </publishername>
            </publisher>
            <pubdate>2005</pubdate>
        </biblioentry>  
    </bibliodiv> 
    <bibliodiv>
        <title>C</title>
        <biblioentry>
            <abbrev>KERNIGHANRITCHIE</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Brian W.</firstname>
                        <surname>Kernighan</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>Dennis M.</firstname>
                        <surname>Ritchie</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>A C programozási nyelv</title>
            <publisher>
                <publishername>Bp., Műszaki</publishername>
            </publisher>
            <pubdate>1993</pubdate>
        </biblioentry>            
    </bibliodiv>
    <bibliodiv>
        <title>C++</title>
        <biblioentry>
            <abbrev>BMECPP</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Zoltán</firstname>
                        <surname>Benedek</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>Tihamér</firstname>
                        <surname>Levendovszky</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>Szoftverfejlesztés C++ nyelven</title>
            <publisher>
                <publishername>Bp., Szak Kiadó</publishername>
            </publisher>
            <pubdate>2013</pubdate>
        </biblioentry>            
    </bibliodiv>
    <bibliodiv>
        <title>Lisp</title>
        <biblioentry>
            <abbrev>METAMATH</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Gregory</firstname>
                        <surname>Chaitin</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>META MATH! The Quest for Omega</title>
            <publisher>
                <publishername>
                    <link xlink:href="http://arxiv.org/PS_cache/math/pdf/0404/0404335v7.pdf">http://arxiv.org/PS_cache/math/pdf/0404/0404335v7.pdf</link>
                </publishername>
            </publisher>
            <pubdate>2004</pubdate>
        </biblioentry> 
    </bibliodiv>    
</bibliography>     
          
            <acknowledgements xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <para>
        Köszönet illeti a
        NEMESPOR, <link xlink:href="https://groups.google.com/forum/#!forum/nemespor">https://groups.google.com/forum/#!forum/nemespor</link>, 
        az UDPROG tanulószoba, <link xlink:href="https://www.facebook.com/groups/udprog">https://www.facebook.com/groups/udprog</link>, 
        a DEAC-Hackers előszoba, <link xlink:href="https://www.facebook.com/groups/DEACHackers">https://www.facebook.com/groups/DEACHackers</link> 
        (illetve egyéb alkalmi szerveződésű szakmai csoportok) 
        tagjait inspiráló érdeklődésükért és hasznos észrevételeikért.         
    </para>                 
    <para>
        Ezen túl kiemelt köszönet illeti az említett UDPROG közösséget, mely a Debreceni Egyetem reguláris 
        programozás oktatása tartalmi szervezését támogatja. Sok példa eleve ebben a közösségben született, vagy itt került
        említésre és adott esetekben szerepet kapott, mint oktatási példa.         
    </para>                 
</acknowledgements>     

</book>
